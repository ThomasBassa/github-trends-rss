<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>GitHub Trending: GLSL, This week</title><link>https://github.com/trending/glsl?since=weekly</link><description>The top repositories on GitHub for glsl, measured weekly</description><pubDate>Mon, 09 Dec 2019 01:05:46 GMT</pubDate><lastBuildDate>Mon, 09 Dec 2019 01:05:46 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><ttl>720</ttl><item><title>KhronosGroup/SPIRV-Cross #1 in GLSL, This week</title><link>https://github.com/KhronosGroup/SPIRV-Cross</link><description>&lt;p&gt;&lt;i&gt;SPIRV-Cross is a practical tool and library for performing reflection on SPIR-V and disassembling SPIR-V back to high level languages.&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="instapaper_body md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-spirv-cross" class="anchor" aria-hidden="true" href="#spirv-cross"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SPIRV-Cross&lt;/h1&gt;
&lt;p&gt;SPIRV-Cross is a tool designed for parsing and converting SPIR-V to other shader languages.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/KhronosGroup/SPIRV-Cross" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/9493bb773eeda1f4bbfd51537f34e2a8bb7b8fc9/68747470733a2f2f7472617669732d63692e6f72672f4b68726f6e6f7347726f75702f53504952562d43726f73732e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/KhronosGroup/SPIRV-Cross.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://ci.appveyor.com/project/HansKristian-Work/SPIRV-Cross" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/2e2a8367664bea2208de849a39240af9ba8e4b5c/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f6769746875622f4b68726f6e6f7347726f75702f53504952562d43726f73733f7376673d74727565266272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/github/KhronosGroup/SPIRV-Cross?svg=true&amp;amp;branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-features" class="anchor" aria-hidden="true" href="#features"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Convert SPIR-V to readable, usable and efficient GLSL&lt;/li&gt;
&lt;li&gt;Convert SPIR-V to readable, usable and efficient Metal Shading Language (MSL)&lt;/li&gt;
&lt;li&gt;Convert SPIR-V to readable, usable and efficient HLSL&lt;/li&gt;
&lt;li&gt;Convert SPIR-V to debuggable C++ [DEPRECATED]&lt;/li&gt;
&lt;li&gt;Convert SPIR-V to a JSON reflection format [EXPERIMENTAL]&lt;/li&gt;
&lt;li&gt;Reflection API to simplify the creation of Vulkan pipeline layouts&lt;/li&gt;
&lt;li&gt;Reflection API to modify and tweak OpDecorations&lt;/li&gt;
&lt;li&gt;Supports "all" of vertex, fragment, tessellation, geometry and compute shaders.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SPIRV-Cross tries hard to emit readable and clean output from the SPIR-V.
The goal is to emit GLSL or MSL that looks like it was written by a human and not awkward IR/assembly-like code.&lt;/p&gt;
&lt;p&gt;NOTE: Individual features are expected to be mostly complete, but it is possible that certain obscure GLSL features are not yet supported.
However, most missing features are expected to be "trivial" improvements at this stage.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-building" class="anchor" aria-hidden="true" href="#building"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Building&lt;/h2&gt;
&lt;p&gt;SPIRV-Cross has been tested on Linux, iOS/OSX, Windows and Android. CMake is the main build system.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-linux-and-macos" class="anchor" aria-hidden="true" href="#linux-and-macos"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Linux and macOS&lt;/h3&gt;
&lt;p&gt;Building with CMake is recommended, as it is the only build system which is tested in continuous integration.
It is also the only build system which has install commands and other useful build system features.&lt;/p&gt;
&lt;p&gt;However, you can just run &lt;code&gt;make&lt;/code&gt; on the command line as a fallback if you only care about the CLI tool.&lt;/p&gt;
&lt;p&gt;A non-ancient GCC (4.8+) or Clang (3.x+) compiler is required as SPIRV-Cross uses C++11 extensively.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-windows" class="anchor" aria-hidden="true" href="#windows"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Windows&lt;/h3&gt;
&lt;p&gt;Building with CMake is recommended, which is the only way to target MSVC.
MinGW-w64 based compilation works with &lt;code&gt;make&lt;/code&gt; as a fallback.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-android" class="anchor" aria-hidden="true" href="#android"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Android&lt;/h3&gt;
&lt;p&gt;SPIRV-Cross is only useful as a library here. Use the CMake build to link SPIRV-Cross to your project.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-c-exceptions" class="anchor" aria-hidden="true" href="#c-exceptions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;C++ exceptions&lt;/h3&gt;
&lt;p&gt;The make and CMake build flavors offer the option to treat exceptions as assertions. To disable exceptions for make just append &lt;code&gt;SPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS=1&lt;/code&gt; to the command line. For CMake append &lt;code&gt;-DSPIRV_CROSS_EXCEPTIONS_TO_ASSERTIONS=ON&lt;/code&gt;. By default exceptions are enabled.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-static-shared-and-cli" class="anchor" aria-hidden="true" href="#static-shared-and-cli"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Static, shared and CLI&lt;/h3&gt;
&lt;p&gt;You can use &lt;code&gt;-DSPIRV_CROSS_STATIC=ON/OFF&lt;/code&gt; &lt;code&gt;-DSPIRV_CROSS_SHARED=ON/OFF&lt;/code&gt; &lt;code&gt;-DSPIRV_CROSS_CLI=ON/OFF&lt;/code&gt; to control which modules are built (and installed).&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Usage&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-using-the-c-api" class="anchor" aria-hidden="true" href="#using-the-c-api"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using the C++ API&lt;/h3&gt;
&lt;p&gt;The C++ API is the main API for SPIRV-Cross. For more in-depth documentation than what's provided in this README,
please have a look at the &lt;a href="https://github.com/KhronosGroup/SPIRV-Cross/wiki"&gt;Wiki&lt;/a&gt;.
&lt;strong&gt;NOTE&lt;/strong&gt;: This API is not guaranteed to be ABI-stable, and it is highly recommended to link against this API statically.
The API is generally quite stable, but it can change over time, see the C API for more stability.&lt;/p&gt;
&lt;p&gt;To perform reflection and convert to other shader languages you can use the SPIRV-Cross API.
For example:&lt;/p&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;#&lt;span class="pl-k"&gt;include&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;spirv_glsl.hpp&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
#&lt;span class="pl-k"&gt;include&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;&amp;lt;&lt;/span&gt;vector&lt;span class="pl-pds"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;
#&lt;span class="pl-k"&gt;include&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;&amp;lt;&lt;/span&gt;utility&lt;span class="pl-pds"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-k"&gt;extern&lt;/span&gt; std::vector&amp;lt;&lt;span class="pl-c1"&gt;uint32_t&lt;/span&gt;&amp;gt; &lt;span class="pl-en"&gt;load_spirv_file&lt;/span&gt;();

&lt;span class="pl-k"&gt;int&lt;/span&gt; &lt;span class="pl-en"&gt;main&lt;/span&gt;()
{
	&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Read SPIR-V from disk or similar.&lt;/span&gt;
	std::vector&amp;lt;&lt;span class="pl-c1"&gt;uint32_t&lt;/span&gt;&amp;gt; spirv_binary = &lt;span class="pl-c1"&gt;load_spirv_file&lt;/span&gt;();

	spirv_cross::CompilerGLSL &lt;span class="pl-smi"&gt;glsl&lt;/span&gt;(&lt;span class="pl-c1"&gt;std::move&lt;/span&gt;(spirv_binary));

	&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; The SPIR-V is now parsed, and we can perform reflection on it.&lt;/span&gt;
	spirv_cross::ShaderResources resources = glsl.&lt;span class="pl-c1"&gt;get_shader_resources&lt;/span&gt;();

	&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Get all sampled images in the shader.&lt;/span&gt;
	&lt;span class="pl-k"&gt;for&lt;/span&gt; (&lt;span class="pl-k"&gt;auto&lt;/span&gt; &amp;amp;resource : resources.&lt;span class="pl-smi"&gt;sampled_images&lt;/span&gt;)
	{
		&lt;span class="pl-k"&gt;unsigned&lt;/span&gt; set = glsl.&lt;span class="pl-c1"&gt;get_decoration&lt;/span&gt;(resource.&lt;span class="pl-smi"&gt;id&lt;/span&gt;, spv::DecorationDescriptorSet);
		&lt;span class="pl-k"&gt;unsigned&lt;/span&gt; binding = glsl.&lt;span class="pl-c1"&gt;get_decoration&lt;/span&gt;(resource.&lt;span class="pl-smi"&gt;id&lt;/span&gt;, spv::DecorationBinding);
		&lt;span class="pl-c1"&gt;printf&lt;/span&gt;(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Image %s at set = %u, binding = %u&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, resource.&lt;span class="pl-smi"&gt;name&lt;/span&gt;.&lt;span class="pl-c1"&gt;c_str&lt;/span&gt;(), set, binding);

		&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Modify the decoration to prepare it for GLSL.&lt;/span&gt;
		glsl.&lt;span class="pl-c1"&gt;unset_decoration&lt;/span&gt;(resource.&lt;span class="pl-smi"&gt;id&lt;/span&gt;, spv::DecorationDescriptorSet);

		&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Some arbitrary remapping if we want.&lt;/span&gt;
		glsl.&lt;span class="pl-c1"&gt;set_decoration&lt;/span&gt;(resource.&lt;span class="pl-smi"&gt;id&lt;/span&gt;, spv::DecorationBinding, set * &lt;span class="pl-c1"&gt;16&lt;/span&gt; + binding);
	}

	&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Set some options.&lt;/span&gt;
	spirv_cross::CompilerGLSL::Options options;
	options.&lt;span class="pl-smi"&gt;version&lt;/span&gt; = &lt;span class="pl-c1"&gt;310&lt;/span&gt;;
	options.&lt;span class="pl-smi"&gt;es&lt;/span&gt; = &lt;span class="pl-c1"&gt;true&lt;/span&gt;;
	glsl.&lt;span class="pl-c1"&gt;set_options&lt;/span&gt;(options);

	&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Compile to GLSL, ready to give to GL driver.&lt;/span&gt;
	std::string source = glsl.&lt;span class="pl-c1"&gt;compile&lt;/span&gt;();
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-using-the-c-api-wrapper" class="anchor" aria-hidden="true" href="#using-the-c-api-wrapper"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using the C API wrapper&lt;/h3&gt;
&lt;p&gt;To facilitate C compatibility and compatibility with foreign programming languages, a C89-compatible API wrapper is provided. Unlike the C++ API,
the goal of this wrapper is to be fully stable, both API and ABI-wise.
This is the only interface which is supported when building SPIRV-Cross as a shared library.&lt;/p&gt;
&lt;p&gt;An important point of the wrapper is that all memory allocations are contained in the &lt;code&gt;spvc_context&lt;/code&gt;.
This simplifies the use of the API greatly. However, you should destroy the context as soon as reasonable,
or use &lt;code&gt;spvc_context_release_allocations()&lt;/code&gt; if you intend to reuse the &lt;code&gt;spvc_context&lt;/code&gt; object again soon.&lt;/p&gt;
&lt;p&gt;Most functions return a &lt;code&gt;spvc_result&lt;/code&gt;, where &lt;code&gt;SPVC_SUCCESS&lt;/code&gt; is the only success code.
For brevity, the code below does not do any error checking.&lt;/p&gt;
&lt;div class="highlight highlight-source-c"&gt;&lt;pre&gt;#&lt;span class="pl-k"&gt;include&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;&amp;lt;&lt;/span&gt;spirv_cross_c.h&lt;span class="pl-pds"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-k"&gt;const&lt;/span&gt; SpvId *spirv = get_spirv_data();
&lt;span class="pl-c1"&gt;size_t&lt;/span&gt; word_count = get_spirv_word_count();

spvc_context context = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
spvc_parsed_ir ir = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
spvc_compiler compiler_glsl = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
spvc_compiler_options options = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
spvc_resources resources = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
&lt;span class="pl-k"&gt;const&lt;/span&gt; spvc_reflected_resource *list = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
&lt;span class="pl-k"&gt;const&lt;/span&gt; &lt;span class="pl-k"&gt;char&lt;/span&gt; *result = &lt;span class="pl-c1"&gt;NULL&lt;/span&gt;;
&lt;span class="pl-c1"&gt;size_t&lt;/span&gt; count;
&lt;span class="pl-c1"&gt;size_t&lt;/span&gt; i;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Create context.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_context_create&lt;/span&gt;(&amp;amp;context);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Set debug callback.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_context_set_error_callback&lt;/span&gt;(context, error_callback, userdata);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Parse the SPIR-V.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_context_parse_spirv&lt;/span&gt;(context, spirv, word_count, &amp;amp;ir);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Hand it off to a compiler instance and give it ownership of the IR.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_context_create_compiler&lt;/span&gt;(context, SPVC_BACKEND_GLSL, ir, SPVC_CAPTURE_MODE_TAKE_OWNERSHIP, &amp;amp;compiler_glsl);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Do some basic reflection.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_compiler_create_shader_resources&lt;/span&gt;(compiler_glsl, &amp;amp;resources);
&lt;span class="pl-en"&gt;spvc_resources_get_resource_list_for_type&lt;/span&gt;(resources, SPVC_RESOURCE_TYPE_UNIFORM_BUFFER, &amp;amp;list, &amp;amp;count);

&lt;span class="pl-k"&gt;for&lt;/span&gt; (i = &lt;span class="pl-c1"&gt;0&lt;/span&gt;; i &amp;lt; count; i++)
{
    &lt;span class="pl-c1"&gt;printf&lt;/span&gt;(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;ID: &lt;span class="pl-c1"&gt;%u&lt;/span&gt;, BaseTypeID: &lt;span class="pl-c1"&gt;%u&lt;/span&gt;, TypeID: &lt;span class="pl-c1"&gt;%u&lt;/span&gt;, Name: &lt;span class="pl-c1"&gt;%s&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, list[i].&lt;span class="pl-smi"&gt;id&lt;/span&gt;, list[i].&lt;span class="pl-smi"&gt;base_type_id&lt;/span&gt;, list[i].&lt;span class="pl-smi"&gt;type_id&lt;/span&gt;,
           list[i].&lt;span class="pl-smi"&gt;name&lt;/span&gt;);
    &lt;span class="pl-c1"&gt;printf&lt;/span&gt;(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;  Set: &lt;span class="pl-c1"&gt;%u&lt;/span&gt;, Binding: &lt;span class="pl-c1"&gt;%u&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
           &lt;span class="pl-c1"&gt;spvc_compiler_get_decoration&lt;/span&gt;(compiler_glsl, list[i].&lt;span class="pl-smi"&gt;id&lt;/span&gt;, SpvDecorationDescriptorSet),
           &lt;span class="pl-c1"&gt;spvc_compiler_get_decoration&lt;/span&gt;(compiler_glsl, list[i].&lt;span class="pl-smi"&gt;id&lt;/span&gt;, SpvDecorationBinding));
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Modify options.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_compiler_create_compiler_options&lt;/span&gt;(context, &amp;amp;options);
&lt;span class="pl-en"&gt;spvc_compiler_options_set_uint&lt;/span&gt;(options, SPVC_COMPILER_OPTION_GLSL_VERSION, &lt;span class="pl-c1"&gt;330&lt;/span&gt;);
&lt;span class="pl-en"&gt;spvc_compiler_options_set_bool&lt;/span&gt;(options, SPVC_COMPILER_OPTION_GLSL_ES, SPVC_FALSE);
&lt;span class="pl-en"&gt;spvc_compiler_install_compiler_options&lt;/span&gt;(compiler_glsl, options);

&lt;span class="pl-en"&gt;spvc_compiler_compile&lt;/span&gt;(compiler, &amp;amp;result);
&lt;span class="pl-en"&gt;printf&lt;/span&gt;(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Cross-compiled source: &lt;span class="pl-c1"&gt;%s&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, result);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Frees all memory we allocated so far.&lt;/span&gt;
&lt;span class="pl-en"&gt;spvc_context_destroy&lt;/span&gt;(context);&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-linking" class="anchor" aria-hidden="true" href="#linking"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Linking&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-cmake-add_subdirectory" class="anchor" aria-hidden="true" href="#cmake-add_subdirectory"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CMake add_subdirectory()&lt;/h4&gt;
&lt;p&gt;This is the recommended way if you are using CMake and want to link against SPIRV-Cross statically.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-integrating-spirv-cross-in-a-custom-build-system" class="anchor" aria-hidden="true" href="#integrating-spirv-cross-in-a-custom-build-system"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Integrating SPIRV-Cross in a custom build system&lt;/h4&gt;
&lt;p&gt;To add SPIRV-Cross to your own codebase, just copy the source and header files from root directory
and build the relevant .cpp files you need. Make sure to build with C++11 support, e.g. &lt;code&gt;-std=c++11&lt;/code&gt; in GCC and Clang.
Alternatively, the Makefile generates a libspirv-cross.a static library during build that can be linked in.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-linking-against-spirv-cross-as-a-system-library" class="anchor" aria-hidden="true" href="#linking-against-spirv-cross-as-a-system-library"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Linking against SPIRV-Cross as a system library&lt;/h4&gt;
&lt;p&gt;It is possible to link against SPIRV-Cross when it is installed as a system library,
which would be mostly relevant for Unix-like platforms.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-pkg-config" class="anchor" aria-hidden="true" href="#pkg-config"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;pkg-config&lt;/h5&gt;
&lt;p&gt;For Unix-based systems, a pkg-config is installed for the C API, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pkg-config spirv-cross-c-shared --libs --cflags
-I/usr/local/include/spirv_cross -L/usr/local/lib -lspirv-cross-c-shared
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;&lt;a id="user-content-cmake" class="anchor" aria-hidden="true" href="#cmake"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CMake&lt;/h5&gt;
&lt;p&gt;If the project is installed, it can be found with &lt;code&gt;find_package()&lt;/code&gt;, e.g.:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmake_minimum_required(VERSION 3.5)
set(CMAKE_C_STANDARD 99)
project(Test LANGUAGES C)

find_package(spirv_cross_c_shared)
if (spirv_cross_c_shared_FOUND)
        message(STATUS "Found SPIRV-Cross C API! :)")
else()
        message(STATUS "Could not find SPIRV-Cross C API! :(")
endif()

add_executable(test test.c)
target_link_libraries(test spirv-cross-c-shared)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;test.c:&lt;/p&gt;
&lt;div class="highlight highlight-source-c"&gt;&lt;pre&gt;#&lt;span class="pl-k"&gt;include&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;&amp;lt;&lt;/span&gt;spirv_cross_c.h&lt;span class="pl-pds"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-k"&gt;int&lt;/span&gt; &lt;span class="pl-en"&gt;main&lt;/span&gt;(&lt;span class="pl-k"&gt;void&lt;/span&gt;)
{
        spvc_context context;
        &lt;span class="pl-c1"&gt;spvc_context_create&lt;/span&gt;(&amp;amp;context);
        &lt;span class="pl-c1"&gt;spvc_context_destroy&lt;/span&gt;(context);
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-cli" class="anchor" aria-hidden="true" href="#cli"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CLI&lt;/h3&gt;
&lt;p&gt;The CLI is suitable for basic cross-compilation tasks, but it cannot support the full flexibility that the API can.
Some examples below.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-creating-a-spir-v-file-from-glsl-with-glslang" class="anchor" aria-hidden="true" href="#creating-a-spir-v-file-from-glsl-with-glslang"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Creating a SPIR-V file from GLSL with glslang&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;glslangValidator -H -V -o test.spv test.frag
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a id="user-content-converting-a-spir-v-file-to-glsl-es" class="anchor" aria-hidden="true" href="#converting-a-spir-v-file-to-glsl-es"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Converting a SPIR-V file to GLSL ES&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;glslangValidator -H -V -o test.spv shaders/comp/basic.comp
./spirv-cross --version 310 --es test.spv
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a id="user-content-converting-to-desktop-glsl" class="anchor" aria-hidden="true" href="#converting-to-desktop-glsl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Converting to desktop GLSL&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;glslangValidator -H -V -o test.spv shaders/comp/basic.comp
./spirv-cross --version 330 --no-es test.spv --output test.comp
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a id="user-content-disable-prettifying-optimizations" class="anchor" aria-hidden="true" href="#disable-prettifying-optimizations"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Disable prettifying optimizations&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;glslangValidator -H -V -o test.spv shaders/comp/basic.comp
./spirv-cross --version 310 --es test.spv --output test.comp --force-temporary
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a id="user-content-using-shaders-generated-from-c-backend" class="anchor" aria-hidden="true" href="#using-shaders-generated-from-c-backend"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using shaders generated from C++ backend&lt;/h3&gt;
&lt;p&gt;Please see &lt;code&gt;samples/cpp&lt;/code&gt; where some GLSL shaders are compiled to SPIR-V, decompiled to C++ and run with test data.
Reading through the samples should explain how to use the C++ interface.
A simple Makefile is included to build all shaders in the directory.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-implementation-notes" class="anchor" aria-hidden="true" href="#implementation-notes"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Implementation notes&lt;/h3&gt;
&lt;p&gt;When using SPIR-V and SPIRV-Cross as an intermediate step for cross-compiling between high level languages there are some considerations to take into account,
as not all features used by one high-level language are necessarily supported natively by the target shader language.
SPIRV-Cross aims to provide the tools needed to handle these scenarios in a clean and robust way, but some manual action is required to maintain compatibility.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-hlsl-source-to-glsl" class="anchor" aria-hidden="true" href="#hlsl-source-to-glsl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HLSL source to GLSL&lt;/h4&gt;
&lt;h5&gt;&lt;a id="user-content-hlsl-entry-points" class="anchor" aria-hidden="true" href="#hlsl-entry-points"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HLSL entry points&lt;/h5&gt;
&lt;p&gt;When using SPIR-V shaders compiled from HLSL, there are some extra things you need to take care of.
First make sure that the entry point is used correctly.
If you forget to set the entry point correctly in glslangValidator (-e MyFancyEntryPoint),
you will likely encounter this error message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Cannot end a function before ending the current block.
Likely cause: If this SPIR-V was created from glslang HLSL, make sure the entry point is valid.
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;&lt;a id="user-content-vertexfragment-interface-linking" class="anchor" aria-hidden="true" href="#vertexfragment-interface-linking"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Vertex/Fragment interface linking&lt;/h5&gt;
&lt;p&gt;HLSL relies on semantics in order to effectively link together shader stages. In the SPIR-V generated by glslang, the transformation from HLSL to GLSL ends up looking like&lt;/p&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;struct&lt;/span&gt; &lt;span class="pl-en"&gt;VSOutput&lt;/span&gt; {
   &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; SV_Position is rerouted to gl_Position&lt;/span&gt;
   float4 position : SV_Position;
   float4 coord : TEXCOORD0;
};

VSOutput &lt;span class="pl-en"&gt;main&lt;/span&gt;(...) {}&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;struct&lt;/span&gt; &lt;span class="pl-en"&gt;VSOutput&lt;/span&gt; {
   float4 coord;
}&lt;span class="pl-ii"&gt;&lt;/span&gt;
&lt;span class="pl-en"&gt;layout&lt;/span&gt;(location = &lt;span class="pl-c1"&gt;0&lt;/span&gt;) out VSOutput _magicNameGeneratedByGlslang;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While this works, be aware of the type of the struct which is used in the vertex stage and the fragment stage.
There may be issues if the structure type name differs in vertex stage and fragment stage.&lt;/p&gt;
&lt;p&gt;You can make use of the reflection interface to force the name of the struct type.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Something like this for both vertex outputs and fragment inputs.
compiler.set_name(varying_resource.base_type_id, "VertexFragmentLinkage");
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Some platform may require identical variable name for both vertex outputs and fragment inputs. (for example MacOSX)
to rename varaible base on location, please add&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;--rename-interface-variable &amp;lt;in|out&amp;gt; &amp;lt;location&amp;gt; &amp;lt;new_variable_name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;&lt;a id="user-content-hlsl-source-to-legacy-glslessl" class="anchor" aria-hidden="true" href="#hlsl-source-to-legacy-glslessl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HLSL source to legacy GLSL/ESSL&lt;/h4&gt;
&lt;p&gt;HLSL tends to emit varying struct types to pass data between vertex and fragment.
This is not supported in legacy GL/GLES targets, so to support this, varying structs are flattened.
This is done automatically, but the API user might need to be aware that this is happening in order to support all cases.&lt;/p&gt;
&lt;p&gt;Modern GLES code like this:&lt;/p&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;struct&lt;/span&gt; &lt;span class="pl-en"&gt;Output&lt;/span&gt; {
   vec4 a;
   vec2 b;
};
out Output vout;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Is transformed into:&lt;/p&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;struct&lt;/span&gt; &lt;span class="pl-en"&gt;Output&lt;/span&gt; {
   vec4 a;
   vec2 b;
};
varying vec4 Output_a;
varying vec2 Output_b;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that now, both the struct name and the member names will participate in the linking interface between vertex and fragment, so
API users might want to ensure that both the struct names and member names match so that vertex outputs and fragment inputs can link properly.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-separate-image-samplers-hlslvulkan-for-backends-which-do-not-support-it-glsl" class="anchor" aria-hidden="true" href="#separate-image-samplers-hlslvulkan-for-backends-which-do-not-support-it-glsl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Separate image samplers (HLSL/Vulkan) for backends which do not support it (GLSL)&lt;/h4&gt;
&lt;p&gt;Another thing you need to remember is when using samplers and textures in HLSL these are separable, and not directly compatible with GLSL. If you need to use this with desktop GL/GLES, you need to call &lt;code&gt;Compiler::build_combined_image_samplers&lt;/code&gt; first before calling &lt;code&gt;Compiler::compile&lt;/code&gt;, or you will get an exception.&lt;/p&gt;
&lt;div class="highlight highlight-source-c++"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; From main.cpp&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Builds a mapping for all combinations of images and samplers.&lt;/span&gt;
compiler-&amp;gt;&lt;span class="pl-en"&gt;build_combined_image_samplers&lt;/span&gt;();

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Give the remapped combined samplers new names.&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Here you can also set up decorations if you want (binding = #N).&lt;/span&gt;
&lt;span class="pl-k"&gt;for&lt;/span&gt; (&lt;span class="pl-k"&gt;auto&lt;/span&gt; &amp;amp;remap : compiler-&amp;gt;&lt;span class="pl-en"&gt;get_combined_image_samplers&lt;/span&gt;())
{
   compiler-&amp;gt;&lt;span class="pl-c1"&gt;set_name&lt;/span&gt;(remap.&lt;span class="pl-smi"&gt;combined_id&lt;/span&gt;, &lt;span class="pl-c1"&gt;join&lt;/span&gt;(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;SPIRV_Cross_Combined&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, compiler-&amp;gt;&lt;span class="pl-c1"&gt;get_name&lt;/span&gt;(remap.&lt;span class="pl-smi"&gt;image_id&lt;/span&gt;),
            compiler-&amp;gt;&lt;span class="pl-c1"&gt;get_name&lt;/span&gt;(remap.&lt;span class="pl-smi"&gt;sampler_id&lt;/span&gt;)));
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If your target is Vulkan GLSL, &lt;code&gt;--vulkan-semantics&lt;/code&gt; will emit separate image samplers as you'd expect.
The command line client calls &lt;code&gt;Compiler::build_combined_image_samplers&lt;/code&gt; automatically, but if you're calling the library, you'll need to do this yourself.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-descriptor-sets-vulkan-glsl-for-backends-which-do-not-support-them-hlslglslmetal" class="anchor" aria-hidden="true" href="#descriptor-sets-vulkan-glsl-for-backends-which-do-not-support-them-hlslglslmetal"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Descriptor sets (Vulkan GLSL) for backends which do not support them (HLSL/GLSL/Metal)&lt;/h4&gt;
&lt;p&gt;Descriptor sets are unique to Vulkan, so make sure that descriptor set + binding is remapped to a flat binding scheme (set always 0), so that other APIs can make sense of the bindings.
This can be done with &lt;code&gt;Compiler::set_decoration(id, spv::DecorationDescriptorSet)&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-linking-by-name-for-targets-which-do-not-support-explicit-locations-legacy-glslessl" class="anchor" aria-hidden="true" href="#linking-by-name-for-targets-which-do-not-support-explicit-locations-legacy-glslessl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Linking by name for targets which do not support explicit locations (legacy GLSL/ESSL)&lt;/h4&gt;
&lt;p&gt;Modern GLSL and HLSL sources (and SPIR-V) relies on explicit layout(location) qualifiers to guide the linking process between shader stages,
but older GLSL relies on symbol names to perform the linking. When emitting shaders with older versions, these layout statements will be removed,
so it is important that the API user ensures that the names of I/O variables are sanitized so that linking will work properly.
The reflection API can rename variables, struct types and struct members to deal with these scenarios using &lt;code&gt;Compiler::set_name&lt;/code&gt; and friends.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-clip-space-conventions" class="anchor" aria-hidden="true" href="#clip-space-conventions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Clip-space conventions&lt;/h4&gt;
&lt;p&gt;SPIRV-Cross can perform some common clip space conversions on gl_Position/SV_Position by enabling &lt;code&gt;CompilerGLSL::Options.vertex.fixup_clipspace&lt;/code&gt;.
While this can be convenient, it is recommended to modify the projection matrices instead as that can achieve the same result.&lt;/p&gt;
&lt;p&gt;For GLSL targets, enabling this will convert a shader which assumes &lt;code&gt;[0, w]&lt;/code&gt; depth range (Vulkan / D3D / Metal) into &lt;code&gt;[-w, w]&lt;/code&gt; range.
For MSL and HLSL targets, enabling this will convert a shader in &lt;code&gt;[-w, w]&lt;/code&gt; depth range (OpenGL) to &lt;code&gt;[0, w]&lt;/code&gt; depth range.&lt;/p&gt;
&lt;p&gt;By default, the CLI will not enable &lt;code&gt;fixup_clipspace&lt;/code&gt;, but in the API you might want to set an explicit value using &lt;code&gt;CompilerGLSL::set_options()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Y-flipping of gl_Position and similar is also supported.
The use of this is discouraged, because relying on vertex shader Y-flipping tends to get quite messy.
To enable this, set &lt;code&gt;CompilerGLSL::Options.vertex.flip_vert_y&lt;/code&gt; or &lt;code&gt;--flip-vert-y&lt;/code&gt; in CLI.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Contributing&lt;/h2&gt;
&lt;p&gt;Contributions to SPIRV-Cross are welcome. See Testing and Licensing sections for details.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-testing" class="anchor" aria-hidden="true" href="#testing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Testing&lt;/h3&gt;
&lt;p&gt;SPIRV-Cross maintains a test suite of shaders with reference output of how the output looks after going through a roundtrip through
glslangValidator/spirv-as then back through SPIRV-Cross again.
The reference files are stored inside the repository in order to be able to track regressions.&lt;/p&gt;
&lt;p&gt;All pull requests should ensure that test output does not change unexpectedly. This can be tested with:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./checkout_glslang_spirv_tools.sh # Checks out glslang and SPIRV-Tools at a fixed revision which matches the reference output.
                                  # NOTE: Some users have reported problems cloning from git:// paths. To use https:// instead pass in
                                  # $ PROTOCOL=https ./checkout_glslang_spirv_tools.sh
                                  # instead.
./build_glslang_spirv_tools.sh    # Builds glslang and SPIRV-Tools.
./test_shaders.sh                 # Runs over all changes and makes sure that there are no deltas compared to reference files.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;./test_shaders.sh&lt;/code&gt; currently requires a Makefile setup with GCC/Clang to be set up.
However, on Windows, this can be rather inconvenient if a MinGW environment is not set up.
To use a spirv-cross binary you built with CMake (or otherwise), you can pass in an environment variable as such:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SPIRV_CROSS_PATH=path/to/custom/spirv-cross ./test_shaders.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, when improving SPIRV-Cross there are of course legitimate cases where reference output should change.
In these cases, run:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./update_test_shaders.sh          # SPIRV_CROSS_PATH also works here.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;to update the reference files and include these changes as part of the pull request.
Always make sure you are running the correct version of glslangValidator as well as SPIRV-Tools when updating reference files.
See &lt;code&gt;checkout_glslang_spirv_tools.sh&lt;/code&gt; which revisions are currently expected. The revisions change regularly.&lt;/p&gt;
&lt;p&gt;In short, the master branch should always be able to run &lt;code&gt;./test_shaders.py shaders&lt;/code&gt; and friends without failure.
SPIRV-Cross uses Travis CI to test all pull requests, so it is not strictly needed to perform testing yourself if you have problems running it locally.
A pull request which does not pass testing on Travis will not be accepted however.&lt;/p&gt;
&lt;p&gt;When adding support for new features to SPIRV-Cross, a new shader and reference file should be added which covers usage of the new shader features in question.
Travis CI runs the test suite with the CMake, by running &lt;code&gt;ctest&lt;/code&gt;. This is a more straight-forward alternative to &lt;code&gt;./test_shaders.sh&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-licensing" class="anchor" aria-hidden="true" href="#licensing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Licensing&lt;/h3&gt;
&lt;p&gt;Contributors of new files should add a copyright header at the top of every new source code file with their copyright
along with the Apache 2.0 licensing stub.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-formatting" class="anchor" aria-hidden="true" href="#formatting"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Formatting&lt;/h3&gt;
&lt;p&gt;SPIRV-Cross uses &lt;code&gt;clang-format&lt;/code&gt; to automatically format code.
Please use &lt;code&gt;clang-format&lt;/code&gt; with the style sheet found in &lt;code&gt;.clang-format&lt;/code&gt; to automatically format code before submitting a pull request.&lt;/p&gt;
&lt;p&gt;To make things easy, the &lt;code&gt;format_all.sh&lt;/code&gt; script can be used to format all
source files in the library. In this directory, run the following from the
command line:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;./format_all.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id="user-content-regression-testing" class="anchor" aria-hidden="true" href="#regression-testing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Regression testing&lt;/h2&gt;
&lt;p&gt;In shaders/ a collection of shaders are maintained for purposes of regression testing.
The current reference output is contained in reference/.
&lt;code&gt;./test_shaders.py shaders&lt;/code&gt; can be run to perform regression testing.&lt;/p&gt;
&lt;p&gt;See &lt;code&gt;./test_shaders.py --help&lt;/code&gt; for more.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-metal-backend" class="anchor" aria-hidden="true" href="#metal-backend"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Metal backend&lt;/h3&gt;
&lt;p&gt;To test the roundtrip path GLSL -&amp;gt; SPIR-V -&amp;gt; MSL, &lt;code&gt;--msl&lt;/code&gt; can be added, e.g. &lt;code&gt;./test_shaders.py --msl shaders-msl&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-hlsl-backend" class="anchor" aria-hidden="true" href="#hlsl-backend"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HLSL backend&lt;/h3&gt;
&lt;p&gt;To test the roundtrip path GLSL -&amp;gt; SPIR-V -&amp;gt; HLSL, &lt;code&gt;--hlsl&lt;/code&gt; can be added, e.g. &lt;code&gt;./test_shaders.py --hlsl shaders-hlsl&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-updating-regression-tests" class="anchor" aria-hidden="true" href="#updating-regression-tests"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Updating regression tests&lt;/h3&gt;
&lt;p&gt;When legitimate changes are found, use &lt;code&gt;--update&lt;/code&gt; flag to update regression files.
Otherwise, &lt;code&gt;./test_shaders.py&lt;/code&gt; will fail with error code.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-mali-offline-compiler-cycle-counts" class="anchor" aria-hidden="true" href="#mali-offline-compiler-cycle-counts"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Mali Offline Compiler cycle counts&lt;/h3&gt;
&lt;p&gt;To obtain a CSV of static shader cycle counts before and after going through spirv-cross, add
&lt;code&gt;--malisc&lt;/code&gt; flag to &lt;code&gt;./test_shaders&lt;/code&gt;. This requires the Mali Offline Compiler to be installed in PATH.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>KhronosGroup</author><guid isPermaLink="false">https://github.com/KhronosGroup/SPIRV-Cross</guid><pubDate>Mon, 09 Dec 2019 00:01:00 GMT</pubDate></item></channel></rss>