<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>GitHub Trending: Haskell, This week</title><link>https://github.com/trending/haskell?since=weekly</link><description>The top repositories on GitHub for haskell, measured weekly</description><pubDate>Tue, 07 Jan 2020 01:11:39 GMT</pubDate><lastBuildDate>Tue, 07 Jan 2020 01:11:39 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><ttl>720</ttl><item><title>graninas/software-design-in-haskell #1 in Haskell, This week</title><link>https://github.com/graninas/software-design-in-haskell</link><description>&lt;p&gt;&lt;i&gt;Software Design in Haskell. A structured set of materials. How to build real-world applications in Haskell.&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-software-design-and-architecture-in-haskell" class="anchor" aria-hidden="true" href="#software-design-and-architecture-in-haskell"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Software Design and Architecture in Haskell&lt;/h1&gt;
&lt;p&gt;A structured set of materials on how to build real-world applications in Haskell.&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;&lt;a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Table of Contents&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Books-on-Software-Architecture-in-Haskell"&gt;Books on Software Architecture in Haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Application-Architectures"&gt;Application Architectures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Design-Approaches-and-Design-Patterns"&gt;Design Approaches and Design Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Free-Monads"&gt;Free Monads&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Final-Tagless--mtl"&gt;Final Tagless / mtl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Effect-Systems"&gt;Effect Systems&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ReaderT-Pattern"&gt;ReaderT Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Service-Handle-Pattern"&gt;Service Handle Pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Other-Patterns"&gt;Other Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#OOP-Design-Patterns-vs-FP-Design-Patterns"&gt;OOP Design Patterns vs FP Design Patterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Comparison-of-Approaches"&gt;Comparison of Approaches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Comparison-Table"&gt;Comparison Table&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#Design-Principles"&gt;Design Principles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Methodologies-and-philosophy"&gt;Methodologies and Philosophy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Best-Practices--Guidelines"&gt;Best Practices &amp;amp; Guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Showcase-Projects--Code-Orgranization-Samples"&gt;Showcase Projects &amp;amp; Code Organization Samples&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Haskell-in-Production--Success-Stories--Experience-Reports"&gt;Haskell in Production. Success Stories, Experience Reports&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Talks"&gt;Talks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Haskell-Ecosystem-and-Accessibility"&gt;Haskell Ecosystem and Accessibility&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#Haskell-Ecosystem-and-Community"&gt;Haskell Ecosystem and Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#Haskell-Learn--Books"&gt;Haskell Learn: Books&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1&gt;&lt;a id="user-content-books-on-software-architecture-in-haskell" class="anchor" aria-hidden="true" href="#books-on-software-architecture-in-haskell"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Books on Software Architecture in Haskell&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://graninas.com/functional-design-and-architecture-book/" rel="nofollow"&gt;Functional Design and Architecture&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.apress.com/gp/book/9781484244791" rel="nofollow"&gt;Practical Haskell. A Real World Guide to Programming&lt;/a&gt; | &lt;strong&gt;Serrano, Alejandro&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://book.realworldhaskell.org/" rel="nofollow"&gt;Real World Haskell&lt;/a&gt; | &lt;strong&gt;Bryan O'Sullivan, Don Stewart, John Goerzen&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tssm/up-to-date-real-world-haskell"&gt;Up-to-date Real World Haskell&lt;/a&gt; | &lt;strong&gt;Bryan O'Sullivan, Don Stewart, John Goerzen, Tae Sandoval&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-application-architectures" class="anchor" aria-hidden="true" href="#application-architectures"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Application Architectures&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.parsonsmatt.org/2018/03/22/three_layer_haskell_cake.html" rel="nofollow"&gt;Three Layer Haskell Cake&lt;/a&gt; | &lt;strong&gt;Matt Parsons&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://degoes.net/articles/modern-fp" rel="nofollow"&gt;A Modern Architecture for FP&lt;/a&gt; | &lt;strong&gt;John A De Goes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://degoes.net/articles/modern-fp-part-2" rel="nofollow"&gt;Modern Functional Programming: Part 2&lt;/a&gt; | &lt;strong&gt;John A De Goes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://abailly.github.io/posts/cm-arch-design.html" rel="nofollow"&gt;Anatomy of a Haskell-based Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.onikudaki.net/blog/archives/6" rel="nofollow"&gt;Architecture of a Real World Haskell Application&lt;/a&gt; | &lt;strong&gt;Michael Oswald&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/3GKQ4ni2pS0" rel="nofollow"&gt;Hierarchical Free Monads and Software Design in Functional Programming (Talk)&lt;/a&gt; | &lt;a href="https://docs.google.com/presentation/d/1SYMIZ-LOI8Ylykz0PTxwiPuHN_02gIWh9AjJDO6xbvM/edit?usp=sharing" rel="nofollow"&gt;Slides&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | FunctionalConf 2019, Bangalore, India&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.pinterest.ru/pin/791929915696726474/#amp" rel="nofollow"&gt;Hexagonal Architecture and Free Monad: Two related design patterns?&lt;/a&gt; | &lt;strong&gt;Quentin Duval&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://stackoverflow.com/questions/3077866/large-scale-design-in-haskell" rel="nofollow"&gt;Large-scale design in Haskell? (SO question)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-design-approaches-and-design-patterns" class="anchor" aria-hidden="true" href="#design-approaches-and-design-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Design Approaches and Design Patterns&lt;/h1&gt;
&lt;h3&gt;&lt;a id="user-content-free-monads" class="anchor" aria-hidden="true" href="#free-monads"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Free Monads&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html" rel="nofollow"&gt;Why free monads matter&lt;/a&gt; | &lt;strong&gt;Gabriel Gonzalez&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://joa.sh/posts/2015-09-13-free-monad-steps.html" rel="nofollow"&gt;Free monads in 7 easy steps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://degoes.net/articles/modern-fp" rel="nofollow"&gt;A Modern Architecture for FP&lt;/a&gt; | &lt;strong&gt;John A De Goes&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/graninas/9beb8df5d88dda5fa21c47ce9bcb0e16"&gt;Building network actors with Node Framework&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | &lt;em&gt;Note: a Free monadic architecture is described there.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/graninas/automatic-whitebox-testing-showcase"&gt;Automatic White-Box Testing with Free Monads&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | &lt;a href="https://github.com/graninas/automatic-whitebox-testing-showcase"&gt;Showcase&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/3GKQ4ni2pS0" rel="nofollow"&gt;Hierarchical Free Monads and Software Design in Functional Programming (Talk)&lt;/a&gt; | &lt;a href="https://docs.google.com/presentation/d/1SYMIZ-LOI8Ylykz0PTxwiPuHN_02gIWh9AjJDO6xbvM/edit?usp=sharing" rel="nofollow"&gt;Slides&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | FunctionalConf 2019, Bangalore, India&lt;/li&gt;
&lt;li&gt;&lt;a href="https://graninas.com/functional-design-and-architecture-book/" rel="nofollow"&gt;Functional Design and Architecture (Book)&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | &lt;em&gt;Note: the whole book is about different aspects of the Free monadic architecture.&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.endpoint.com/blog/2016/03/11/strict-typing-fun-example-free-monads" rel="nofollow"&gt;Strict typing fun example — Free Monads in Haskell&lt;/a&gt; | &lt;strong&gt;Kamil Ciemniewski&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://deque.blog/2017/11/13/free-monads-from-basics-up-to-implementing-composable-and-effectful-stream-processing/" rel="nofollow"&gt;Free Monads: from the basics to the implementation of composable and effectful stream processing&lt;/a&gt; | &lt;strong&gt;Quentin Duval&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parsonsmatt.org/2017/09/22/what_does_free_buy_us.html" rel="nofollow"&gt;What does Free buy us?&lt;/a&gt; | &lt;strong&gt;Matt Parsons&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.ploeh.dk/2017/07/24/combining-free-monads-in-haskell/" rel="nofollow"&gt;Combining free monads in Haskell&lt;/a&gt; | &lt;strong&gt;Mark Seemann&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://markkarpov.com/post/free-monad-considered-harmful.html" rel="nofollow"&gt;Free monad considered harmful&lt;/a&gt; | &lt;strong&gt;Mark Karpov&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://softwareengineering.stackexchange.com/questions/242795/what-is-the-free-monad-interpreter-pattern#" rel="nofollow"&gt;What is the “Free Monad + Interpreter” pattern? (SO question)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://captjakk.com/posts/2019-05-12-practical-intro-eff.html" rel="nofollow"&gt;A Practical Introduction to Freer Monads (Eff)&lt;/a&gt; | &lt;strong&gt;Keagan McClelland&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-final-tagless--mtl" class="anchor" aria-hidden="true" href="#final-tagless--mtl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Final Tagless / mtl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://jproyo.github.io/posts/2019-03-17-tagless-final-haskell.html" rel="nofollow"&gt;Tagless Final Encoding in Haskell&lt;/a&gt; | &lt;strong&gt;Juan Pablo Royo&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://serokell.io/blog/tagless-final" rel="nofollow"&gt;Introduction to Tagless Final&lt;/a&gt; | &lt;strong&gt;Vasiliy Kevroletin&lt;/strong&gt; | Serokell&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ro-che.info/articles/2016-02-03-finally-tagless-boilerplate" rel="nofollow"&gt;Reducing boilerplate in finally tagless style&lt;/a&gt; | &lt;strong&gt;Roman Cheplyaka&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wickstrom.tech/programming/2017/06/05/tagless-final-encoding-of-a-test-language.html" rel="nofollow"&gt;Tagless Final Encoding of a Test Language&lt;/a&gt; | &lt;strong&gt;Oskar Wickström&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-effect-systems" class="anchor" aria-hidden="true" href="#effect-systems"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Effect Systems&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://mmhaskell.com/blog/2017/11/20/eff-to-the-rescue" rel="nofollow"&gt;Eff to the Rescue!&lt;/a&gt; | &lt;strong&gt;Monday Morning Haskell&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/barely-functional/freer-doesnt-come-for-free-c9fade793501" rel="nofollow"&gt;Freer doesn’t come for free&lt;/a&gt; | &lt;strong&gt;Eric Torreborre&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.sumtypeofway.com/posts/serving-http-content-with-fused-effects.html" rel="nofollow"&gt;Serving HTTP Content with Fused-Effects&lt;/a&gt; | &lt;strong&gt;Patrick Thomson&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://captjakk.com/posts/2019-05-12-practical-intro-eff.html" rel="nofollow"&gt;A Practical Introduction to Freer Monads (Eff)&lt;/a&gt; | &lt;strong&gt;Keagan McClelland&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-readert-pattern" class="anchor" aria-hidden="true" href="#readert-pattern"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;ReaderT Pattern&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.fpcomplete.com/blog/2017/06/readert-design-pattern" rel="nofollow"&gt;The ReaderT Design Pattern&lt;/a&gt; | &lt;strong&gt;Michael Snoyman&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://magnus.therning.org/posts/2019-02-02-000-the-readert-design-pattern-or-tagless-final-.html" rel="nofollow"&gt;The ReaderT design pattern or tagless final?&lt;/a&gt; | &lt;strong&gt;Magnus Therning&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.tweag.io/posts/2018-10-04-capability.html" rel="nofollow"&gt;Capability: The ReaderT Pattern Without The Boilerplate&lt;/a&gt; | &lt;strong&gt;Andreas Herrmann, Arnaud Spiwack&lt;/strong&gt; | Tweag.IO&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-service-handle-pattern" class="anchor" aria-hidden="true" href="#service-handle-pattern"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Service Handle Pattern&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.schoolofhaskell.com/user/meiersi/the-service-pattern" rel="nofollow"&gt;The Service Pattern&lt;/a&gt; | &lt;strong&gt;Simon Meier&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" rel="nofollow"&gt;Haskell Design Patterns: The Handle Pattern&lt;/a&gt; | &lt;strong&gt;Jasper Van der Jeugt&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-other-patterns" class="anchor" aria-hidden="true" href="#other-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Other Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.oreilly.com/library/view/haskell-design-patterns/9781783988723/" rel="nofollow"&gt;(Book) Haskell Design Patterns&lt;/a&gt; | &lt;strong&gt;Ryan Lemmer&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://michaelxavier.net/posts/2016-04-03-Enterprise-Haskell-Pattern-Lensed-Reader.html" rel="nofollow"&gt;Enterprise Haskell Pattern: Lensed Reader&lt;/a&gt; | &lt;strong&gt;Michael Xavier&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/the-has-type-class-pattern-ca12adab70ae" rel="nofollow"&gt;The Has Type Class Pattern&lt;/a&gt; | &lt;strong&gt;Jonathan Fischoff&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://hackernoon.com/type-class-patterns-and-anti-patterns-efd045c5af66" rel="nofollow"&gt;Type Class Patterns and Anti-patterns&lt;/a&gt; | &lt;strong&gt;Jonathan Fischoff&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-oop-design-patterns-vs-fp-design-patterns" class="anchor" aria-hidden="true" href="#oop-design-patterns-vs-fp-design-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;OOP Design Patterns vs FP Design Patterns&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/thma/LtuPatternFactory"&gt;Lambda the Ultimate Pattern Factory&lt;/a&gt; | &lt;strong&gt;thma&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-comparison-of-approaches" class="anchor" aria-hidden="true" href="#comparison-of-approaches"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Comparison of Approaches&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://williamyaoh.com/posts/2019-12-14-typesafe-db-libraries.html" rel="nofollow"&gt;Which Type-Safe Database Library Should You Use?&lt;/a&gt; | &lt;strong&gt;William Yao&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/u1GGqDQyGfc" rel="nofollow"&gt;Final Tagless vs Free Monad (Talk, Rus)&lt;/a&gt; | &lt;a href="https://drive.google.com/open?id=1VhS8ySgk2w5RoN_l_Ar_axcE4Dzf97zLw1uuzUJQbCo" rel="nofollow"&gt;Slides (Eng)&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | FPure 2019, Kazan&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ocharles.org.uk/posts/2016-01-26-transformers-free-monads-mtl-laws.html" rel="nofollow"&gt;Monad transformers, free monads, mtl, laws and a new approach&lt;/a&gt; | &lt;strong&gt;Oliver Charles&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qfpl.io/posts/backpack-for-initial-and-final-encodings/" rel="nofollow"&gt;Backpack for initial and final encodings&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.tweag.io/posts/2018-10-04-capability.html" rel="nofollow"&gt;Capability: The ReaderT Pattern Without The Boilerplate&lt;/a&gt; | &lt;strong&gt;Andreas Herrmann, Arnaud Spiwack&lt;/strong&gt; | Tweag.io&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-comparison-table" class="anchor" aria-hidden="true" href="#comparison-table"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Comparison Table&lt;/h3&gt;
&lt;p&gt;Separate page:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/graninas/1b7961ccaedf7b5cb92417a1599fdc99"&gt;Haskell Approaches Comparison Table&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-methodologies-and-philosophy" class="anchor" aria-hidden="true" href="#methodologies-and-philosophy"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Methodologies and Philosophy&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.snoyman.com/blog/2019/11/boring-haskell-manifesto" rel="nofollow"&gt;Boring Haskell Manifesto&lt;/a&gt; | &lt;strong&gt;Michael Snoyman&lt;/strong&gt; | &lt;a href="https://www.reddit.com/r/haskell/comments/dzx15d/boring_haskell_manifesto_by_michael_snoyman/" rel="nofollow"&gt;Reddit discussion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://patrickmn.com/software/the-haskell-pyramid/" rel="nofollow"&gt;The Haskell Pyramid&lt;/a&gt; | &lt;strong&gt;Patrick&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://alpacaaa.net/thoughts-on-haskell-2020/" rel="nofollow"&gt;My thoughts on Haskell in 2020&lt;/a&gt; | &lt;strong&gt;Marco Sampellegrini&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.parsonsmatt.org/2019/12/26/write_junior_code.html" rel="nofollow"&gt;Write Junior Code&lt;/a&gt; | &lt;strong&gt;Matt Parsons&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-design-principles" class="anchor" aria-hidden="true" href="#design-principles"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Design Principles&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;Note. It's a big void here in these topics. We don't have any good materials about Design Principles applicable to Haskell.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Inversion of Control&lt;/li&gt;
&lt;li&gt;Dependency Injection&lt;/li&gt;
&lt;li&gt;Low Coupling / High Cohesion&lt;/li&gt;
&lt;li&gt;Rule of Least Power / Law of Demeter&lt;/li&gt;
&lt;li&gt;SOLID&lt;/li&gt;
&lt;li&gt;KISS&lt;/li&gt;
&lt;li&gt;YAGNI&lt;/li&gt;
&lt;li&gt;DRY&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-best-practices--guidelines" class="anchor" aria-hidden="true" href="#best-practices--guidelines"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Best Practices &amp;amp; Guidelines&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://williamyaoh.com/posts/2019-09-27-figuring-out-beam-migrations.html" rel="nofollow"&gt;Figuring Out How To Use Beam For DB Migrations&lt;/a&gt; | &lt;strong&gt;Willam Yao&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/morteako/bitcoin"&gt;Making a small Haskell application&lt;/a&gt; | &lt;strong&gt;Morten Kolstad&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/freckle/guides/blob/master/haskell-best-practices.md"&gt;Haskell practices&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://lexi-lambda.github.io/blog/2018/02/10/an-opinionated-guide-to-haskell-in-2018/" rel="nofollow"&gt;An opinionated guide to Haskell in 2018&lt;/a&gt; | &lt;strong&gt;Lexi Lambda&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=-X1vrxQUETM" rel="nofollow"&gt;Getting things done in Haskell (Talk)&lt;/a&gt; |  &lt;strong&gt;Jasper Van der Jeugt&lt;/strong&gt; | HaskellerZ, Feb 2018&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/mtesseract/1b69087b0aeeb6ddd7023ff05f7b7e68"&gt;Working around Haskell's namespace problem for records&lt;/a&gt; | &lt;strong&gt;Moritz Clasmeier&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.haskell.org/Programming_guidelines" rel="nofollow"&gt;Programming guidelines&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://kowainik.github.io/posts/2019-02-06-style-guide" rel="nofollow"&gt;Kowainik's Haskell Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tweag/guides/blob/master/style/Haskell.md"&gt;Tweag.IO's Haskell Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md"&gt;Tibbe's Haskell Style Guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-showcase-projects--code-orgranization-samples" class="anchor" aria-hidden="true" href="#showcase-projects--code-orgranization-samples"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Showcase Projects &amp;amp; Code Orgranization Samples&lt;/h1&gt;
&lt;p&gt;Separate page:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/graninas/49be74a21fbd58236bad28e1ce1eed94"&gt;Software Design Showcase Projects in Haskell&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-haskell-in-production-success-stories-experience-reports" class="anchor" aria-hidden="true" href="#haskell-in-production-success-stories-experience-reports"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Haskell in Production. Success Stories, Experience Reports&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.stephendiehl.com/posts/production.html" rel="nofollow"&gt;The Joy and Agony of Haskell in Production&lt;/a&gt; | &lt;strong&gt;Stephen Diehl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://m.youtube.com/watch?v=mlTO510zO78" rel="nofollow"&gt;Haskell is Not For Production and Other Tales (Talk)&lt;/a&gt; | &lt;strong&gt;Katie Miller&lt;/strong&gt; | Linux.conf.au 2016 | Geelong, Australia&lt;/li&gt;
&lt;li&gt;&lt;a href="https://m.youtube.com/watch?v=AZQLkkDXy68" rel="nofollow"&gt;Production Haskell (Talk)&lt;/a&gt; | &lt;strong&gt;Reid Draper&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Haskell in Production | &lt;strong&gt;Felix Mulder&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://felixmulder.com/writing/2019/10/05/Haskell-in-Production.html" rel="nofollow"&gt;Haskell in Production&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://felixmulder.com/writing/2019/10/05/Designing-testable-components.html" rel="nofollow"&gt;Designing Testable Components&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.hasura.io/from-zero-to-hipster-haskell-in-production-97ea99d90c3b/" rel="nofollow"&gt;Haskell in Production&lt;/a&gt; | Hasura.IO&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/hZgW4mT1PkE" rel="nofollow"&gt;5 Years of Haskell in Production (Talk)&lt;/a&gt; | &lt;strong&gt;Alexander Thiemann&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.infoq.com/news/2016/08/haskell-production-retrospective/" rel="nofollow"&gt;Retrospective: Haskell in Production&lt;/a&gt; | &lt;strong&gt;Sergio De Simone&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://medium.com/@djoyner/my-haskell-in-production-story-e48897ed54c" rel="nofollow"&gt;My “Haskell In Production” Story&lt;/a&gt; | &lt;strong&gt;David Joyner&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-talks" class="anchor" aria-hidden="true" href="#talks"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Talks&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.youtube.com/watch?v=-X1vrxQUETM" rel="nofollow"&gt;Getting things done in Haskell (Talk)&lt;/a&gt; |  &lt;strong&gt;Jasper Van der Jeugt&lt;/strong&gt; | HaskellerZ, Feb 2018&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/3GKQ4ni2pS0" rel="nofollow"&gt;Hierarchical Free Monads and Software Design in Functional Programming (Talk)&lt;/a&gt; | &lt;a href="https://docs.google.com/presentation/d/1SYMIZ-LOI8Ylykz0PTxwiPuHN_02gIWh9AjJDO6xbvM/edit?usp=sharing" rel="nofollow"&gt;Slides&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | FunctionalConf 2019, Bangalore, India&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/u1GGqDQyGfc" rel="nofollow"&gt;Final Tagless vs Free Monad (Talk, Rus)&lt;/a&gt; | &lt;a href="https://drive.google.com/open?id=1VhS8ySgk2w5RoN_l_Ar_axcE4Dzf97zLw1uuzUJQbCo" rel="nofollow"&gt;Slides (Eng)&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt; | FPure 2019, Kazan&lt;/li&gt;
&lt;li&gt;&lt;a href="https://m.youtube.com/watch?v=mlTO510zO78" rel="nofollow"&gt;Haskell is Not For Production and Other Tales (Talk)&lt;/a&gt; | &lt;strong&gt;Katie Miller&lt;/strong&gt; | Linux.conf.au 2016 | Geelong, Australia&lt;/li&gt;
&lt;li&gt;&lt;a href="https://m.youtube.com/watch?v=AZQLkkDXy68" rel="nofollow"&gt;Production Haskell (Talk)&lt;/a&gt; | &lt;strong&gt;Reid Draper&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://youtu.be/hZgW4mT1PkE" rel="nofollow"&gt;5 Years of Haskell in Production (Talk)&lt;/a&gt; | &lt;strong&gt;Alexander Thiemann&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;&lt;a id="user-content-haskell-ecosystem-and-accessibility" class="anchor" aria-hidden="true" href="#haskell-ecosystem-and-accessibility"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Haskell Ecosystem and Accessibility&lt;/h1&gt;
&lt;p&gt;This section is aimed to show that learning and using Haskell is not as horrible as some folks are trying to claim.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-haskell-ecosystem-and-community" class="anchor" aria-hidden="true" href="#haskell-ecosystem-and-community"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Haskell Ecosystem and Community&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/Gabriel439/post-rfc/blob/master/sotu.md"&gt;State of the Haskell ecosystem&lt;/a&gt; | &lt;strong&gt;Gabriel Gonzalez&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://taylor.fausak.me/2017/11/15/2017-state-of-haskell-survey-results/" rel="nofollow"&gt;2017 State of Haskell Survey results&lt;/a&gt; | &lt;strong&gt;Taylor Fausak&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://taylor.fausak.me/2018/11/18/2018-state-of-haskell-survey-results/" rel="nofollow"&gt;2018 State of Haskell Survey results&lt;/a&gt; | &lt;strong&gt;Taylor Fausak&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://taylor.fausak.me/2019/11/16/haskell-survey-results/" rel="nofollow"&gt;2019 State of Haskell Survey results&lt;/a&gt; | &lt;strong&gt;Taylor Fausak&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://patrickmn.com/software/the-haskell-pyramid/" rel="nofollow"&gt;The Haskell Pyramid&lt;/a&gt; | &lt;strong&gt;Patrick&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-haskell-learn-books" class="anchor" aria-hidden="true" href="#haskell-learn-books"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Haskell Learn: Books&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.manning.com/books/get-programming-with-haskell" rel="nofollow"&gt;Get Programming with Haskell&lt;/a&gt; | &lt;strong&gt;Will Kurt&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.manning.com/books/haskell-in-depth" rel="nofollow"&gt;Haskell in Depth&lt;/a&gt; | &lt;strong&gt;Vitaly Bragilevsky&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://dev.stephendiehl.com/hask/" rel="nofollow"&gt;What I Wish I Knew When Learning Haskell&lt;/a&gt; | &lt;strong&gt;Stephen Diehl&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.haskellfromtheverybeginning.com/" rel="nofollow"&gt;Haskell from the Very Beginning&lt;/a&gt; | &lt;strong&gt;John Whitington&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://learnyouahaskell.com/" rel="nofollow"&gt;Learn You a Haskell for Great Good!&lt;/a&gt; | &lt;strong&gt;Miran Lipovača&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cs.nott.ac.uk/~pszgmh/pih.html" rel="nofollow"&gt;Programming in Haskell&lt;/a&gt; | &lt;strong&gt;Graham Hutton&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.apress.com/gp/book/9781484244791" rel="nofollow"&gt;Practical Haskell. A Real World Guide to Programming&lt;/a&gt; | &lt;strong&gt;Serrano, Alejandro&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://shop.oreilly.com/product/0636920026365.do" rel="nofollow"&gt;Parallel and Concurrent Programming in Haskell: Techniques for Multicore and Multithreaded Programming&lt;/a&gt; | &lt;strong&gt;Simon Marlow&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://book.realworldhaskell.org/" rel="nofollow"&gt;Real World Haskell&lt;/a&gt; | &lt;strong&gt;Bryan O'Sullivan, Don Stewart, John Goerzen&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://graninas.com/functional-design-and-architecture-book/" rel="nofollow"&gt;Functional Design and Architecture&lt;/a&gt; | &lt;strong&gt;Alexander Granin&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://thinkingwithtypes.com/" rel="nofollow"&gt;Thinking with Types. Type-Level Programming in Haskell&lt;/a&gt; | &lt;strong&gt;Sandy Maguire&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://haskellbook.com/" rel="nofollow"&gt;Haskell Programming from First Principles&lt;/a&gt; | &lt;strong&gt;Chistopher Allen, Julie Moronuki&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-misc" class="anchor" aria-hidden="true" href="#misc"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Misc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/graninas/ef5dd5a2b57903af81039fb21ff3b0bf"&gt;Appendix to Software Design in Haskell&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gist.github.com/graninas/ef5dd5a2b57903af81039fb21ff3b0bf#Testing"&gt;Testing&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>graninas</author><guid isPermaLink="false">https://github.com/graninas/software-design-in-haskell</guid><pubDate>Tue, 07 Jan 2020 00:01:00 GMT</pubDate></item><item><title>unisonweb/unison #2 in Haskell, This week</title><link>https://github.com/unisonweb/unison</link><description>&lt;p&gt;&lt;i&gt;A friendly programming language from the future&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-the-unison-language" class="anchor" aria-hidden="true" href="#the-unison-language"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The Unison language&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/unisonweb/unison" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/1cf74060aa43b747ead8ff6ec02708dbdfb0b28a/68747470733a2f2f7472617669732d63692e6f72672f756e69736f6e7765622f756e69736f6e2e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/unisonweb/unison.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://unisonweb.org" rel="nofollow"&gt;Unison&lt;/a&gt; is a new programming language, currently under active development. It's a modern, statically-typed purely functional language, similar to Haskell, but with a unique ability to describe entire distributed systems with a single program. Here's a simple example:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; comments start with `--`&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; alice : Node, bob : Node&lt;/span&gt;

x &lt;span class="pl-k"&gt;=&lt;/span&gt; factorial &lt;span class="pl-c1"&gt;6&lt;/span&gt;
&lt;span class="pl-c1"&gt;Remote.&lt;/span&gt;transfer alice
y &lt;span class="pl-k"&gt;=&lt;/span&gt; foo x &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; happens on `alice` node&lt;/span&gt;
&lt;span class="pl-c1"&gt;Remote.&lt;/span&gt;transfer bob
bar x y &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; happens on `bob` node&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Remote.transfer&lt;/code&gt; function introduces a "remote effect", where computation may proceed on multiple Unison nodes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;Remote.transfer alice&lt;/code&gt; transfers control of the computation to the &lt;code&gt;alice&lt;/code&gt; node.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;foo x&lt;/code&gt; call happens on the &lt;code&gt;alice&lt;/code&gt; node.&lt;/li&gt;
&lt;li&gt;At each transfer, any required definitions (such as &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;) will be dynamically deployed to the &lt;code&gt;alice&lt;/code&gt; node and cached for future use.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Remote.transfer bob&lt;/code&gt; transfers control of the rest of the computation to the &lt;code&gt;bob&lt;/code&gt; node.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;bar x y&lt;/code&gt; computation happens on the &lt;code&gt;bob&lt;/code&gt; node. Again, any needed definitions (&lt;code&gt;bar&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;) will be dynamically deployed to the &lt;code&gt;bob&lt;/code&gt; node.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This dynamic transfer / deployment of arbitrary computations is possible because definitions in Unison are identified by a cryptographic hash of their content, &lt;em&gt;including the hashes of all dependencies&lt;/em&gt; (the hash is also "nameless" as it isn't affected by naming of variables). To transfer a computation, we send it to the recipient, and the recipient checks to see if the computation references any unknown hashes. Any unknown hashes are synced to the recipient before the transfer completes and the computation proceeds.&lt;/p&gt;
&lt;p&gt;If you'd like to learn more about the project, the talk &lt;a href="https://www.youtube.com/watch?v=f6yA3t0dO-k" rel="nofollow"&gt;How to write a search engine in 15 lines of code&lt;/a&gt; has more of an introduction to the language. For a more complete overview of the syntax look at the &lt;a href="https://www.unisonweb.org/docs/language-reference" rel="nofollow"&gt;unison language reference&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Since Unison isn't terribly useful in its current form, the rest of this README will focus on stuff that will be of interest for potential contributors, namely, how to build the code, and a brief tour of the (fairly small but action-packed) codebase. If you're just interested in the project and want to follow along with the progress, &lt;a href="http://unisonweb.org" rel="nofollow"&gt;unisonweb.org&lt;/a&gt; is the place to go, or you can also say hello or lurk &lt;a href="http://tiny.cc/unisonslack" rel="nofollow"&gt;in the Slack chat&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Still here? All right then! Let's get to it.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-a-brief-code-tour" class="anchor" aria-hidden="true" href="#a-brief-code-tour"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;A brief code tour&lt;/h2&gt;
&lt;p&gt;First, clone unison with &lt;code&gt;--recursive&lt;/code&gt;:
&lt;code&gt;git clone --recursive https://github.com/unisonweb/unison.git&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Next, a bit of orientation. Here's the directory structure:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;editor-support/&lt;/code&gt; includes some very basic and probably incomplete text edit support (read: syntax highlighting)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;yaks/&lt;/code&gt; has subprojects for various utilities not specific to Unison (the result of &lt;a href="https://en.wiktionary.org/wiki/yak_shaving" rel="nofollow"&gt;"yak-shaving"&lt;/a&gt;). Once mature, each of these might be moved to independent projects and published on Hackage.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parser-typechecker/&lt;/code&gt; has the meat: the Unison syntax tree, parser, typechecker, and runtime. Depends on &lt;code&gt;yaks/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-building-using-stack" class="anchor" aria-hidden="true" href="#building-using-stack"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Building using Stack&lt;/h2&gt;
&lt;p&gt;If these instructions don't work for you or are incomplete, please file an issue.&lt;/p&gt;
&lt;p&gt;The build uses &lt;a href="http://docs.haskellstack.org/" rel="nofollow"&gt;Stack&lt;/a&gt;. If you don't already have it installed, &lt;a href="http://docs.haskellstack.org/en/stable/README.html#how-to-install" rel="nofollow"&gt;follow the install instructions&lt;/a&gt; for your platform.  (Hint: &lt;code&gt;brew update &amp;amp;&amp;amp; brew install stack&lt;/code&gt;)&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ git clone --recursive https://github.com/unisonweb/unison.git
$ &lt;span class="pl-c1"&gt;cd&lt;/span&gt; unison
$ stack --version &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;#&lt;/span&gt; we'll want to know this version if you run into trouble&lt;/span&gt;
$ stack build &lt;span class="pl-k"&gt;&amp;amp;&amp;amp;&lt;/span&gt; stack &lt;span class="pl-c1"&gt;exec&lt;/span&gt; tests &lt;span class="pl-k"&gt;&amp;amp;&amp;amp;&lt;/span&gt; stack &lt;span class="pl-c1"&gt;exec&lt;/span&gt; unison&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note: If you get this error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stack looks for packages in the directories configured in the 'packages' and 'extra-deps' fields defined in your stack.yaml
The current entry points to &amp;lt;root&amp;gt;/yaks/haskeline/ but no .cabal or package.yaml file could be found there.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then your local git repo is older than the haskeline submodule dependency; use this to get it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule init
git submodule update
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See &lt;a href="development.markdown"&gt;&lt;code&gt;development.markdown&lt;/code&gt;&lt;/a&gt; for a list of build commands you'll likely use during development.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-a-brief-tour-of-the-haskell-code" class="anchor" aria-hidden="true" href="#a-brief-tour-of-the-haskell-code"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;A brief tour of the Haskell code&lt;/h2&gt;
&lt;p&gt;In the &lt;code&gt;parser-typechecker/&lt;/code&gt; project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Unison.Term&lt;/code&gt; and &lt;code&gt;Unison.Type&lt;/code&gt; have the syntax trees for terms and types. In both &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt;, the same pattern is used. Each defines a 'base functor' type, &lt;code&gt;F a&lt;/code&gt;, which is nonrecursive, and the actual thing we use is an &lt;em&gt;abstract binding tree&lt;/em&gt; over this base functor, an &lt;code&gt;ABT F&lt;/code&gt;. &lt;code&gt;ABT&lt;/code&gt; (for 'abstract binding tree') is defined in &lt;code&gt;Unison.ABT&lt;/code&gt;. If you aren't familiar with abstract binding trees, &lt;a href="http://semantic-domain.blogspot.com/2015/03/abstract-binding-trees.html" rel="nofollow"&gt;here is a nice blog post explaining one formulation of the idea&lt;/a&gt;, which inspired the &lt;code&gt;Unison.ABT&lt;/code&gt; module. A lot of operations on terms and types just delegate to generic &lt;code&gt;ABT&lt;/code&gt; operations.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unison.Parsers&lt;/code&gt; has the main entry point for the parser.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unison.Typechecker.Context&lt;/code&gt; is the implementation of the typechecker, and &lt;code&gt;Unison.Typechecker&lt;/code&gt; has the "public interface to the typechecker" and some convenience functions. There isn't a lot of code here (about 700 LOC presently), since the typechecking algorithm is pretty simple. Unlike a unification-based typechecker, where the typechecking state is an unordered bag of unification constraints and higher-rank polymorphism is usually bolted on awkwardly later, &lt;a href="http://www.mpi-sws.org/~neelk/bidir.pdf" rel="nofollow"&gt;Dunfield and Krishnaswami's algorithm&lt;/a&gt; keeps the typechecking state as a nicely tidy &lt;em&gt;ordered context&lt;/em&gt;, represented as a regular list manipulated in a stack-like fashion, and the algorithm handles higher-rank polymorphism very cleanly. They've also &lt;a href="http://semantic-domain.blogspot.com/2015/03/new-draft-sound-and-complete.html" rel="nofollow"&gt;extended this work to include features like GADTs&lt;/a&gt;, though this new algorithm hasn't been incorporated into Unison yet.&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>unisonweb</author><guid isPermaLink="false">https://github.com/unisonweb/unison</guid><pubDate>Tue, 07 Jan 2020 00:02:00 GMT</pubDate></item><item><title>agda/agda #3 in Haskell, This week</title><link>https://github.com/agda/agda</link><description>&lt;p&gt;&lt;i&gt;Agda is a dependently typed programming language / interactive theorem prover.&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-agda-2" class="anchor" aria-hidden="true" href="#agda-2"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Agda 2&lt;/h1&gt;
&lt;p&gt;&lt;a href="http://hackage.haskell.org/package/Agda" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/b9048ae35fa410df17a3424f305829758ae92f51/68747470733a2f2f696d672e736869656c64732e696f2f6861636b6167652f762f416764612e7376673f6c6162656c3d4861636b616765" alt="Hackage version" data-canonical-src="https://img.shields.io/hackage/v/Agda.svg?label=Hackage" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://www.stackage.org/package/Agda" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/9f88ff79ffa487f05b7a6b5316beafe9d174f02d/68747470733a2f2f7777772e737461636b6167652e6f72672f7061636b6167652f416764612f62616467652f6c74733f6c6162656c3d537461636b616765" alt="Stackage version" data-canonical-src="https://www.stackage.org/package/Agda/badge/lts?label=Stackage" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://travis-ci.org/agda/agda" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/e044f602cbc729bd25dcf40c5b3dab9ff10b9a33/68747470733a2f2f7472617669732d63692e6f72672f616764612f616764612e7376673f6272616e63683d6d6173746572" alt="Travis Status" data-canonical-src="https://travis-ci.org/agda/agda.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://github.com/agda/agda/actions?query=workflow%3A%22stack+build%22"&gt;&lt;img src="https://github.com/agda/agda/workflows/stack%20build/badge.svg" alt="Stack Build Status via GH Actions" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://ci.appveyor.com/project/gallais/agda" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/3a431ee88796239ee20eb0ff21eb76302af31756/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f78366c696c6e32646f6c3062673471772f6272616e63682f6d61737465723f7376673d74727565" alt="Appveyor Status" data-canonical-src="https://ci.appveyor.com/api/projects/status/x6liln2dol0bg4qw/branch/master?svg=true" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="http://agda.readthedocs.io/en/latest/?badge=latest" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/1d7b94ef1f0376a13376b32e1bd02c1bca17242e/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f616764612f62616467652f3f76657273696f6e3d6c6174657374" alt="Documentation Status" data-canonical-src="https://readthedocs.org/projects/agda/badge/?version=latest" style="max-width:100%;"&gt;&lt;/a&gt; &lt;a href="https://gitter.im/agda/agda?utm_source=badge&amp;amp;utm_medium=badge&amp;amp;utm_campaign=pr-badge&amp;amp;utm_content=badge" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/3b54f762e1605530037ddfc046cc2a5b77474b81/68747470733a2f2f6261646765732e6769747465722e696d2f616764612f616764612e737667" alt="Join the chat at https://gitter.im/agda/agda" data-canonical-src="https://badges.gitter.im/agda/agda.svg" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="doc/user-manual/agda.svg"&gt;&lt;img src="doc/user-manual/agda.svg" alt="The official Agda logo" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Note that this README is only about Agda, not its standard
library. See the &lt;a href="http://wiki.portal.chalmers.se/agda/pmwiki.php" rel="nofollow"&gt;Agda Wiki&lt;/a&gt; for information about the
library.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Documentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://agda.readthedocs.io" rel="nofollow"&gt;User manual&lt;/a&gt;
(per-commit pdf can be downloaded from the
&lt;a href="https://github.com/agda/agda/actions?query=workflow%3A%22User+Manual%22"&gt;github actions&lt;/a&gt; page)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/agda/agda/blob/master/CHANGELOG.md"&gt;CHANGELOG&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://agda.readthedocs.io/en/latest/getting-started/prerequisites.html" rel="nofollow"&gt;Prerequisites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://agda.readthedocs.io/en/latest/getting-started/installation.html" rel="nofollow"&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://agda.readthedocs.io/en/latest/getting-started/quick-guide.html" rel="nofollow"&gt;Quick guide to editing, type checking and compiling Agda
code&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-contributing-to-agda" class="anchor" aria-hidden="true" href="#contributing-to-agda"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Contributing to Agda&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Contribution how-to: &lt;a href="https://github.com/agda/agda/blob/master/HACKING.md"&gt;&lt;code&gt;HACKING&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/andreasabel/haskell-style-guide/blob/master/haskell-style.md"&gt;Haskell style-guide&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>agda</author><guid isPermaLink="false">https://github.com/agda/agda</guid><pubDate>Tue, 07 Jan 2020 00:03:00 GMT</pubDate></item><item><title>haskell/haskell-ide-engine #4 in Haskell, This week</title><link>https://github.com/haskell/haskell-ide-engine</link><description>&lt;p&gt;&lt;i&gt;The engine for haskell ide-integration. Not an IDE&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-haskell-ide-engine-hie" class="anchor" aria-hidden="true" href="#haskell-ide-engine-hie"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Haskell IDE Engine (HIE)&lt;/h1&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://github.com/haskell/haskell-ide-engine/raw/master/logos/HIE_logo_512.png"&gt;&lt;img src="https://github.com/haskell/haskell-ide-engine/raw/master/logos/HIE_logo_512.png" width="256" align="right" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/haskell/haskell-ide-engine/blob/master/LICENSE"&gt;&lt;img src="https://camo.githubusercontent.com/e91a929ad3a9026c2d11216147f47b02866c9577/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f6c6963656e73652d425344332d677265656e2e7376673f64756d6d79" alt="License BSD3" data-canonical-src="https://img.shields.io/badge/license-BSD3-green.svg?dummy" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://circleci.com/gh/haskell/haskell-ide-engine/" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/5c7ec34b3056999d94f373bf8596a8c3ee85a94c/68747470733a2f2f696d672e736869656c64732e696f2f636972636c6563692f70726f6a6563742f6769746875622f6861736b656c6c2f6861736b656c6c2d6964652d656e67696e652f6d61737465722e737667" alt="CircleCI" data-canonical-src="https://img.shields.io/circleci/project/github/haskell/haskell-ide-engine/master.svg" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://ci.appveyor.com/project/Bubba/haskell-ide-engine-74xec" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/e965bc22ff5d28e244bde14e2923b6d6d7215caa/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f36686974376d7876676472616f3371303f7376673d74727565" alt="AppVeyor" data-canonical-src="https://ci.appveyor.com/api/projects/status/6hit7mxvgdrao3q0?svg=true" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://www.codetriage.com/haskell/haskell-ide-engine" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/2e91fe3f3c3461f8d7a5aaf33fb79d5ed0be4d42/68747470733a2f2f7777772e636f64657472696167652e636f6d2f6861736b656c6c2f6861736b656c6c2d6964652d656e67696e652f6261646765732f75736572732e737667" alt="Open Source Helpers" data-canonical-src="https://www.codetriage.com/haskell/haskell-ide-engine/badges/users.svg" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This project aims to be &lt;strong&gt;the universal interface&lt;/strong&gt; to &lt;strong&gt;a growing number of Haskell tools&lt;/strong&gt;, providing a &lt;strong&gt;fully-featured &lt;a href="https://github.com/Microsoft/language-server-protocol/blob/master/protocol.md"&gt;Language Server Protocol&lt;/a&gt; server&lt;/strong&gt; for editors and IDEs that require Haskell-specific functionality.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#haskell-ide-engine-hie"&gt;Haskell IDE Engine (HIE)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#features"&gt;Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#installation"&gt;Installation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#installation-with-nix"&gt;Installation with Nix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#installation-on-archlinux"&gt;Installation on ArchLinux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#installation-from-source"&gt;Installation from source&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#common-pre-requirements"&gt;Common pre-requirements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#linux-specific-pre-requirements"&gt;Linux-specific pre-requirements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows-specific-pre-requirements"&gt;Windows-specific pre-requirements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#download-the-source-code"&gt;Download the source code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#building"&gt;Building&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#install-via-cabal"&gt;Install via cabal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#install-cabal-using-stack"&gt;Install cabal using stack&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#install-specific-ghc-version"&gt;Install specific GHC Version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#multiple-versions-of-hie-optional"&gt;Multiple versions of HIE (optional)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#configuration"&gt;Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#project-configuration"&gt;Project Configuration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#editor-integration"&gt;Editor Integration&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#using-hie-with-vs-code"&gt;Using HIE with VS Code&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#using-vs-code-with-nix"&gt;Using VS Code with Nix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-sublime-text"&gt;Using HIE with Sublime Text&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-vim-or-neovim"&gt;Using HIE with Vim or Neovim&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#coc"&gt;Coc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#languageclient-neovim"&gt;LanguageClient-neovim&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#vim-plug"&gt;vim-plug&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#clone-the-languageclient-neovim-repo"&gt;Clone the LanguageClient-neovim repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sample-vimrc"&gt;Sample &lt;code&gt;~/.vimrc&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-atom"&gt;Using HIE with Atom&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-emacs"&gt;Using HIE with Emacs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-spacemacs"&gt;Using HIE with Spacemacs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#using-hie-with-oni"&gt;Using HIE with Oni&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#docs-on-hovercompletion"&gt;Docs on hover/completion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contributing"&gt;Contributing&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#planned-features"&gt;Planned Features&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#its-time-to-join-the-project"&gt;It's time to join the project!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#documentation"&gt;Documentation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#architecture"&gt;Architecture&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#troubleshooting"&gt;Troubleshooting&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#emacs"&gt;Emacs&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#parse-errors-file-state-going-out-of-sync"&gt;Parse errors, file state going out of sync&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#emacs-direnv-loads-environment-too-late"&gt;&lt;code&gt;emacs-direnv&lt;/code&gt; loads environment too late&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#dyld-on-macos"&gt;DYLD on macOS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#macos-got-error-while-installing-ghc-861-or-862---dyld-library-not-loaded-usrlocaloptgmpliblibgmp10dylib"&gt;macOS: Got error while installing GHC 8.6.1 or 8.6.2 - dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#macos-got-error-while-processing-diagnostics-unable-to-load-package-integer-gmp-1020"&gt;macOS: Got error while processing diagnostics: unable to load package &lt;code&gt;integer-gmp-1.0.2.0&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cannot-satisfy--package-id-package"&gt;cannot satisfy -package-id &amp;lt;package&amp;gt;&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#is-package-base-x"&gt;Is &amp;lt;package&amp;gt; base-x?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#is-there-a-hash--after-package"&gt;Is there a hash (#) after &amp;lt;package&amp;gt;?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#otherwise"&gt;Otherwise&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#liquid-haskell"&gt;Liquid Haskell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#profiling-haskell-ide-engine"&gt;Profiling &lt;code&gt;haskell-ide-engine&lt;/code&gt;.&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#using-ghc-events-analyze"&gt;Using &lt;code&gt;ghc-events-analyze&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-features" class="anchor" aria-hidden="true" href="#features"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Supports plain GHC projects, cabal projects(sandboxed and non sandboxed) and stack projects&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Fast due to caching of compile info&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Uses LSP, so should be easy to integrate with a wide selection of editors&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Diagnostics via hlint and GHC warnings/errors&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/2aa08d157d92b2953bd86cfd35769fc0c42fb994/68747470733a2f2f692e696d6775722e636f6d2f3176716d3465462e676966"&gt;&lt;img src="https://camo.githubusercontent.com/2aa08d157d92b2953bd86cfd35769fc0c42fb994/68747470733a2f2f692e696d6775722e636f6d2f3176716d3465462e676966" alt="Diagnostics" data-canonical-src="https://i.imgur.com/1vqm4eF.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Code actions and quick fixes via apply-refact&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/6d201abf03ddb9be69ab213e92d8402b87a1e682/68747470733a2f2f692e696d6775722e636f6d2f644272536935462e676966"&gt;&lt;img src="https://camo.githubusercontent.com/6d201abf03ddb9be69ab213e92d8402b87a1e682/68747470733a2f2f692e696d6775722e636f6d2f644272536935462e676966" alt="Apply Refact" data-canonical-src="https://i.imgur.com/dBrSi5F.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type information and documentation(via haddock) on hover&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/61086adf657ed1e8cb4e23dc4c8ad2993535261f/68747470733a2f2f692e696d6775722e636f6d2f41637659524f762e676966"&gt;&lt;img src="https://camo.githubusercontent.com/61086adf657ed1e8cb4e23dc4c8ad2993535261f/68747470733a2f2f692e696d6775722e636f6d2f41637659524f762e676966" alt="Hover" data-canonical-src="https://i.imgur.com/AcvYROv.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Jump to definition&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/1df0430f4d616f03d5fb0cc2f566cf90ed4caf92/68747470733a2f2f692e696d6775722e636f6d2f6b6d435532427a2e676966"&gt;&lt;img src="https://camo.githubusercontent.com/1df0430f4d616f03d5fb0cc2f566cf90ed4caf92/68747470733a2f2f692e696d6775722e636f6d2f6b6d435532427a2e676966" alt="Find Def" data-canonical-src="https://i.imgur.com/kmCU2Bz.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List all top level definitions&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/98474da5d6fb94d6b50afc17159c07c7076ab5fd/68747470733a2f2f692e696d6775722e636f6d2f474572635971702e676966"&gt;&lt;img src="https://camo.githubusercontent.com/98474da5d6fb94d6b50afc17159c07c7076ab5fd/68747470733a2f2f692e696d6775722e636f6d2f474572635971702e676966" alt="Doc Symbols" data-canonical-src="https://i.imgur.com/GErcYqp.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Highlight references in document&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/321a7f27cb6a831de91a318d83ebd765785e0c9e/68747470733a2f2f692e696d6775722e636f6d2f594c6a487332732e676966"&gt;&lt;img src="https://camo.githubusercontent.com/321a7f27cb6a831de91a318d83ebd765785e0c9e/68747470733a2f2f692e696d6775722e636f6d2f594c6a487332732e676966" alt="Doc Highlight" data-canonical-src="https://i.imgur.com/YLjHs2s.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Completion&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/f17cb65e337a168f3f99ab8c4749b076beee47ed/68747470733a2f2f692e696d6775722e636f6d2f775236494a374d2e676966"&gt;&lt;img src="https://camo.githubusercontent.com/f17cb65e337a168f3f99ab8c4749b076beee47ed/68747470733a2f2f692e696d6775722e636f6d2f775236494a374d2e676966" alt="Completion" data-canonical-src="https://i.imgur.com/wR6IJ7M.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Formatting via brittany&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/816777ff5ea8c4e5615579dc2ca14a895ad43420/68747470733a2f2f692e696d6775722e636f6d2f63715a5a3848432e676966"&gt;&lt;img src="https://camo.githubusercontent.com/816777ff5ea8c4e5615579dc2ca14a895ad43420/68747470733a2f2f692e696d6775722e636f6d2f63715a5a3848432e676966" alt="Formatting" data-canonical-src="https://i.imgur.com/cqZZ8HC.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Renaming via HaRe (NOTE: HaRe is temporarily disabled)&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/9037127f728c4eec37a72e25b191c7b7a5a71c0b/68747470733a2f2f692e696d6775722e636f6d2f7a3033473261352e676966"&gt;&lt;img src="https://camo.githubusercontent.com/9037127f728c4eec37a72e25b191c7b7a5a71c0b/68747470733a2f2f692e696d6775722e636f6d2f7a3033473261352e676966" alt="Renaming" data-canonical-src="https://i.imgur.com/z03G2a5.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add packages to cabal and hpack package files&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/2488460/43036067-20ae5964-8cf2-11e8-9951-4fd849b3f735.gif"&gt;&lt;img src="https://user-images.githubusercontent.com/2488460/43036067-20ae5964-8cf2-11e8-9951-4fd849b3f735.gif" alt="Adding package to hpack" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/1387653/40287051-b6f987fe-5c5f-11e8-980f-ed7bfa1b2aec.gif"&gt;&lt;img src="https://user-images.githubusercontent.com/1387653/40287051-b6f987fe-5c5f-11e8-980f-ed7bfa1b2aec.gif" alt="Adding import &amp;amp; deps" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Typo quick fixes&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/2488460/43036093-746ae176-8cf2-11e8-8b2d-59799b21c283.gif"&gt;&lt;img src="https://user-images.githubusercontent.com/2488460/43036093-746ae176-8cf2-11e8-8b2d-59799b21c283.gif" alt="Quick fixes" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add missing imports (via hsimport)&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/2488460/43036113-9bb5d5b0-8cf2-11e8-8e32-20952378cf2b.gif"&gt;&lt;img src="https://user-images.githubusercontent.com/2488460/43036113-9bb5d5b0-8cf2-11e8-8e32-20952378cf2b.gif" alt="Missing imports" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-installation-with-nix" class="anchor" aria-hidden="true" href="#installation-with-nix"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation with Nix&lt;/h3&gt;
&lt;p&gt;Follow the instructions at &lt;a href="https://github.com/Infinisil/all-hies"&gt;https://github.com/Infinisil/all-hies&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-installation-on-archlinux" class="anchor" aria-hidden="true" href="#installation-on-archlinux"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation on ArchLinux&lt;/h3&gt;
&lt;p&gt;An &lt;a href="https://aur.archlinux.org/packages/haskell-ide-engine/" rel="nofollow"&gt;haskell-ide-engine&lt;/a&gt; package is available on the AUR.&lt;/p&gt;
&lt;p&gt;Using &lt;a href="https://github.com/aurapm/aura"&gt;Aura&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# aura -A haskell-ide-engine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;&lt;a id="user-content-installation-from-source" class="anchor" aria-hidden="true" href="#installation-from-source"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation from source&lt;/h3&gt;
&lt;p&gt;To install HIE, you need stack version &amp;gt;= 1.7.1.&lt;/p&gt;
&lt;p&gt;HIE builds from source code, so there's a couple of extra steps.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-common-pre-requirements" class="anchor" aria-hidden="true" href="#common-pre-requirements"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Common pre-requirements&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;stack&lt;/code&gt; must be in your PATH&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git&lt;/code&gt; must be in your PATH&lt;/li&gt;
&lt;li&gt;Stack local bin directory must be in your PATH. Get it with &lt;code&gt;stack path --local-bin&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tip: you can quickly check if some command is in your path by running the command.
If you receive some meaningful output instead of "command not found"-like message
then it means you have the command in PATH.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-linux-specific-pre-requirements" class="anchor" aria-hidden="true" href="#linux-specific-pre-requirements"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Linux-specific pre-requirements&lt;/h4&gt;
&lt;p&gt;On Linux you will need install a couple of extra libraries (for Unicode (&lt;a href="http://site.icu-project.org/" rel="nofollow"&gt;ICU&lt;/a&gt;) and &lt;a href="https://www.gnu.org/software/ncurses/" rel="nofollow"&gt;NCURSES&lt;/a&gt;):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Debian 9/Ubuntu 18.04 or earlier&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;sudo apt install libicu-dev libtinfo-dev libgmp-dev&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Debian 10/Ubuntu 18.10 or later&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;sudo apt install libicu-dev libncurses-dev libgmp-dev&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Fedora&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;sudo dnf install libicu-devel ncurses-devel &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;#&lt;/span&gt; also zlib-devel if not already installed&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-windows-specific-pre-requirements" class="anchor" aria-hidden="true" href="#windows-specific-pre-requirements"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Windows-specific pre-requirements&lt;/h4&gt;
&lt;p&gt;In order to avoid problems with long paths on Windows you can do either one of the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Clone the &lt;code&gt;haskell-ide-engine&lt;/code&gt; to a short path, for example the root of your logical drive (e.g. to
&lt;code&gt;C:\hie&lt;/code&gt;). If this doesn't work or you want to use a longer path, try the second option.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If the &lt;code&gt;Local Group Policy Editor&lt;/code&gt; is available on your system, go to: &lt;code&gt;Local Computer Policy -&amp;gt; Computer Configuration -&amp;gt; Administrative Templates -&amp;gt; System -&amp;gt; Filesystem&lt;/code&gt; set &lt;code&gt;Enable Win32 long paths&lt;/code&gt; to &lt;code&gt;Enabled&lt;/code&gt;. If you don't have the policy editor you can use regedit by using the following instructions &lt;a href="https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file#enable-long-paths-in-windows-10-version-1607-and-later" rel="nofollow"&gt;here&lt;/a&gt;. You also need to configure git to allow longer paths by using unicode paths. To set this for all your git repositories use &lt;code&gt;git config --system core.longpaths true&lt;/code&gt; (you probably need an administrative shell for this) or for just this one repository use &lt;code&gt;git config core.longpaths true&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;a id="user-content-download-the-source-code" class="anchor" aria-hidden="true" href="#download-the-source-code"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Download the source code&lt;/h4&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;git clone https://github.com/haskell/haskell-ide-engine --recurse-submodules
&lt;span class="pl-c1"&gt;cd&lt;/span&gt; haskell-ide-engine&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-building" class="anchor" aria-hidden="true" href="#building"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Building&lt;/h4&gt;
&lt;p&gt;Uses the &lt;a href="https://shakebuild.com/" rel="nofollow"&gt;shake&lt;/a&gt; build system for predictable builds.&lt;/p&gt;
&lt;p&gt;Note, on first invocation of the build script, a GHC is being installed for execution.
The GHC used for the &lt;code&gt;install.hs&lt;/code&gt; can be adjusted in &lt;code&gt;shake.yaml&lt;/code&gt; by using a different resolver.&lt;/p&gt;
&lt;p&gt;Available commands can be seen with:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;stack ./install.hs &lt;span class="pl-c1"&gt;help&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Remember, this will take time to download a Stackage-LTS and an appropriate GHC. However, afterwards all commands should work as expected.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-install-via-cabal" class="anchor" aria-hidden="true" href="#install-via-cabal"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Install via cabal&lt;/h5&gt;
&lt;p&gt;The install-script can be invoked via &lt;code&gt;cabal&lt;/code&gt; instead of &lt;code&gt;stack&lt;/code&gt; with the command&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;cabal v2-run ./install.hs --project-file install/shake.project &lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;target&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or using the existing alias script&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;./cabal-hie-install &lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;target&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Running the script with cabal on windows requires a cabal version greater or equal to &lt;code&gt;3.0.0.0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, it is still required to have &lt;code&gt;stack&lt;/code&gt; installed so that the install-script can locate the &lt;code&gt;local-bin&lt;/code&gt; directory (on Linux &lt;code&gt;~/.local/bin&lt;/code&gt;) and copy the &lt;code&gt;hie&lt;/code&gt; binaries to &lt;code&gt;hie-x.y.z&lt;/code&gt;, which is required for the &lt;code&gt;hie-wrapper&lt;/code&gt; to function as expected. There are plans to remove this requirement and let users build hie only with one build tool or another.&lt;/p&gt;
&lt;p&gt;For brevity, only the &lt;code&gt;stack&lt;/code&gt;-based commands are presented in the following sections.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-install-cabal-using-stack" class="anchor" aria-hidden="true" href="#install-cabal-using-stack"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Install cabal using stack&lt;/h5&gt;
&lt;p&gt;Although you can use hie for stack based projects (those which have a &lt;code&gt;stack.yaml&lt;/code&gt; in the project base directory) without having cabal installed, you will need it for cabal based projects (with only a &lt;code&gt;&amp;lt;projectName&amp;gt;.cabal&lt;/code&gt; file or a &lt;code&gt;cabal.project&lt;/code&gt; one in the project base directory).&lt;/p&gt;
&lt;p&gt;You can install an appropriate cabal version using stack by running:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;stack ./install.hs stack-install-cabal&lt;/pre&gt;&lt;/div&gt;
&lt;h5&gt;&lt;a id="user-content-install-specific-ghc-version" class="anchor" aria-hidden="true" href="#install-specific-ghc-version"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Install specific GHC Version&lt;/h5&gt;
&lt;p&gt;Install hie for the latest available and supported GHC version (and hoogle docs):&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;stack ./install.hs build&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install hie for a specific GHC version (and hoogle docs):&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;stack ./install.hs hie-8.6.5
stack ./install.hs build-data&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The Haskell IDE Engine can also be built with &lt;code&gt;cabal v2-build&lt;/code&gt; instead of &lt;code&gt;stack build&lt;/code&gt;.
This has the advantage that you can decide how the GHC versions have been installed.
To see what GHC versions are available, the command &lt;code&gt;stack install.hs cabal-ghcs&lt;/code&gt; can be used.
It will list all GHC versions that are on the path and their respective installation directory.
If you think, this list is incomplete, you can try to modify the PATH variable, such that the executables can be found.
Note, that the targets &lt;code&gt;cabal-build&lt;/code&gt; and &lt;code&gt;cabal-build-data&lt;/code&gt; depend on the found GHC versions.
They install Haskell IDE Engine only for the found GHC versions.&lt;/p&gt;
&lt;p&gt;An example output is:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; stack install.hs cabal-ghcs
&lt;span class="pl-k"&gt;******************************************************************&lt;/span&gt;
Found the following GHC paths:
ghc-8.4.4: /opt/bin/ghc-8.4.4
ghc-8.6.2: /opt/bin/ghc-8.6.2

&lt;span class="pl-k"&gt;******************************************************************&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If your desired ghc has been found, you use it to install Haskell IDE Engine.&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;stack install.hs cabal-hie-8.4.4
stack install.hs cabal-build-data&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In general, targets that use &lt;code&gt;cabal&lt;/code&gt; instead of &lt;code&gt;stack&lt;/code&gt; are prefixed with &lt;code&gt;cabal-*&lt;/code&gt; and are identical to their counterpart, except they do not install a GHC if it is missing but fail.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-multiple-versions-of-hie-optional" class="anchor" aria-hidden="true" href="#multiple-versions-of-hie-optional"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Multiple versions of HIE (optional)&lt;/h5&gt;
&lt;p&gt;If you installed multiple versions of HIE then you will need to use a wrapper script.
Wrapper script will analyze your project, find suitable version of HIE and launch it.
Enable it by editing VS Code settings like that:&lt;/p&gt;
&lt;div class="highlight highlight-source-json"&gt;&lt;pre&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;languageServerHaskell.useCustomHieWrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;: &lt;span class="pl-c1"&gt;true&lt;/span&gt;,
&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;languageServerHaskell.useCustomHieWrapperPath&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hie-wrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id="user-content-configuration" class="anchor" aria-hidden="true" href="#configuration"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Configuration&lt;/h2&gt;
&lt;p&gt;There are some settings that can be configured via a &lt;code&gt;settings.json&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight highlight-source-json"&gt;&lt;pre&gt;{
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;languageServerHaskell&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;: {
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hlintOn&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;: &lt;span class="pl-ii"&gt;Boolean&lt;/span&gt;,
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;maxNumberOfProblems&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;: &lt;span class="pl-ii"&gt;Number&lt;/span&gt;
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;diagnosticsDebounceDuration&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-ii"&gt;:&lt;/span&gt; &lt;span class="pl-ii"&gt;Number&lt;/span&gt;
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;liquidOn&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;                    &lt;span class="pl-ii"&gt;:&lt;/span&gt; &lt;span class="pl-ii"&gt;Bool&lt;/span&gt; &lt;span class="pl-ii"&gt;(default&lt;/span&gt; &lt;span class="pl-ii"&gt;False)&lt;/span&gt;
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;completionSnippetsOn&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;        &lt;span class="pl-ii"&gt;:&lt;/span&gt; &lt;span class="pl-ii"&gt;Bool&lt;/span&gt; &lt;span class="pl-ii"&gt;(default&lt;/span&gt; &lt;span class="pl-ii"&gt;True)&lt;/span&gt;
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;formatOnImportOn&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;            &lt;span class="pl-ii"&gt;:&lt;/span&gt; &lt;span class="pl-ii"&gt;Bool&lt;/span&gt; &lt;span class="pl-ii"&gt;(default&lt;/span&gt; &lt;span class="pl-ii"&gt;True)&lt;/span&gt;
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;formattingProvider&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;          &lt;span class="pl-ii"&gt;:&lt;/span&gt; &lt;span class="pl-ii"&gt;String&lt;/span&gt; &lt;span class="pl-ii"&gt;(default&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;brittany&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
                                                &lt;span class="pl-ii"&gt;alternate&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;floskell&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-ii"&gt;)&lt;/span&gt;
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;VS Code: These settings will show up in the settings window&lt;/li&gt;
&lt;li&gt;LanguageClient-neovim: Create this file in &lt;code&gt;$projectdir/.vim/settings.json&lt;/code&gt; or set &lt;code&gt;g:LanguageClient_settingsPath&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-project-configuration" class="anchor" aria-hidden="true" href="#project-configuration"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Project Configuration&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;For a full explanation of possible configurations, refer to &lt;a href="https://github.com/mpickering/hie-bios/blob/master/README.md"&gt;hie-bios/README&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HIE will attempt to automatically detect your project configuration and set up
the environment for GHC.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;cabal.project&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;stack.yaml&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;*.cabal&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;Project selected&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png"&gt;✅&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Cabal v2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png"&gt;✅&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;Stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="white_check_mark" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png"&gt;✅&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;Cabal (v2 or v1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;&lt;g-emoji class="g-emoji" alias="x" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png"&gt;❌&lt;/g-emoji&gt;&lt;/td&gt;
&lt;td&gt;None&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;However, you can also place a &lt;code&gt;hie.yaml&lt;/code&gt; file in the root of the workspace to
&lt;strong&gt;explicitly&lt;/strong&gt; describe how to setup the environment. For example, to state that
you want to use &lt;code&gt;stack&lt;/code&gt; then the configuration file would look like:&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;stack&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:lib&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you use &lt;code&gt;cabal&lt;/code&gt; then you probably need to specify which component you want
to use.&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lib:haskell-ide-engine&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have a project with multiple components, you can use a cabal-multi
cradle:&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/dispatcher/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:dispatcher-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/functional/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:func-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/unit/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:unit-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./hie-plugin-api/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lib:hie-plugin-api&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./app/MainHie.hs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;exe:hie&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./app/HieWrapper.hs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;exe:hie-wrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lib:haskell-ide-engine&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Equivalently, you can use stack:&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;stack&lt;/span&gt;:
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/dispatcher/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:test:dispatcher-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/functional/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:test:func-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./test/unit/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:test:unit-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./hie-plugin-api/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hie-plugin-api:lib&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./app/MainHie.hs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:exe:hie&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./app/HieWrapper.hs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:exe:hie-wrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;./&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
      &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell-ide-engine:lib&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can explicitly state the program which should be used to collect
the options by supplying the path to the program. It is interpreted
relative to the current working directory if it is not an absolute path.&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;bios&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;program&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.hie-bios&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The complete configuration is a subset of&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;optional component name&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
  &lt;span class="pl-ent"&gt;stack&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;optional component name&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
  &lt;span class="pl-ent"&gt;bios&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;program&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;program to run&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-ent"&gt;dependency-program&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;optional program to run&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
  &lt;span class="pl-ent"&gt;direct&lt;/span&gt;:
    &lt;span class="pl-ent"&gt;arguments&lt;/span&gt;: &lt;span class="pl-s"&gt;["list","of","ghc","arguments"]&lt;/span&gt;
  &lt;span class="pl-ent"&gt;default&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;none&lt;/span&gt;:

&lt;span class="pl-ent"&gt;dependencies&lt;/span&gt;:
  - &lt;span class="pl-s"&gt;someDep&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is also support for multiple cradles in a single &lt;code&gt;hie.yaml&lt;/code&gt;. An example configuration for Haskell IDE Engine:&lt;/p&gt;
&lt;div class="highlight highlight-source-yaml"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
  &lt;span class="pl-ent"&gt;multi&lt;/span&gt;:
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./test/dispatcher/&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:dispatcher-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./test/functional/&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:func-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./test/unit/&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;test:unit-test&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./hie-plugin-api/&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lib:hie-plugin-api&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./app/MainHie.hs&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;exe:hie&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./app/HieWrapper.hs&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;exe:hie-wrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    - &lt;span class="pl-ent"&gt;path&lt;/span&gt;: &lt;span class="pl-s"&gt;./&lt;/span&gt;
      &lt;span class="pl-ent"&gt;config&lt;/span&gt;:
        &lt;span class="pl-ent"&gt;cradle&lt;/span&gt;:
          &lt;span class="pl-ent"&gt;cabal&lt;/span&gt;:
            &lt;span class="pl-ent"&gt;component&lt;/span&gt;: &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lib:haskell-ide-engine&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id="user-content-editor-integration" class="anchor" aria-hidden="true" href="#editor-integration"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Editor Integration&lt;/h2&gt;
&lt;p&gt;Note to editor integrators: there is now a &lt;code&gt;hie-wrapper&lt;/code&gt; executable, which is installed alongside the &lt;code&gt;hie&lt;/code&gt; executable.  When this is invoked in the project root directory, it attempts to work out the GHC version used in the project, and then launch the matching &lt;code&gt;hie&lt;/code&gt; executable.&lt;/p&gt;
&lt;p&gt;All of the editor integrations assume that you have already installed HIE (see above) and that &lt;code&gt;stack&lt;/code&gt; put the &lt;code&gt;hie&lt;/code&gt; binary in your path (usually &lt;code&gt;~/.local/bin&lt;/code&gt; on linux and macOS).&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-vs-code" class="anchor" aria-hidden="true" href="#using-hie-with-vs-code"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with VS Code&lt;/h3&gt;
&lt;p&gt;Install from
&lt;a href="https://marketplace.visualstudio.com/items?itemName=alanz.vscode-hie-server" rel="nofollow"&gt;the VSCode marketplace&lt;/a&gt;, or manually from the repository &lt;a href="https://github.com/alanz/vscode-hie-server"&gt;vscode-hie-server&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-using-vs-code-with-nix" class="anchor" aria-hidden="true" href="#using-vs-code-with-nix"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using VS Code with Nix&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;.config/nixpkgs/config.nix&lt;/code&gt; sample:&lt;/p&gt;
&lt;div class="highlight highlight-source-nix"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;with&lt;/span&gt; &lt;span class="pl-c1"&gt;import&lt;/span&gt; &lt;span class="pl-s"&gt;&amp;lt;nixpkgs&amp;gt;&lt;/span&gt; {};

&lt;span class="pl-k"&gt;let&lt;/span&gt;
  &lt;span class="pl-e"&gt;hie&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; (&lt;span class="pl-c1"&gt;import&lt;/span&gt; (&lt;span class="pl-v"&gt;fetchFromGitHub&lt;/span&gt; {
                   &lt;span class="pl-e"&gt;owner&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;domenkozar&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
                   &lt;span class="pl-e"&gt;repo&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hie-nix&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
                   &lt;span class="pl-e"&gt;rev&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;e3113da&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
                   &lt;span class="pl-e"&gt;sha256&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;05rkzjvzywsg66iafm84xgjlkf27yfbagrdcb8sc9fd59hrzyiqk&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
                 }) {})&lt;span class="pl-k"&gt;.&lt;/span&gt;&lt;span class="pl-v"&gt;hie84&lt;/span&gt;;
&lt;span class="pl-k"&gt;in&lt;/span&gt;
{
  &lt;span class="pl-e"&gt;allowUnfree&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;true&lt;/span&gt;;
  &lt;span class="pl-e"&gt;packageOverrides&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-smi"&gt;pkgs&lt;/span&gt;: &lt;span class="pl-k"&gt;rec&lt;/span&gt; {

    &lt;span class="pl-e"&gt;vscode&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-v"&gt;pkgs&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;&lt;span class="pl-v"&gt;vscode&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;&lt;span class="pl-v"&gt;overrideDerivation&lt;/span&gt; (&lt;span class="pl-smi"&gt;old&lt;/span&gt;: {
      &lt;span class="pl-e"&gt;postFixup&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;''&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-s"&gt;        wrapProgram $out/bin/code --prefix PATH : &lt;span class="pl-mi"&gt;&lt;span class="pl-pse"&gt;${&lt;/span&gt;&lt;span class="pl-v"&gt;lib&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;&lt;span class="pl-v"&gt;makeBinPath&lt;/span&gt; [&lt;span class="pl-v"&gt;hie&lt;/span&gt;]&lt;span class="pl-pse"&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-s"&gt;      &lt;span class="pl-pds"&gt;''&lt;/span&gt;&lt;/span&gt;;
    });

  };
}&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-sublime-text" class="anchor" aria-hidden="true" href="#using-hie-with-sublime-text"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Sublime Text&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Make sure HIE is installed (see above) and that the directory stack put the &lt;code&gt;hie&lt;/code&gt; binary in is in your path
&lt;ul&gt;
&lt;li&gt;(usually &lt;code&gt;~/.local/bin&lt;/code&gt; on unix)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Install &lt;a href="https://packagecontrol.io/packages/LSP" rel="nofollow"&gt;LSP&lt;/a&gt; using &lt;a href="https://packagecontrol.io/" rel="nofollow"&gt;Package Control&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;From Sublime Text, press Command+Shift+P and search for Preferences: LSP Settings&lt;/li&gt;
&lt;li&gt;Paste in these settings. Make sure to change the command path to your &lt;code&gt;hie&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{
"clients": {
  "haskell-ide-engine": {
    "command": ["hie"],
    "scopes": ["source.haskell"],
    "syntaxes": ["Packages/Haskell/Haskell.sublime-syntax"],
    "languageId": "haskell",
  },
},
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now open a Haskell project with Sublime Text. You should have these features available to you:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Errors are underlined in red&lt;/li&gt;
&lt;li&gt;LSP: Show Diagnostics will show a list of hints and errors&lt;/li&gt;
&lt;li&gt;LSP: Format Document will prettify the file&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-vim-or-neovim" class="anchor" aria-hidden="true" href="#using-hie-with-vim-or-neovim"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Vim or Neovim&lt;/h3&gt;
&lt;p&gt;As above, make sure HIE is installed.
Then you can use &lt;a href="https://github.com/neoclide/coc.nvim"&gt;Coc&lt;/a&gt;, &lt;a href="https://github.com/autozimu/LanguageClient-neovim"&gt;LanguageClient-neovim&lt;/a&gt;
or any other vim Langauge server protocol client.
Coc is recommend since it is the only complete LSP implementation for Vim and Neovim and offers snippets and floating documentation out of the box.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-coc" class="anchor" aria-hidden="true" href="#coc"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Coc&lt;/h4&gt;
&lt;p&gt;Follow Coc's &lt;a href="https://github.com/neoclide/coc.nvim"&gt;installation instructions&lt;/a&gt;,
Then issue &lt;code&gt;:CocConfig&lt;/code&gt; and add the following to your Coc config file.&lt;/p&gt;
&lt;div class="highlight highlight-source-js"&gt;&lt;pre&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;languageserver&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; {
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; {
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;command&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hie-wrapper&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;args&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;--lsp&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;],
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;rootPatterns&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; [
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;*.cabal&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;stack.yaml&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;cabal.project&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;package.yaml&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
    ],
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;filetypes&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; [
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lhs&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;haskell&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    ],
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;initializationOptions&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; {
      &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;languageServerHaskell&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; {
      }
    }
  }
}&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-languageclient-neovim" class="anchor" aria-hidden="true" href="#languageclient-neovim"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;LanguageClient-neovim&lt;/h4&gt;
&lt;h5&gt;&lt;a id="user-content-vim-plug" class="anchor" aria-hidden="true" href="#vim-plug"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;vim-plug&lt;/h5&gt;
&lt;p&gt;If you use &lt;a href="https://github.com/junegunn/vim-plug"&gt;vim-plug&lt;/a&gt;, then you can do this by e.g.,
including the following line in the Plug section of your &lt;code&gt;init.vim&lt;/code&gt; or &lt;code&gt;~/.vimrc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Plug 'autozimu/LanguageClient-neovim', {
    \ 'branch': 'next',
    \ 'do': './install.sh'
    \ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and issuing a &lt;code&gt;:PlugInstall&lt;/code&gt; command within Neovim or Vim.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-clone-the-languageclient-neovim-repo" class="anchor" aria-hidden="true" href="#clone-the-languageclient-neovim-repo"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Clone the LanguageClient-neovim repo&lt;/h5&gt;
&lt;p&gt;As an alternative to using &lt;a href="https://github.com/junegunn/vim-plug"&gt;vim-plug&lt;/a&gt; shown above, clone &lt;a href="https://github.com/autozimu/LanguageClient-neovim"&gt;LanguageClient-neovim&lt;/a&gt;
into &lt;code&gt;~/.vim/pack/XXX/start/&lt;/code&gt;, where &lt;code&gt;XXX&lt;/code&gt; is just a name for your "plugin suite".&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-sample-vimrc" class="anchor" aria-hidden="true" href="#sample-vimrc"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Sample &lt;code&gt;~/.vimrc&lt;/code&gt;&lt;/h5&gt;
&lt;div class="highlight highlight-source-viml"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;set&lt;/span&gt; &lt;span class="pl-c1"&gt;rtp&lt;/span&gt;&lt;span class="pl-k"&gt;+=&lt;/span&gt;&lt;span class="pl-c1"&gt;~/.vim/pack/XXX/start/LanguageClient-neovim&lt;/span&gt;
&lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-smi"&gt;&lt;span class="pl-k"&gt;g:&lt;/span&gt;LanguageClient_serverCommands&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; { &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;haskell&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;: [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;hie-wrapper&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;--lsp&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;] }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You'll probably want to add some mappings for common commands:&lt;/p&gt;
&lt;div class="highlight highlight-source-viml"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;nnoremap&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;F5&amp;gt;&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient_contextMenu&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;lk :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_hover&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;lg&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_definition&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;lr&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_rename&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;lf&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_formatting&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;lb&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_references&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;la&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_codeAction&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;&amp;lt;Leader&amp;gt;&lt;/span&gt;&lt;span class="pl-c1"&gt;ls&lt;/span&gt; :&lt;span class="pl-c1"&gt;call&lt;/span&gt; &lt;span class="pl-en"&gt;LanguageClient#textDocument_documentSymbol&lt;/span&gt;()&lt;span class="pl-c1"&gt;&amp;lt;CR&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Use &lt;kbd&gt;Ctrl+x&lt;/kbd&gt;&lt;kbd&gt;Ctrl+o&lt;/kbd&gt; (&lt;code&gt;&amp;lt;C-x&amp;gt;&amp;lt;C-o&amp;gt;&lt;/code&gt;) to open up the auto-complete menu,
or for asynchronous auto-completion, follow the setup instructions on
&lt;a href="https://github.com/autozimu/LanguageClient-neovim"&gt;LanguageClient&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you'd like diagnostics to be highlighted, add a highlight group for &lt;code&gt;ALEError&lt;/code&gt;/&lt;code&gt;ALEWarning&lt;/code&gt;/&lt;code&gt;ALEInfo&lt;/code&gt;,
or customize &lt;code&gt; g:LanguageClient_diagnosticsDisplay&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-viml"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;hi&lt;/span&gt; &lt;span class="pl-c1"&gt;link&lt;/span&gt; &lt;span class="pl-v"&gt;ALEError&lt;/span&gt; &lt;span class="pl-v"&gt;Error&lt;/span&gt;
&lt;span class="pl-c1"&gt;hi&lt;/span&gt; Warning &lt;span class="pl-c1"&gt;term&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;underline&lt;/span&gt; cterm&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;underline&lt;/span&gt; ctermfg&lt;span class="pl-k"&gt;=&lt;/span&gt;Yellow &lt;span class="pl-c1"&gt;gui&lt;/span&gt;&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;undercurl&lt;/span&gt; guisp&lt;span class="pl-k"&gt;=&lt;/span&gt;Gold
&lt;span class="pl-c1"&gt;hi&lt;/span&gt; &lt;span class="pl-c1"&gt;link&lt;/span&gt; &lt;span class="pl-v"&gt;ALEWarning&lt;/span&gt; &lt;span class="pl-v"&gt;Warning&lt;/span&gt;
&lt;span class="pl-c1"&gt;hi&lt;/span&gt; &lt;span class="pl-c1"&gt;link&lt;/span&gt; &lt;span class="pl-v"&gt;ALEInfo&lt;/span&gt; &lt;span class="pl-v"&gt;SpellCap&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you're finding that the server isn't starting at the correct project root,
it may also be helpful to also specify root markers:&lt;/p&gt;
&lt;div class="highlight highlight-source-viml"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-smi"&gt;&lt;span class="pl-k"&gt;g:&lt;/span&gt;LanguageClient_rootMarkers&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;*.cabal&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;stack.yaml&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-atom" class="anchor" aria-hidden="true" href="#using-hie-with-atom"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Atom&lt;/h3&gt;
&lt;p&gt;Make sure HIE is installed, then install the two Atom packages &lt;a href="https://atom.io/packages/atom-ide-ui" rel="nofollow"&gt;atom-ide-ui&lt;/a&gt; and &lt;a href="https://atom.io/packages/ide-haskell-hie" rel="nofollow"&gt;ide-haskell-hie&lt;/a&gt;,&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ apm install language-haskell atom-ide-ui ide-haskell-hie&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-emacs" class="anchor" aria-hidden="true" href="#using-hie-with-emacs"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Emacs&lt;/h3&gt;
&lt;p&gt;Install HIE along with the following emacs packages:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/emacs-lsp/lsp-mode"&gt;lsp-mode&lt;/a&gt;
&lt;a href="https://github.com/emacs-lsp/lsp-ui"&gt;lsp-ui&lt;/a&gt;
&lt;a href="https://github.com/emacs-lsp/lsp-haskell"&gt;lsp-haskell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Make sure to follow the instructions in the README of each of these packages.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-spacemacs" class="anchor" aria-hidden="true" href="#using-hie-with-spacemacs"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Spacemacs&lt;/h3&gt;
&lt;p&gt;Install HIE, and then add the following to your &lt;code&gt;.spacemacs&lt;/code&gt; config,&lt;/p&gt;
&lt;div class="highlight highlight-source-lisp"&gt;&lt;pre&gt;(&lt;span class="pl-k"&gt;defun&lt;/span&gt; &lt;span class="pl-en"&gt;dotspacemacs&lt;/span&gt;/layers ()
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;...&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
  (setq-default
   &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;;&lt;/span&gt;; ...&lt;/span&gt;
   dotspacemacs-configuration-layers
   '(
     (haskell :variables haskell-completion-backend 'lsp)
     lsp
     )
    ))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now you should be able to use HIE in Spacemacs.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-using-hie-with-oni" class="anchor" aria-hidden="true" href="#using-hie-with-oni"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using HIE with Oni&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.onivim.io/" rel="nofollow"&gt;Oni&lt;/a&gt; (a Neovim GUI) added built-in support for HIE, using stack, in &lt;a href="https://github.com/onivim/oni/pull/1918/files"&gt;#1918&lt;/a&gt;. If you need to change the configuration for HIE, you can overwrite the following settings in your &lt;code&gt;~/.config/oni/config.tsx&lt;/code&gt; file (accessible via the command palette and &lt;code&gt;Configuration: Edit User Config&lt;/code&gt;),&lt;/p&gt;
&lt;div class="highlight highlight-source-js"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;export&lt;/span&gt; &lt;span class="pl-k"&gt;const&lt;/span&gt; &lt;span class="pl-c1"&gt;configuration&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; {
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;language.haskell.languageServer.command&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;stack&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;language.haskell.languageServer.arguments&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;exec&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;--&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hie&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;],
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;language.haskell.languageServer.rootFiles&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.git&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;],
  &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;language.haskell.languageServer.configuration&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt; {},
}&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id="user-content-docs-on-hovercompletion" class="anchor" aria-hidden="true" href="#docs-on-hovercompletion"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Docs on hover/completion&lt;/h2&gt;
&lt;p&gt;HIE supports fetching docs from haddock on hover. It will fallback on using a hoogle db(generally located in ~/.hoogle on linux)
if no haddock documentation is found.&lt;/p&gt;
&lt;p&gt;To generate haddock documentation for stack projects:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ &lt;span class="pl-c1"&gt;cd&lt;/span&gt; your-project-directory
$ stack haddock --keep-going&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To enable documentation generation for cabal projects, add the following to your ~/.cabal/config&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;documentation: True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To generate a hoogle database that hie can use&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ &lt;span class="pl-c1"&gt;cd&lt;/span&gt; haskell-ide-engine
$ stack --stack-yaml=&lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;stack.yaml you used to build hie&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;exec&lt;/span&gt; hoogle generate&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Or you can set the environment variable &lt;code&gt;HIE_HOOGLE_DATABASE&lt;/code&gt; to specify a specific database.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Contributing&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-planned-features" class="anchor" aria-hidden="true" href="#planned-features"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Planned Features&lt;/h3&gt;
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""&gt; Multiproject support&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox" checked=""&gt; New-build support&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; Project wide references&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; Cross project find definition&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; More HaRe refactorings&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; More code actions&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; Cross project/dependency Find Definition&lt;/li&gt;
&lt;li class="task-list-item"&gt;&lt;input type="checkbox" id="" disabled="" class="task-list-item-checkbox"&gt; Case splitting, type insertion etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This project is not started from scratch:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;See why &lt;a href="/docs/Challenges.md"&gt;we should supersede previous tools&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Check the &lt;a href="/docs/Tools.md"&gt;list of existing tools and functionality&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;See more &lt;a href="/docs/Inspirations.md"&gt;other tools and IDEs for inspiration&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;&lt;a id="user-content-its-time-to-join-the-project" class="anchor" aria-hidden="true" href="#its-time-to-join-the-project"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;It's time to join the project!&lt;/h3&gt;
&lt;p&gt;&lt;g-emoji class="g-emoji" alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png"&gt;❤️&lt;/g-emoji&gt; Haskell tooling dream is near, we need your help! &lt;g-emoji class="g-emoji" alias="heart" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png"&gt;❤️&lt;/g-emoji&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Register in &lt;a href="https://groups.google.com/forum/#!forum/haskell-ide" rel="nofollow"&gt;our google group mailing list&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Join &lt;a href="https://webchat.freenode.net/?channels=haskell-ide-engine" rel="nofollow"&gt;our IRC channel&lt;/a&gt; at &lt;code&gt;#haskell-ide-engine&lt;/code&gt; on &lt;code&gt;freenode&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fork this repo and hack as much as you can.&lt;/li&gt;
&lt;li&gt;Ask @alanz or @hvr to join the project.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-hacking-on-haskell-ide-engine" class="anchor" aria-hidden="true" href="#hacking-on-haskell-ide-engine"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Hacking on haskell-ide-engine&lt;/h3&gt;
&lt;p&gt;Haskell-ide-engine can be used on its own project.  We have supplied
preset samples of &lt;code&gt;hie.yaml&lt;/code&gt; files for stack and cabal, simply copy
the appropriate template to &lt;code&gt;hie.yaml&lt;/code&gt; and it shoule work.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;hie.yaml.cbl&lt;/code&gt; for cabal&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hie.yaml.stack&lt;/code&gt; for stack&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-documentation" class="anchor" aria-hidden="true" href="#documentation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Documentation&lt;/h2&gt;
&lt;p&gt;All the documentation is in &lt;a href="/docs"&gt;the docs folder&lt;/a&gt; at the root of this project.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-architecture" class="anchor" aria-hidden="true" href="#architecture"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Architecture&lt;/h3&gt;
&lt;p&gt;Have a look at&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the &lt;a href="docs/Architecture.md"&gt;Architecture discussion&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="docs/Protocol.md"&gt;Protocol discussion&lt;/a&gt; and&lt;/li&gt;
&lt;li&gt;&lt;a href="docs/Design.md"&gt;Design discussion&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-troubleshooting" class="anchor" aria-hidden="true" href="#troubleshooting"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Troubleshooting&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-emacs" class="anchor" aria-hidden="true" href="#emacs"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Emacs&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-parse-errors-file-state-going-out-of-sync" class="anchor" aria-hidden="true" href="#parse-errors-file-state-going-out-of-sync"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Parse errors, file state going out of sync&lt;/h4&gt;
&lt;p&gt;With the &lt;code&gt;lsp-mode&lt;/code&gt; client for Emacs, it seems that the document can very easily get out of sync between, which leads to parse errors being displayed. To fix this, enable full document synchronization with&lt;/p&gt;
&lt;div class="highlight highlight-source-emacs-lisp"&gt;&lt;pre&gt;(&lt;span class="pl-k"&gt;setq&lt;/span&gt; lsp-document-sync-method &lt;span class="pl-c1"&gt;'full&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-emacs-direnv-loads-environment-too-late" class="anchor" aria-hidden="true" href="#emacs-direnv-loads-environment-too-late"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href="https://github.com/wbolster/emacs-direnv"&gt;&lt;code&gt;emacs-direnv&lt;/code&gt;&lt;/a&gt; loads environment too late&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;emacs-direnv&lt;/code&gt; sometimes loads the environment too late, meaning &lt;code&gt;lsp-mode&lt;/code&gt; won't be able to find correct GHC/cabal versions. To fix this, add a direnv update hook &lt;em&gt;after&lt;/em&gt; adding the lsp hook for &lt;code&gt;haskell-mode&lt;/code&gt; (meaning the direnv hook is executed first, because hooks are LIFO):&lt;/p&gt;
&lt;div class="highlight highlight-source-emacs-lisp"&gt;&lt;pre&gt;(&lt;span class="pl-c1"&gt;add-hook&lt;/span&gt; &lt;span class="pl-c1"&gt;'haskell-mode-hook&lt;/span&gt; &lt;span class="pl-c1"&gt;'lsp&lt;/span&gt;)
(&lt;span class="pl-c1"&gt;add-hook&lt;/span&gt; &lt;span class="pl-c1"&gt;'haskell-mode-hook&lt;/span&gt; &lt;span class="pl-c1"&gt;'direnv-update-environment&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-dyld-on-macos" class="anchor" aria-hidden="true" href="#dyld-on-macos"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;DYLD on macOS&lt;/h3&gt;
&lt;p&gt;If you hit a problem that looks like &lt;code&gt;can't load .so/.DLL for: libiconv.dylib (dlopen(libiconv.dylib, 5): image not found)&lt;/code&gt;, it means that libraries cannot be found in the library path. We can hint where to look for them and append more paths to &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH:/usr/lib:/usr/local/lib"
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On practice &lt;code&gt;/usr/local/lib&lt;/code&gt; is full of dylibs linked by &lt;code&gt;brew&lt;/code&gt;. After you amend &lt;code&gt;DYLD_LIBRARY_PATH&lt;/code&gt;, some of the previously compiled application might not work and yell about incorrect linking, for example, &lt;code&gt;dyld: Symbol not found: __cg_jpeg_resync_to_restart&lt;/code&gt;. You may need to look up where it comes from and remove clashing links, in this case it were clashing images libs:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ brew unlink libjpeg
$ brew unlink libtiff
$ brew unlink libpng&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Recompile.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-macos-got-error-while-installing-ghc-861-or-862---dyld-library-not-loaded-usrlocaloptgmpliblibgmp10dylib" class="anchor" aria-hidden="true" href="#macos-got-error-while-installing-ghc-861-or-862---dyld-library-not-loaded-usrlocaloptgmpliblibgmp10dylib"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;macOS: Got error while installing GHC 8.6.1 or 8.6.2 - dyld: Library not loaded: /usr/local/opt/gmp/lib/libgmp.10.dylib&lt;/h3&gt;
&lt;p&gt;These builds have a dependency on &lt;a href="https://brew.sh" rel="nofollow"&gt;homebrew&lt;/a&gt;'s &lt;code&gt;gmp&lt;/code&gt; library. Install with brew: &lt;code&gt;brew install gmp&lt;/code&gt;.
&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/15769" rel="nofollow"&gt;Should be fixed in GHC 8.6.3.&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-macos-got-error-while-processing-diagnostics-unable-to-load-package-integer-gmp-1020" class="anchor" aria-hidden="true" href="#macos-got-error-while-processing-diagnostics-unable-to-load-package-integer-gmp-1020"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;macOS: Got error while processing diagnostics: unable to load package &lt;code&gt;integer-gmp-1.0.2.0&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/alanz/vscode-hie-server/issues/89#issuecomment-398212122"&gt;Rename the file&lt;/a&gt; at &lt;code&gt;~/.stack/programs/x86_64-osx/ghc-8.4.3/lib/ghc-8.4.3/integer-gmp-1.0.2.0/HSinteger-gmp-1.0.2.0.o&lt;/code&gt; to a temporary name.
&lt;a href="https://ghc.haskell.org/trac/ghc/ticket/15105" rel="nofollow"&gt;Should be fixed in GHC 8.8.1.&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-cannot-satisfy--package-id-package" class="anchor" aria-hidden="true" href="#cannot-satisfy--package-id-package"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;cannot satisfy -package-id &amp;lt;package&amp;gt;&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-is-package-base-x" class="anchor" aria-hidden="true" href="#is-package-base-x"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Is &amp;lt;package&amp;gt; base-x?&lt;/h4&gt;
&lt;p&gt;Make sure that the GHC version of HIE matches the one of the project. After that run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cabal configure
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then restart HIE (e.g. by restarting your editor).&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-is-there-a-hash--after-package" class="anchor" aria-hidden="true" href="#is-there-a-hash--after-package"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Is there a hash (#) after &amp;lt;package&amp;gt;?&lt;/h4&gt;
&lt;p&gt;Delete any &lt;code&gt;.ghc.environment*&lt;/code&gt; files in your project root and try again. (At the time of writing, cabal new-style projects are not supported with ghc-mod)&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-otherwise" class="anchor" aria-hidden="true" href="#otherwise"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Otherwise&lt;/h4&gt;
&lt;p&gt;Try running &lt;code&gt;cabal update&lt;/code&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-liquid-haskell" class="anchor" aria-hidden="true" href="#liquid-haskell"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Liquid Haskell&lt;/h3&gt;
&lt;p&gt;Liquid Haskell requires an SMT solver on the path. We do not take care of installing one, thus, Liquid Haskell will not run until one is installed.
The recommended SMT solver is &lt;a href="https://github.com/Z3Prover/z3"&gt;z3&lt;/a&gt;. To run the tests, it is also required to have an SMT solver on the path, otherwise the tests will fail for Liquid Haskell.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-profiling-haskell-ide-engine" class="anchor" aria-hidden="true" href="#profiling-haskell-ide-engine"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Profiling &lt;code&gt;haskell-ide-engine&lt;/code&gt;.&lt;/h3&gt;
&lt;p&gt;If you think &lt;code&gt;haskell-ide-engine&lt;/code&gt; is using a lot of memory then the most useful
thing you can do is prepare a profile of the memory usage whilst you're using
the program.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add &lt;code&gt;profiling: True&lt;/code&gt; to the cabal.project file of &lt;code&gt;haskell-ide-engine&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cabal new-build hie&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;(IMPORTANT) Add &lt;code&gt;profiling: True&lt;/code&gt; to the &lt;code&gt;cabal.project&lt;/code&gt; file of the project you want to profile.&lt;/li&gt;
&lt;li&gt;Make a wrapper script which calls the &lt;code&gt;hie&lt;/code&gt; you built in step 2 with the additional options &lt;code&gt;+RTS -hd -l-au&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Modify your editor settings to call this wrapper script instead of looking for &lt;code&gt;hie&lt;/code&gt; on the path&lt;/li&gt;
&lt;li&gt;Try using &lt;code&gt;h-i-e&lt;/code&gt; as normal and then process the &lt;code&gt;*.eventlog&lt;/code&gt; which will be created using  &lt;a href="http://hackage.haskell.org/package/eventlog2html" rel="nofollow"&gt;&lt;code&gt;eventlog2html&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Repeat the process again using different profiling options if you like.&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;a id="user-content-using-ghc-events-analyze" class="anchor" aria-hidden="true" href="#using-ghc-events-analyze"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using &lt;code&gt;ghc-events-analyze&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;haskell-ide-engine&lt;/code&gt; contains the necessary tracing functions to work with &lt;a href="http://www.well-typed.com/blog/2014/02/ghc-events-analyze/" rel="nofollow"&gt;&lt;code&gt;ghc-events-analyze&lt;/code&gt;&lt;/a&gt;. Each
request which is made will emit an event to the eventlog when it starts and finishes. This way you
can see if there are any requests which are taking a long time to complete or are blocking.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make sure that &lt;code&gt;hie&lt;/code&gt; is linked with the &lt;code&gt;-eventlog&lt;/code&gt; option. This can be achieved by adding the flag
to the &lt;code&gt;ghc-options&lt;/code&gt; field in the cabal file.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;hie&lt;/code&gt; as normal but with the addition of &lt;code&gt;+RTS -l&lt;/code&gt;. This will produce an eventlog called &lt;code&gt;hie.eventlog&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;ghc-events-analyze&lt;/code&gt; on the &lt;code&gt;hie.eventlog&lt;/code&gt; file to produce the rendered SVG. Warning, this might take a while and produce a big SVG file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The default options for &lt;code&gt;ghc-events-analyze&lt;/code&gt; will produce quite a wide chart which is difficult to view. You can try using less buckets in order
to make the chart quicker to generate and faster to render.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ghc-events-analyze hie.eventlog -b 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This support is similar to the logging capabilities &lt;a href="https://www.haskell.org/ghc/blog/20190924-eventful-ghc.html" rel="nofollow"&gt;built into GHC&lt;/a&gt;.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>haskell</author><guid isPermaLink="false">https://github.com/haskell/haskell-ide-engine</guid><pubDate>Tue, 07 Jan 2020 00:04:00 GMT</pubDate></item><item><title>facebook/duckling #5 in Haskell, This week</title><link>https://github.com/facebook/duckling</link><description>&lt;p&gt;&lt;i&gt;Language, engine, and tooling for expressing, testing, and evaluating composable language rules on input strings.&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://github.com/facebook/duckling/raw/master/logo.png"&gt;&lt;img src="https://github.com/facebook/duckling/raw/master/logo.png" alt="Duckling Logo" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a id="user-content-duckling-" class="anchor" aria-hidden="true" href="#duckling-"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Duckling &lt;a href="https://travis-ci.org/facebook/duckling" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/dc026295c990c04b7941234a5f2e2d3a32e0b317/68747470733a2f2f7472617669732d63692e6f72672f66616365626f6f6b2f6475636b6c696e672e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/facebook/duckling.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Duckling is a Haskell library that parses text into structured data.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;"the first Tuesday of October"
=&amp;gt; {"value":"2017-10-03T00:00:00.000-07:00","grain":"day"}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id="user-content-requirements" class="anchor" aria-hidden="true" href="#requirements"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Requirements&lt;/h2&gt;
&lt;p&gt;A Haskell environment is required. We recommend using
&lt;a href="https://haskell-lang.org/get-started" rel="nofollow"&gt;stack&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;On macOS you'll need to install PCRE development headers.
The easiest way to do that is with &lt;a href="https://brew.sh/" rel="nofollow"&gt;Homebrew&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install pcre
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If that doesn't help, try running &lt;code&gt;brew doctor&lt;/code&gt; and fix
the issues it finds.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-quickstart" class="anchor" aria-hidden="true" href="#quickstart"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Quickstart&lt;/h2&gt;
&lt;p&gt;To compile and run the binary:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack build
$ stack exec duckling-example-exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first time you run it, it will download all required packages.&lt;/p&gt;
&lt;p&gt;This runs a basic HTTP server. Example request:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl -XPOST http://0.0.0.0:8000/parse --data 'locale=en_GB&amp;amp;text=tomorrow at eight'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See &lt;code&gt;exe/ExampleMain.hs&lt;/code&gt; for an example on how to integrate Duckling in your
project.
If your backend doesn't run Haskell or if you don't want to spin your own Duckling server, you can directly use &lt;a href="https://wit.ai" rel="nofollow"&gt;wit.ai&lt;/a&gt;'s built-in entities.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-supported-dimensions" class="anchor" aria-hidden="true" href="#supported-dimensions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Supported dimensions&lt;/h2&gt;
&lt;p&gt;Duckling supports many languages, but most don't support all dimensions yet
(&lt;strong&gt;we need your help!&lt;/strong&gt;).
Please look into &lt;a href="https://github.com/facebook/duckling/blob/master/Duckling/Dimensions"&gt;this directory&lt;/a&gt; for language-specific support.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Dimension&lt;/th&gt;
&lt;th&gt;Example input&lt;/th&gt;
&lt;th&gt;Example value output&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;AmountOfMoney&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"42€"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":42,"type":"value","unit":"EUR"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CreditCardNumber&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"4111-1111-1111-1111"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":"4111111111111111","issuer":"visa"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Distance&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"6 miles"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":6,"type":"value","unit":"mile"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"3 mins"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":3,"minute":3,"unit":"minute","normalized":{"value":180,"unit":"second"}}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Email&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"&lt;a href="mailto:duckling-team@fb.com"&gt;duckling-team@fb.com&lt;/a&gt;"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":"duckling-team@fb.com"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Numeral&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"eighty eight"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":88,"type":"value"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Ordinal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"33rd"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":33,"type":"value"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;PhoneNumber&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"+1 (650) 123-4567"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":"(+1) 6501234567"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Quantity&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"3 cups of sugar"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":3,"type":"value","product":"sugar","unit":"cup"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Temperature&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"80F"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":80,"type":"value","unit":"fahrenheit"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"today at 9am"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"values":[{"value":"2016-12-14T09:00:00.000-08:00","grain":"hour","type":"value"}],"value":"2016-12-14T09:00:00.000-08:00","grain":"hour","type":"value"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Url&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"&lt;a href="https://api.wit.ai/message?q=hi" rel="nofollow"&gt;https://api.wit.ai/message?q=hi&lt;/a&gt;"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":"https://api.wit.ai/message?q=hi","domain":"api.wit.ai"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Volume&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;"4 gallons"&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{"value":4,"type":"value","unit":"gallon"}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href="https://github.com/facebook/duckling/blob/master/exe/CustomDimensionExample.hs"&gt;Custom dimensions&lt;/a&gt; are also supported.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-extending-duckling" class="anchor" aria-hidden="true" href="#extending-duckling"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Extending Duckling&lt;/h2&gt;
&lt;p&gt;To regenerate the classifiers and run the test suite:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack build :duckling-regen-exe &amp;amp;&amp;amp; stack exec duckling-regen-exe &amp;amp;&amp;amp; stack test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It's important to regenerate the classifiers after updating the code and before
running the test suite.&lt;/p&gt;
&lt;p&gt;To extend Duckling's support for a dimension in a given language, typically 4
files need to be updated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Duckling/&amp;lt;Dimension&amp;gt;/&amp;lt;Lang&amp;gt;/Rules.hs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Duckling/&amp;lt;Dimension&amp;gt;/&amp;lt;Lang&amp;gt;/Corpus.hs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Duckling/Dimensions/&amp;lt;Lang&amp;gt;.hs&lt;/code&gt; (if not already present in &lt;code&gt;Duckling/Dimensions/Common.hs&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Duckling/Rules/&amp;lt;Lang&amp;gt;.hs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To add a new language:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make sure that the language code used follows the &lt;a href="https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes" rel="nofollow"&gt;ISO-639-1 standard&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The first dimension to implement is &lt;code&gt;Numeral&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Follow &lt;a href="https://github.com/facebook/duckling/commit/24d3f199768be970149412c95b1c1bf5d76f8240"&gt;this example&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To add a new locale:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There should be a need for diverging rules between the locale and the language.&lt;/li&gt;
&lt;li&gt;Make sure that the locale code is a valid &lt;a href="https://www.iso.org/obp/ui/#search/code/" rel="nofollow"&gt;ISO3166 alpha2 country code&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Follow &lt;a href="https://github.com/facebook/duckling/commit/1ab5f447d2635fe6d48887a501d333a52adff5b9"&gt;this example&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rules have a name, a pattern and a production.
Patterns are used to perform character-level matching (regexes on input) and
concept-level matching (predicates on tokens).
Productions are arbitrary functions that take a list of tokens and return a new
token.&lt;/p&gt;
&lt;p&gt;The corpus (resp. negative corpus) is a list of examples that should (resp.
shouldn't) parse. The reference time for the corpus is Tuesday Feb 12, 2013 at
4:30am.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Duckling.Debug&lt;/code&gt; provides a few debugging tools:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ stack repl --no-load
&amp;gt; :l Duckling.Debug
&amp;gt; debug (makeLocale EN $ Just US) "in two minutes" [This Time]
in|within|after &amp;lt;duration&amp;gt; (in two minutes)
-- regex (in)
-- &amp;lt;integer&amp;gt; &amp;lt;unit-of-duration&amp;gt; (two minutes)
-- -- integer (0..19) (two)
-- -- -- regex (two)
-- -- minute (grain) (minutes)
-- -- -- regex (minutes)
[Entity {dim = "time", body = "in two minutes", value = RVal Time (TimeValue (SimpleValue (InstantValue {vValue = 2013-02-12 04:32:00 -0200, vGrain = Second})) [SimpleValue (InstantValue {vValue = 2013-02-12 04:32:00 -0200, vGrain = Second})] Nothing), start = 0, end = 14}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id="user-content-license" class="anchor" aria-hidden="true" href="#license"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;License&lt;/h2&gt;
&lt;p&gt;Duckling is BSD-licensed.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>facebook</author><guid isPermaLink="false">https://github.com/facebook/duckling</guid><pubDate>Tue, 07 Jan 2020 00:05:00 GMT</pubDate></item><item><title>thma/LtuPatternFactory #6 in Haskell, This week</title><link>https://github.com/thma/LtuPatternFactory</link><description>&lt;p&gt;&lt;i&gt;Lambda the ultimate Pattern Factory: FP, Haskell, Typeclassopedia vs Software Design Patterns&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-lambda-the-ultimate-pattern-factory" class="anchor" aria-hidden="true" href="#lambda-the-ultimate-pattern-factory"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lambda the Ultimate Pattern Factory&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://circleci.com/gh/thma/LtuPatternFactory" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/c3deaba64734e211331a122588d831254764245b/68747470733a2f2f636972636c6563692e636f6d2f67682f74686d612f4c74755061747465726e466163746f72792e7376673f7374796c653d737667" alt="CircleCI" data-canonical-src="https://circleci.com/gh/thma/LtuPatternFactory.svg?style=svg" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;My first programming languages were Lisp, Scheme, and ML. When I later started to work in OO languages like C++ and Java I noticed that idioms that are standard vocabulary in functional programming (fp) were not so easy to achieve and required sophisticated structures. Books like &lt;a href="https://en.wikipedia.org/wiki/Design_Patterns" rel="nofollow"&gt;Design Patterns: Elements of Reusable Object-Oriented Software&lt;/a&gt; were a great starting point to reason about those structures. One of my earliest findings was that several of the GoF-Patterns had a stark resemblance of structures that are built into in functional languages: for instance the strategy pattern corresponds to higher order functions in fp (more details see &lt;a href="#strategy"&gt;below&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Recently, while re-reading through the &lt;a href="https://wiki.haskell.org/Typeclassopedia" rel="nofollow"&gt;Typeclassopedia&lt;/a&gt; I thought it would be a good exercise to map the structure of software &lt;a href="https://en.wikipedia.org/wiki/Software_design_pattern#Classification_and_list" rel="nofollow"&gt;design-patterns&lt;/a&gt; to the concepts found in the Haskell type class library and in functional programming in general.&lt;/p&gt;
&lt;p&gt;By searching the web I found some blog entries studying specific patterns, but I did not come across any comprehensive study. As it seemed that nobody did this kind of work yet I found it worthy to spend some time on it and write down all my findings on the subject.&lt;/p&gt;
&lt;p&gt;I think this kind of exposition could be helpful if you are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a programmer with an OO background who wants to get a better grip on how to implement complexer designs in functional programming&lt;/li&gt;
&lt;li&gt;a functional programmer who wants to get a deeper intuition for type classes.&lt;/li&gt;
&lt;li&gt;studying the &lt;a href="https://wiki.haskell.org/Typeclassopedia" rel="nofollow"&gt;Typeclassopedia&lt;/a&gt; and are looking for an accompanying reading providing example use cases and working code.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;This project is work in progress, so please feel free to contact me with any corrections, adjustments, comments, suggestions and additional ideas you might have.
Please use the &lt;a href="https://github.com/thma/LtuPatternFactory/issues"&gt;Issue Tracker&lt;/a&gt; to enter your requests.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Table of contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#lambda-the-ultimate-pattern-factory"&gt;Lambda the ultimate pattern factory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#the-patternopedia"&gt;The Patternopedia&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#strategy--functor"&gt;Strategy → Functor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#singleton--applicative"&gt;Singleton → Applicative&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pipeline--monad"&gt;Pipeline → Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#nullobject--maybe-monad"&gt;NullObject → Maybe Monad&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#interpreter--reader-monad"&gt;Interpreter → Reader Monad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#aspect-weaving--monad-transformers"&gt;Aspect Weaving → Monad Transformers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#composite--semigroup--monoid"&gt;Composite → SemiGroup → Monoid&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#visitor--foldable"&gt;Visitor → Foldable&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#iterator--traversable"&gt;Iterator → Traversable&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#the-pattern-behind-the-patterns--category"&gt;The Pattern behind the Patterns → Category&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#fluent-api--comonad"&gt;Fluent Api → Comonad&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#beyond-type-class-patterns"&gt;Beyond type class patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#dependency-injection--parameter-binding-partial-application"&gt;Dependency Injection → Parameter Binding, Partial Application&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#command--functions-as-first-class-citizens"&gt;Command → Functions as First Class Citizens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#adapter--function-composition"&gt;Adapter → Function Composition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#template-method--type-class-default-functions"&gt;Template Method → type class default functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#creational-patterns"&gt;Creational Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#abstract-factory--functions-as-data-type-values"&gt;Abstract Factory → functions as data type values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#builder--record-syntax-smart-constructor"&gt;Builder → record syntax, smart constructor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#functional-programming-patterns"&gt;Functional Programming Patterns&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#higher-order-functions"&gt;Higher Order Functions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#map-reduce"&gt;Map Reduce&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#lazy-evaluation"&gt;Lazy Evaluation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="#reflection"&gt;Reflection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#conclusions"&gt;Conclusions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#some-interesting-links"&gt;Some related links&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-the-patternopedia" class="anchor" aria-hidden="true" href="#the-patternopedia"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The Patternopedia&lt;/h2&gt;
&lt;p&gt;The &lt;a href="https://wiki.haskell.org/wikiupload/8/85/TMR-Issue13.pdf" rel="nofollow"&gt;Typeclassopedia&lt;/a&gt; is a now classic paper that introduces the Haskell type classes by clarifying their algebraic and category-theoretic background. In particular it explains the relationships among those type classes.&lt;/p&gt;
&lt;p&gt;In this chapter I'm taking a tour through the Typeclassopedia from a design pattern perspective.
For each of the Typeclassopedia type classes I try to explain how it corresponds to structures applied in software design patterns.&lt;/p&gt;
&lt;p&gt;As a reference map I have included the following chart that depicts the Relationships between type classes covered in the Typeclassopedia:&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/4ff86a3e8ce3a3bc9e58ab72eb7d91f0578c02e5/68747470733a2f2f77696b692e6861736b656c6c2e6f72672f77696b6975706c6f61642f632f63372f54797065636c6173736f70656469612d6469616772616d2e737667"&gt;&lt;img src="https://camo.githubusercontent.com/4ff86a3e8ce3a3bc9e58ab72eb7d91f0578c02e5/68747470733a2f2f77696b692e6861736b656c6c2e6f72672f77696b6975706c6f61642f632f63372f54797065636c6173736f70656469612d6469616772616d2e737667" alt="The Haskell type classes covered by the Typeclassopedia" data-canonical-src="https://wiki.haskell.org/wikiupload/c/c7/Typeclassopedia-diagram.svg" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Solid arrows point from the general to the specific; that is, if there is an arrow from Foo to Bar it means that every Bar is (or should be, or can be made into) a Foo.&lt;/li&gt;
&lt;li&gt;Dotted lines indicate some other sort of relationship.&lt;/li&gt;
&lt;li&gt;Monad and ArrowApply are equivalent.&lt;/li&gt;
&lt;li&gt;Apply and Comonad are greyed out since they are not actually (yet?) in the standard Haskell libraries ∗.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-strategy--functor" class="anchor" aria-hidden="true" href="#strategy--functor"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Strategy → Functor&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"The strategy pattern [...] is a behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code receives run-time instructions as to which in a family of algorithms to use"&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/7648cba4a3eca544c2253671db583701fffb0ff1/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34352f57337344657369676e5f53747261746567795f44657369676e5f5061747465726e5f554d4c2e6a7067"&gt;&lt;img src="https://camo.githubusercontent.com/7648cba4a3eca544c2253671db583701fffb0ff1/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34352f57337344657369676e5f53747261746567795f44657369676e5f5061747465726e5f554d4c2e6a7067" alt="strategy pattern" data-canonical-src="https://upload.wikimedia.org/wikipedia/commons/4/45/W3sDesign_Strategy_Design_Pattern_UML.jpg" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;"In the above UML class diagram, the &lt;code&gt;Context&lt;/code&gt; class doesn't implement an algorithm directly. Instead, &lt;code&gt;Context&lt;/code&gt; refers to the  &lt;code&gt;Strategy&lt;/code&gt; interface for performing an algorithm (&lt;code&gt;strategy.algorithm()&lt;/code&gt;), which makes &lt;code&gt;Context&lt;/code&gt; independent of how an algorithm is implemented. The &lt;code&gt;Strategy1&lt;/code&gt; and &lt;code&gt;Strategy2&lt;/code&gt; classes implement the &lt;code&gt;Strategy&lt;/code&gt; interface, that is, implement (encapsulate) an algorithm."
(quoted from &lt;a href="https://en.wikipedia.org/wiki/Strategy_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;in C a strategy would be modelled as a function pointer that can be used to dispatch calls to different functions.&lt;/li&gt;
&lt;li&gt;In an OO language like Java a strategy would be modelled as a single strategy-method interface that would be implemented by different strategy classes that provide implementations of the strategy method.&lt;/li&gt;
&lt;li&gt;in functional programming a strategy is just a function that is passed as a parameter to a &lt;a href="https://en.wikipedia.org/wiki/Higher-order_function" rel="nofollow"&gt;higher order function&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We are starting with a simplified example working on Numbers. I'm defining Java interfaces for three simple strategies:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;interface&lt;/span&gt; &lt;span class="pl-en"&gt;StrategySquare&lt;/span&gt; {
        &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-en"&gt;algorithm&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;input&lt;/span&gt;);
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;interface&lt;/span&gt; &lt;span class="pl-en"&gt;StrategyDouble&lt;/span&gt; {
        &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-en"&gt;algorithm&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;input&lt;/span&gt;);
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;interface&lt;/span&gt; &lt;span class="pl-en"&gt;StrategyToString&lt;/span&gt; {
        &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-en"&gt;algorithm&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;input&lt;/span&gt;);
    }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These interface can then be implemented by concrete classes. I'm using anonymous classes to implement the strategies:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-smi"&gt;StrategySquare&lt;/span&gt; strategySquare &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;StrategySquare&lt;/span&gt;() {
    &lt;span class="pl-k"&gt;@Override&lt;/span&gt;
    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-en"&gt;algorithm&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;input&lt;/span&gt;) {
        &lt;span class="pl-k"&gt;return&lt;/span&gt; input &lt;span class="pl-k"&gt;*&lt;/span&gt; input;
    }
};&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once I've written this code my Java IDE tells me that this anonymous class could be replaced by a lambda expression. So I can simply implement the strategies as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-smi"&gt;StrategySquare&lt;/span&gt; strategySquare &lt;span class="pl-k"&gt;=&lt;/span&gt; input &lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; input &lt;span class="pl-k"&gt;*&lt;/span&gt; input;

&lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-smi"&gt;StrategyDouble&lt;/span&gt; strategyDouble &lt;span class="pl-k"&gt;=&lt;/span&gt; input &lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;*&lt;/span&gt; input;

&lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-smi"&gt;StrategyToString&lt;/span&gt; strategyToString &lt;span class="pl-k"&gt;=&lt;/span&gt; input &lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;valueOf(input);

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; now we can use the strategies as follows:&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; main(&lt;span class="pl-k"&gt;String&lt;/span&gt;[] args) {
    &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(strategySquare&lt;span class="pl-k"&gt;.&lt;/span&gt;algorithm(&lt;span class="pl-c1"&gt;4.0&lt;/span&gt;));
    &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(strategyDouble&lt;span class="pl-k"&gt;.&lt;/span&gt;algorithm(&lt;span class="pl-c1"&gt;4.0&lt;/span&gt;));
    &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(strategyToString&lt;span class="pl-k"&gt;.&lt;/span&gt;algorithm(strategySquare&lt;span class="pl-k"&gt;.&lt;/span&gt;algorithm(&lt;span class="pl-c1"&gt;5&lt;/span&gt;)));
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting point here is that in Java single method interfaces like &lt;code&gt;StrategySquare&lt;/code&gt; can be implemented by lambda expressions, that is anonymous functions.&lt;/p&gt;
&lt;p&gt;So the conclusion is: a single method interface of a strategy is just the type signature of a function.&lt;/p&gt;
&lt;p&gt;That's why in functional programming strategies are implemented as functions passed as arguments to &lt;em&gt;higher order&lt;/em&gt; functions. In Haskell our three strategies would be implemented as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; first we define simple strategies operating on numbers:&lt;/span&gt;
&lt;span class="pl-en"&gt;strategyDouble&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
strategyDouble n &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;&lt;span class="pl-k"&gt;*&lt;/span&gt;n

&lt;span class="pl-en"&gt;strategySquare&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
strategySquare n &lt;span class="pl-k"&gt;=&lt;/span&gt; n&lt;span class="pl-k"&gt;*&lt;/span&gt;n

&lt;span class="pl-en"&gt;strategyToString&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
strategyToString &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These &lt;em&gt;strategies&lt;/em&gt; – or rather functions – can then be used to perform operations on numbers, as shown in the following GHCi (The Glasgow Haskell Compiler REPL) session:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; strategySquare &lt;span class="pl-c1"&gt;15&lt;/span&gt;
&lt;span class="pl-c1"&gt;225&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; strategyDouble &lt;span class="pl-c1"&gt;8.0&lt;/span&gt;
&lt;span class="pl-c1"&gt;16.0&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; strategyToString &lt;span class="pl-c1"&gt;4&lt;/span&gt;
&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;4&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We are using the functions by applying them to some numeric values.&lt;/p&gt;
&lt;p&gt;One nice feature of functions is that they can be composed using the &lt;code&gt;(.)&lt;/code&gt; operator:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;(.)&lt;/span&gt;
&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;(.)&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; strategySquare ) &lt;span class="pl-c1"&gt;15&lt;/span&gt;
&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;225&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far we have been using functions directly and not as a parameter to some &lt;em&gt;higher order&lt;/em&gt; function, that is we are using them without a computational context referring to them.&lt;/p&gt;
&lt;p&gt;In the next step we will set up such a computational context.&lt;/p&gt;
&lt;p&gt;Let's assume we want to be able to apply our strategies defined above not only to single values but to lists of values. We don't want to rewrite our code, but rather reuse the existing functions and use them in a list context.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; applyInListContext applies a function of type Num a =&amp;gt; a -&amp;gt; b to a list of a's:&lt;/span&gt;
&lt;span class="pl-en"&gt;applyInListContext&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;b&lt;/span&gt;]
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; applying f to an empty list returns the empty list&lt;/span&gt;
applyInListContext f &lt;span class="pl-c1"&gt;[]&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; applying f to a list with head x returns (f x) 'consed' to a list&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; resulting from applying applyInListContext f to the tail of the list&lt;/span&gt;
applyInListContext f (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; (f x) &lt;span class="pl-k"&gt;:&lt;/span&gt; applyInListContext f xs

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; HLint, the Haskell linter advices us to use the predefined map function instead of our definition above:&lt;/span&gt;
applyInListContext &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can use the &lt;code&gt;applyInListContext&lt;/code&gt; function to apply strategies to lists of numbers:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; applyInListContext strategyDouble [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;,&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;14&lt;/span&gt;,&lt;span class="pl-c1"&gt;16&lt;/span&gt;,&lt;span class="pl-c1"&gt;18&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;]
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; applyInListContext strategySquare [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;16&lt;/span&gt;,&lt;span class="pl-c1"&gt;25&lt;/span&gt;,&lt;span class="pl-c1"&gt;36&lt;/span&gt;,&lt;span class="pl-c1"&gt;49&lt;/span&gt;,&lt;span class="pl-c1"&gt;64&lt;/span&gt;,&lt;span class="pl-c1"&gt;81&lt;/span&gt;,&lt;span class="pl-c1"&gt;100&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using this approach is not limited to lists but we can apply it to any other parametric datatype.
As an example we construct a &lt;code&gt;Context a&lt;/code&gt; type with the corresponding higher order function &lt;code&gt;applyInContext&lt;/code&gt;.
This function accepts a function of type &lt;code&gt;Num a =&amp;gt; (a -&amp;gt; b)&lt;/code&gt; and a &lt;code&gt;Context a&lt;/code&gt; and returns a &lt;code&gt;Context b&lt;/code&gt;.
The return value of type &lt;code&gt;Context b&lt;/code&gt; is constructed by applying the function &lt;code&gt;f&lt;/code&gt; of type &lt;code&gt;(a -&amp;gt; b)&lt;/code&gt; to the value &lt;code&gt;x&lt;/code&gt; which has been extracted from the input value &lt;code&gt;Context x&lt;/code&gt; by pattern matching:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;, &lt;span class="pl-e"&gt;Read&lt;/span&gt;)

&lt;span class="pl-en"&gt;applyInContext&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
applyInContext f (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; x) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Context&lt;/span&gt; (f x)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; using this in ghci:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; applyInContext (strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; strategySquare) (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-c1"&gt;14&lt;/span&gt;)
&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;196&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now imagine we would be asked to implement this way to apply functions within a context for yet another data type.
Wouldn't it be great to have a generic tool that would solve this problem for any context, thus avoiding to reinvent the wheel each time?&lt;/p&gt;
&lt;p&gt;In Functional Programming languages, the application of a function in a computational context is generalized with the type class &lt;code&gt;Functor&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt;  &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt;  &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;fmap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By comparing the signature of &lt;code&gt;fmap&lt;/code&gt; with our higher order functions &lt;code&gt;applyInListContext&lt;/code&gt; and &lt;code&gt;applyIncontext&lt;/code&gt;
we notice that they bear the same structure:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;    &lt;span class="pl-en"&gt;fmap&lt;/span&gt;               &lt;span class="pl-k"&gt;::&lt;/span&gt;          (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;       &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;

    &lt;span class="pl-en"&gt;applyInContext&lt;/span&gt;     &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;

    &lt;span class="pl-en"&gt;applyInListContext&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]       &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;b&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Actually the function &lt;code&gt;map&lt;/code&gt; (which had been suggested as a replacement for applyInContext by the Haskell Linter) is the &lt;code&gt;fmap&lt;/code&gt; implementation for the List Functor instance:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the same way the Functor definition for the Context type defines &lt;code&gt;fmap&lt;/code&gt; exactly as the &lt;code&gt;applyInIncontext&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; a) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Context&lt;/span&gt; (f a)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As deriving of Functor instances can be done mechanically for any algebraic data type there is no need to define Functor instances explicitely.
Instead of the the above &lt;code&gt;instance Functor&lt;/code&gt; declaration we let the compiler do the work for us by using the &lt;code&gt;DeriveFunctor&lt;/code&gt; pragma:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;{-# &lt;span class="pl-k"&gt;LANGUAGE&lt;/span&gt; DeriveFunctor #-}

&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Functor&lt;/span&gt;, &lt;span class="pl-e"&gt;Show&lt;/span&gt;, &lt;span class="pl-e"&gt;Read&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-composition-of-functors" class="anchor" aria-hidden="true" href="#composition-of-functors"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;composition of functors&lt;/h4&gt;
&lt;p&gt;In the beginning of this section we have seen that composition of functions using the &lt;code&gt;(.)&lt;/code&gt; operator is a very useful tool to construct complex functionality by chaining more simple functions.&lt;/p&gt;
&lt;p&gt;As stated in the &lt;a href="https://wiki.haskell.org/Typeclassopedia#Laws" rel="nofollow"&gt;Functor laws&lt;/a&gt; any Functor instance must ensure that:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; (g &lt;span class="pl-k"&gt;.&lt;/span&gt; h) &lt;span class="pl-k"&gt;=&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; g) &lt;span class="pl-k"&gt;.&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; h)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's try to verify this with our two example Functors &lt;code&gt;Context&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; strategySquare) (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-c1"&gt;7&lt;/span&gt;)
&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;49&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; this version is more efficient as we have to pattern match and reconstruct the Context only once:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; (strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; strategySquare) (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-c1"&gt;7&lt;/span&gt;)
&lt;span class="pl-ent"&gt;Context&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;49&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; now with a list context:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; strategySquare) [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;4&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;9&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;16&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;25&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;36&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;49&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;64&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;81&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;100&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; this version is more efficient as we iterate the list only once:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; (strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; strategySquare) [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;4&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;9&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;16&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;25&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;36&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;49&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;64&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;81&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;100&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But composition doesn't stop here:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt;) (strategyToString &lt;span class="pl-k"&gt;.&lt;/span&gt; strategySquare) (&lt;span class="pl-ent"&gt;Context&lt;/span&gt; [&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;])
&lt;span class="pl-ent"&gt;Context&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;36&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;49&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we can see, The two functors &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;Context&lt;/code&gt; can be composed and this composition is a new Functor &lt;code&gt;Context []&lt;/code&gt;. The composition &lt;code&gt;(fmap . fmap)&lt;/code&gt; can be used to apply our strategy functions on the wrapped integers 6 and 7.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-conclusion" class="anchor" aria-hidden="true" href="#conclusion"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;conclusion&lt;/h4&gt;
&lt;p&gt;Although it would be fair to say that the type class &lt;code&gt;Functor&lt;/code&gt; captures the essential idea of the strategy
pattern – namely the injecting of a function into a computational context and its execution in this context –
the usage of higher order functions is of course not limited to &lt;code&gt;Functors&lt;/code&gt; – we could use just any &lt;a href="#higher-order-functions"&gt;higher order function&lt;/a&gt;
fitting our purpose.&lt;/p&gt;
&lt;p&gt;Other type classes like &lt;a href="#visitor--foldable"&gt;&lt;code&gt;Foldable&lt;/code&gt;&lt;/a&gt; or &lt;a href="#iterator--traversable"&gt;&lt;code&gt;Traversable&lt;/code&gt;&lt;/a&gt; (which is a &lt;code&gt;Foldable Functor&lt;/code&gt;) can serve as helpful abstractions when dealing with typical use cases of applying variable strategies within a computational context.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Strategy.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-singleton--applicative" class="anchor" aria-hidden="true" href="#singleton--applicative"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Singleton → Applicative&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"The singleton pattern is a software design pattern that restricts the instantiation of a class to one object. This is useful when exactly one object is needed to coordinate actions across the system."
(quoted from &lt;a href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The singleton pattern ensures that multiple requests to a given object always return one and the same singleton instance.
In functional programming this semantics can be achieved by &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;let&lt;/span&gt; singleton &lt;span class="pl-k"&gt;=&lt;/span&gt; someExpensiveComputation
&lt;span class="pl-k"&gt;in&lt;/span&gt;  mainComputation

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;or in lambda notation:&lt;/span&gt;
(&lt;span class="pl-k"&gt;\&lt;/span&gt;singleton &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; mainComputation) someExpensiveComputation&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Via the &lt;code&gt;let&lt;/code&gt;-Binding we can thread the singleton through arbitrary code in the &lt;code&gt;in&lt;/code&gt; block. All occurences of &lt;code&gt;singleton&lt;/code&gt; in the &lt;code&gt;mainComputation&lt;/code&gt;will point to the same instance.&lt;/p&gt;
&lt;p&gt;Type classes provide several tools to make this kind of threading more convenient or even to avoid explicit threading of instances.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-using-applicative-functor-for-threading-of-singletons" class="anchor" aria-hidden="true" href="#using-applicative-functor-for-threading-of-singletons"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using Applicative Functor for threading of singletons&lt;/h4&gt;
&lt;p&gt;The following code defines a simple expression evaluator:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
           | &lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;
           | &lt;span class="pl-ent"&gt;Add&lt;/span&gt; (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;) (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;)
           | &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;) (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the environment is a list of tuples mapping variable names to values of type e&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [(&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-smi"&gt;e&lt;/span&gt;)]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a simple evaluator reducing expression to numbers&lt;/span&gt;
&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;
eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)   env &lt;span class="pl-k"&gt;=&lt;/span&gt; fetch x env
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)   env &lt;span class="pl-k"&gt;=&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; p q) env &lt;span class="pl-k"&gt;=&lt;/span&gt; eval p env &lt;span class="pl-k"&gt;+&lt;/span&gt; eval q env  
eval (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; p q) env &lt;span class="pl-k"&gt;=&lt;/span&gt; eval p env &lt;span class="pl-k"&gt;*&lt;/span&gt; eval q env&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;eval&lt;/code&gt; is a classic evaluator function that recursively evaluates sub-expression before applying &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;.
Note how the explicit &lt;code&gt;env&lt;/code&gt;parameter is threaded through the recursive eval calls. This is needed to have the
environment avalailable for variable lookup at any recursive call depth.&lt;/p&gt;
&lt;p&gt;If we now bind &lt;code&gt;env&lt;/code&gt; to a value as in the following snippet it is used as an immutable singleton within the recursive evaluation of &lt;code&gt;eval exp env&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;main &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
  &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-c1"&gt;exp&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;3&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;))
                (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))
      env &lt;span class="pl-k"&gt;=&lt;/span&gt; [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-c1"&gt;pi&lt;/span&gt;)]
  &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; eval &lt;span class="pl-c1"&gt;exp&lt;/span&gt; env&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Experienced Haskellers will notice the &lt;a href="https://wiki.haskell.org/Eta_conversion" rel="nofollow"&gt;"eta-reduction smell"&lt;/a&gt; in &lt;code&gt;eval (Var x) env = fetch x env&lt;/code&gt; which hints at the possibilty to remove &lt;code&gt;env&lt;/code&gt; as an explicit parameter. We can not do this right away as the other equations for &lt;code&gt;eval&lt;/code&gt; do not allow eta-reduction. In order to do so we have to apply the combinators of the &lt;code&gt;Applicative Functor&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;pure&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-en"&gt;(&amp;lt;*&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; ((&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;pure&lt;/span&gt;        &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;const&lt;/span&gt;
    &lt;span class="pl-en"&gt;(&amp;lt;*&amp;gt;)&lt;/span&gt; f g x &lt;span class="pl-k"&gt;=&lt;/span&gt; f x (g x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This &lt;code&gt;Applicative&lt;/code&gt; allows us to rewrite &lt;code&gt;eval&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;
eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)   &lt;span class="pl-k"&gt;=&lt;/span&gt; fetch x
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; p q) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval p  &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval q  
eval (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; p q) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval p  &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval q&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Any explicit handling of the variable &lt;code&gt;env&lt;/code&gt; is now removed.
(I took this example from the classic paper &lt;a href="http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf" rel="nofollow"&gt;Applicative programming with effects&lt;/a&gt; which details how &lt;code&gt;pure&lt;/code&gt; and &lt;code&gt;&amp;lt;*&amp;gt;&lt;/code&gt; correspond to the combinatory logic combinators &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;S&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Singleton.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-pipeline--monad" class="anchor" aria-hidden="true" href="#pipeline--monad"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Pipeline → Monad&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, a pipeline consists of a chain of processing elements (processes, threads, coroutines, functions, etc.), arranged so that the output of each element is the input of the next; the name is by analogy to a physical pipeline.
(Quoted from: &lt;a href="https://en.wikipedia.org/wiki/Pipeline_(software)" rel="nofollow"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The concept of pipes and filters in Unix shell scripts is a typical example of the pipeline architecture pattern.&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;$ &lt;span class="pl-c1"&gt;echo&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;|&lt;/span&gt; wc -w &lt;span class="pl-k"&gt;|&lt;/span&gt; xargs &lt;span class="pl-c1"&gt;printf&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;%d*3\n&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;|&lt;/span&gt; bc -l
6&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This works exactly as stated in the wikipedia definition of the pattern: the output of &lt;code&gt;echo "hello world"&lt;/code&gt; is used as input for the next command &lt;code&gt;wc -w&lt;/code&gt;. The ouptput of this command is then piped as input into &lt;code&gt;xargs printf "%d*3\n"&lt;/code&gt; and so on.
On the first glance this might look like ordinary function composition. We could for instance come up with the following approximation in Haskell:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;((&lt;span class="pl-c1"&gt;3&lt;/span&gt; &lt;span class="pl-k"&gt;*&lt;/span&gt;) &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt;) &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;6&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But with this design we missed an important feature of the chain of shell commands: The commands do not work on elementary types like Strings or numbers but on input and output streams that are used to propagate the actual elementary data around. So we can't just send a String into the &lt;code&gt;wc&lt;/code&gt; command as in &lt;code&gt;"hello world" | wc -w&lt;/code&gt;. Instead we have to use &lt;code&gt;echo&lt;/code&gt; to place the string into a stream that we can then use as input to the &lt;code&gt;wc&lt;/code&gt; command:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;echo&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;|&lt;/span&gt; wc -w&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we might say that &lt;code&gt;echo&lt;/code&gt; &lt;em&gt;injects&lt;/em&gt; the String &lt;code&gt;"hello world"&lt;/code&gt; into the stream context.
We can capture this behaviour in a functional program like this:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; The Stream type is a wrapper around an arbitrary payload type 'a'&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; echo injects an item of type 'a' into the Stream context&lt;/span&gt;
&lt;span class="pl-en"&gt;echo&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
echo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Stream&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the 'andThen' operator used for chaining commands&lt;/span&gt;
&lt;span class="pl-k"&gt;infixl&lt;/span&gt; &lt;span class="pl-c1"&gt;7&lt;/span&gt; &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt;
&lt;span class="pl-en"&gt;(|&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
&lt;span class="pl-ent"&gt;Stream&lt;/span&gt; x &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; f x


&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; echo and |&amp;gt; are used to create the actual pipeline&lt;/span&gt;
&lt;span class="pl-en"&gt;pipeline&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
pipeline str &lt;span class="pl-k"&gt;=&lt;/span&gt;
  echo str &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt; echo &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt; &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt; echo &lt;span class="pl-k"&gt;.&lt;/span&gt; (&lt;span class="pl-c1"&gt;3&lt;/span&gt; &lt;span class="pl-k"&gt;*&lt;/span&gt;)
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; now executing the program in ghci repl:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; pipeline &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Stream&lt;/span&gt; &lt;span class="pl-c1"&gt;6&lt;/span&gt;  &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;echo&lt;/code&gt; function injects any input into the &lt;code&gt;Stream&lt;/code&gt; context:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; echo &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Stream&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;|&amp;gt;&lt;/code&gt; (pronounced as "andThen") does the function chaining:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; echo &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt; echo &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt;
&lt;span class="pl-ent"&gt;Stream&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The result of &lt;code&gt;|&amp;gt;&lt;/code&gt; is of type &lt;code&gt;Stream b&lt;/code&gt; that's why we cannot just write &lt;code&gt;echo "hello world" |&amp;gt; words&lt;/code&gt;. We have to use echo  to create a &lt;code&gt;Stream&lt;/code&gt; output that can be digested by a subsequent &lt;code&gt;|&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The interplay of a Context type &lt;code&gt;Stream a&lt;/code&gt; and the functions &lt;code&gt;echo&lt;/code&gt; and &lt;code&gt;|&amp;gt;&lt;/code&gt; is a well known pattern from functional languages: it's the legendary &lt;em&gt;Monad&lt;/em&gt;. As the &lt;a href="https://en.wikipedia.org/wiki/Pipeline_(software)" rel="nofollow"&gt;Wikipedia article on the pipeline pattern&lt;/a&gt; states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Pipes and filters can be viewed as a form of functional programming, using byte streams as data objects; more specifically, they can be seen as a particular form of monad for I/O.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is an interesting paper available elaborating on the monadic nature of Unix pipes: &lt;a href="http://okmij.org/ftp/Computation/monadic-shell.html" rel="nofollow"&gt;Monadic Shell&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is the definition of the Monad type class in Haskell:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Sequentially compose two actions, passing any value produced&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; by the first as an argument to the second.&lt;/span&gt;
    &lt;span class="pl-en"&gt;(&amp;gt;&amp;gt;=)&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Inject a value into the monadic type.&lt;/span&gt;
    &lt;span class="pl-en"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By looking at the types of &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; and &lt;code&gt;return&lt;/code&gt; it's easy to see the direct correspondence to &lt;code&gt;|&amp;gt;&lt;/code&gt; and &lt;code&gt;echo&lt;/code&gt; in the pipeline example above:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;    &lt;span class="pl-en"&gt;(|&amp;gt;)&lt;/span&gt;   &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
    &lt;span class="pl-en"&gt;echo&lt;/span&gt;   &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Mhh, this is nice, but still looks a lot like ordinary composition of functions, just with the addition of a wrapper.
In this simplified example that's true, because we have designed the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator to simply unwrap a value from the Stream and bind it to the formal parameter of the subsequent function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;Stream&lt;/span&gt; x &lt;span class="pl-k"&gt;|&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; f x&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we are free to implement the &lt;code&gt;andThen&lt;/code&gt; operator in any way that we seem fit as long we maintain the type signature and the &lt;a href="https://en.wikipedia.org/wiki/Monad_%28functional_programming%29#Monad_laws" rel="nofollow"&gt;monad laws&lt;/a&gt;.
So we could for instance change the semantics of &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; to keep a log along the execution pipeline:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; The DeriveFunctor Language Pragma provides automatic derivation of Functor instances&lt;/span&gt;
{-# &lt;span class="pl-k"&gt;LANGUAGE&lt;/span&gt; DeriveFunctor #-}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a Log is just a list of Strings&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Log&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the Stream type is extended by a Log that keeps track of any logged messages&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;Log&lt;/span&gt;) &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;, &lt;span class="pl-e"&gt;Functor&lt;/span&gt;)

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
  &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;
  &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (f, _) &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; r &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f r  

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; our definition of the Logging Stream Monad:&lt;/span&gt;
&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; returns a Stream wrapping a tuple of the actual payload and an empty Log&lt;/span&gt;
  &lt;span class="pl-c1"&gt;return&lt;/span&gt; a &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (a, &lt;span class="pl-c1"&gt;[]&lt;/span&gt;)

  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; we define (&amp;gt;&amp;gt;=) to return a tuple (composed functions, concatenated logs)&lt;/span&gt;
  m1 &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; m2  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt;(f1, l1) &lt;span class="pl-k"&gt;=&lt;/span&gt; m1
                   &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt;(f2, l2) &lt;span class="pl-k"&gt;=&lt;/span&gt; m2 f1
               &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt;(f2, l1 &lt;span class="pl-k"&gt;++&lt;/span&gt; l2)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute length of a String and provide a log message&lt;/span&gt;
&lt;span class="pl-en"&gt;logLength&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
logLength str &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;let&lt;/span&gt; l &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt;(&lt;span class="pl-c1"&gt;words&lt;/span&gt; str)
                &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (l, [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;length(&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; str &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;) = &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt; l])

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; multiply x with 3 and provide a log message&lt;/span&gt;
&lt;span class="pl-en"&gt;logMultiply&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
logMultiply x &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;let&lt;/span&gt; z &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-c1"&gt;3&lt;/span&gt;
                &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (z, [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;multiply(&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt; x &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;, 3&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;) = &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt; z])

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the logging version of the pipeline&lt;/span&gt;
&lt;span class="pl-en"&gt;logPipeline&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;LoggerStream&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
logPipeline str &lt;span class="pl-k"&gt;=&lt;/span&gt;
  &lt;span class="pl-c1"&gt;return&lt;/span&gt; str &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; logLength &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; logMultiply

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in Ghci:&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; logPipeline &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello logging world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;LoggerStream&lt;/span&gt; (&lt;span class="pl-c1"&gt;9&lt;/span&gt;,[&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;length(hello logging world) = 3&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;multiply(3, 3) = 9&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What's noteworthy here is that Monads allow to make the mechanism of chaining functions &lt;em&gt;explicit&lt;/em&gt;. We can define what &lt;code&gt;andThen&lt;/code&gt; should mean in our pipeline by choosing a different Monad implementation.
So in a sense Monads could be called &lt;a href="http://book.realworldhaskell.org/read/monads.html#id642960" rel="nofollow"&gt;programmable semicolons&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To make this statement a bit clearer we will have a closer look at the internal workings of the &lt;code&gt;Maybe&lt;/code&gt; Monad in the next section.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Pipeline.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-nullobject--maybe-monad" class="anchor" aria-hidden="true" href="#nullobject--maybe-monad"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;NullObject → Maybe Monad&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] a null object is an object with no referenced value or with defined neutral ("null") behavior. The null object design pattern describes the uses of such objects and their behavior (or lack thereof).
&lt;a href="https://en.wikipedia.org/wiki/Null_object_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In functional programming the null object pattern is typically formalized with option types:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] an option type or maybe type is a polymorphic type that represents encapsulation of an optional value; e.g., it is used as the return type of functions which may or may not return a meaningful value when they are applied. It consists of a constructor which either is empty (named None or &lt;code&gt;Nothing&lt;/code&gt;), or which encapsulates the original data type &lt;code&gt;A&lt;/code&gt; (written &lt;code&gt;Just A&lt;/code&gt; or Some A).
&lt;a href="https://en.wikipedia.org/wiki/Option_type" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(See also: &lt;a href="http://blog.ploeh.dk/2018/04/23/null-object-as-identity/" rel="nofollow"&gt;Null Object as Identity&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;In Haskell the most simple option type is &lt;code&gt;Maybe&lt;/code&gt;. Let's directly dive into an example. We define a reverse index, mapping songs to album titles.
If we now lookup up a song title we may either be lucky and find the respective album or not so lucky when there is no album matching our song:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt;           &lt;span class="pl-c1"&gt;Data.Map&lt;/span&gt; (&lt;span class="pl-en"&gt;Map&lt;/span&gt;, &lt;span class="pl-en"&gt;fromList&lt;/span&gt;)
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-k"&gt;qualified&lt;/span&gt; &lt;span class="pl-c1"&gt;Data.Map&lt;/span&gt; &lt;span class="pl-k"&gt;as&lt;/span&gt; &lt;span class="pl-c1"&gt;Map&lt;/span&gt; (&lt;span class="pl-en"&gt;lookup&lt;/span&gt;) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; avoid clash with Prelude.lookup&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; type aliases for Songs and Albums&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt;   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt;  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the simplified reverse song index&lt;/span&gt;
&lt;span class="pl-en"&gt;songMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt;
songMap &lt;span class="pl-k"&gt;=&lt;/span&gt; fromList
    [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Baby Satellite&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Microgravity&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
    ,(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;An Ending&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Apollo: Atmospheres and Soundtracks&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can lookup this map by using the function &lt;code&gt;Map.lookup :: Ord k =&amp;gt; k -&amp;gt; Map k a -&amp;gt; Maybe a&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If no match is found it will return &lt;code&gt;Nothing&lt;/code&gt; if a match is found it will return &lt;code&gt;Just match&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;&lt;span class="pl-c1"&gt;lookup&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Baby Satellite&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; songMap
&lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Microgravity&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;&lt;span class="pl-c1"&gt;lookup&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;The Fairy Tale&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; songMap
&lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Actually the &lt;code&gt;Maybe&lt;/code&gt; type is defined as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt;  &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;  &lt;span class="pl-k"&gt;=&lt;/span&gt;  &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; | &lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Eq&lt;/span&gt;, &lt;span class="pl-e"&gt;Ord&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;All code using the &lt;code&gt;Map.lookup&lt;/code&gt; function will never be confronted with any kind of Exceptions, null pointers or other nasty things. Even in case of errors a lookup will always return a properly typed &lt;code&gt;Maybe&lt;/code&gt; instance. By pattern matching for &lt;code&gt;Nothing&lt;/code&gt; or &lt;code&gt;Just a&lt;/code&gt; client code can react on failing matches or positive results:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;    &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;&lt;span class="pl-c1"&gt;lookup&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Ancient Campfire&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; songMap &lt;span class="pl-k"&gt;of&lt;/span&gt;
        &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;sorry, could not find your song&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
        &lt;span class="pl-ent"&gt;Just&lt;/span&gt; a  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt; a&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's try to apply this to an extension of our simple song lookup.
Let's assume that our music database has much more information available. Apart from a reverse index from songs to albums, there might also be an index mapping album titles to artists.
And we might also have an index mapping artist names to their websites:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt;   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt;  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Artist&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-en"&gt;songMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt;
songMap &lt;span class="pl-k"&gt;=&lt;/span&gt; fromList
    [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Baby Satellite&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Microgravity&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
    ,(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;An Ending&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Apollo: Atmospheres and Soundtracks&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)]

&lt;span class="pl-en"&gt;albumMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt; &lt;span class="pl-en"&gt;Artist&lt;/span&gt;
albumMap &lt;span class="pl-k"&gt;=&lt;/span&gt; fromList
    [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Microgravity&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Biosphere&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
    ,(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Apollo: Atmospheres and Soundtracks&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Brian Eno&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)]

&lt;span class="pl-en"&gt;artistMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;Artist&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;
artistMap &lt;span class="pl-k"&gt;=&lt;/span&gt; fromList
    [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Biosphere&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://www.biosphere.no//&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
    ,(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Brian Eno&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://www.brian-eno.net&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)]

&lt;span class="pl-en"&gt;lookup'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
lookup' &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;flip&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;&lt;span class="pl-c1"&gt;lookup&lt;/span&gt;

&lt;span class="pl-en"&gt;findAlbum&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt;
findAlbum &lt;span class="pl-k"&gt;=&lt;/span&gt; lookup' songMap

&lt;span class="pl-en"&gt;findArtist&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Album&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Artist&lt;/span&gt;
findArtist &lt;span class="pl-k"&gt;=&lt;/span&gt; lookup' albumMap

&lt;span class="pl-en"&gt;findWebSite&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Artist&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;
findWebSite &lt;span class="pl-k"&gt;=&lt;/span&gt; lookup' artistMap&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With all this information at hand we want to write a function that has an input parameter of type &lt;code&gt;Song&lt;/code&gt; and returns a &lt;code&gt;Maybe URL&lt;/code&gt; by going from song to album to artist to website url:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;findUrlFromSong&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;
findUrlFromSong song &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;case&lt;/span&gt; findAlbum song &lt;span class="pl-k"&gt;of&lt;/span&gt;
        &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;    &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;
        &lt;span class="pl-ent"&gt;Just&lt;/span&gt; album &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;
            &lt;span class="pl-k"&gt;case&lt;/span&gt; findArtist album &lt;span class="pl-k"&gt;of&lt;/span&gt;
                &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;     &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;
                &lt;span class="pl-ent"&gt;Just&lt;/span&gt; artist &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;
                    &lt;span class="pl-k"&gt;case&lt;/span&gt; findWebSite artist &lt;span class="pl-k"&gt;of&lt;/span&gt;
                        &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;
                        &lt;span class="pl-ent"&gt;Just&lt;/span&gt; url &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; url&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code makes use of the pattern matching logic described before. It's worth to note that there is some nice circuit breaking happening in case of a &lt;code&gt;Nothing&lt;/code&gt;. In this case &lt;code&gt;Nothing&lt;/code&gt; is directly returned as result of the function and the rest of the case-ladder is not executed.
What's not so nice is &lt;em&gt;"the dreaded ladder of code marching off the right of the screen"&lt;/em&gt; &lt;a href="http://book.realworldhaskell.org/" rel="nofollow"&gt;(quoted from Real World Haskell)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For each find function we have to repeat the same ceremony of pattern matching on the result and either return &lt;code&gt;Nothing&lt;/code&gt; or proceed with the next nested level.&lt;/p&gt;
&lt;p&gt;The good news is that it is possible to avoid this ladder.
We can rewrite our search by applying the &lt;code&gt;andThen&lt;/code&gt; operator &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; as &lt;code&gt;Maybe&lt;/code&gt; is an instance of &lt;code&gt;Monad&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;findUrlFromSong'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;
findUrlFromSong' song &lt;span class="pl-k"&gt;=&lt;/span&gt;
    findAlbum song   &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;album &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;
    findArtist album &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;artist &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;
    findWebSite artist  &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;or even shorter as we can eliminate the lambda expressions by applying &lt;a href="https://wiki.haskell.org/Eta_conversion" rel="nofollow"&gt;eta-conversion&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;findUrlFromSong''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Song&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;URL&lt;/span&gt;
findUrlFromSong'' song &lt;span class="pl-k"&gt;=&lt;/span&gt;
    findAlbum song &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; findArtist &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; findWebSite&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using it in GHCi:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; findUrlFromSong'' &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;All you need is love&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; findUrlFromSong'' &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;An Ending&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://www.brian-eno.net&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The expression &lt;code&gt;findAlbum song &amp;gt;&amp;gt;= findArtist &amp;gt;&amp;gt;= findWebSite&lt;/code&gt; and the sequencing of actions in the &lt;a href="#pipeline---monad"&gt;pipeline&lt;/a&gt; example &lt;code&gt;return str &amp;gt;&amp;gt;= return . length . words &amp;gt;&amp;gt;= return . (3 *)&lt;/code&gt; have a similar structure.&lt;/p&gt;
&lt;p&gt;But the behaviour of both chains is quite different: In the Maybe Monad &lt;code&gt;a &amp;gt;&amp;gt;= b&lt;/code&gt; does not evaluate b if &lt;code&gt;a == Nothing&lt;/code&gt; but stops the whole chain of actions by simply returning &lt;code&gt;Nothing&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The pattern matching and 'short-circuiting' is directly coded into the definition of &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; in the Monad implementation of &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt;  &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt;  &lt;span class="pl-k"&gt;where&lt;/span&gt;
    (&lt;span class="pl-ent"&gt;Just&lt;/span&gt; x) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; k      &lt;span class="pl-k"&gt;=&lt;/span&gt; k x
    &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;  &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; _      &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This elegant feature of &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; in the &lt;code&gt;Maybe&lt;/code&gt; Monad allows us to avoid ugly and repetetive coding.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-avoiding-partial-functions-by-using-maybe" class="anchor" aria-hidden="true" href="#avoiding-partial-functions-by-using-maybe"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Avoiding partial functions by using Maybe&lt;/h4&gt;
&lt;p&gt;Maybe is often used to avoid the exposure of partial functions to client code. Take for example division by zero or computing the square root of negative numbers which are undefined (at least for real numbers).
Here come safe – that is total – definitions of these functions that return &lt;code&gt;Nothing&lt;/code&gt; for undefined cases:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;safeRoot&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeRoot x
    &lt;span class="pl-k"&gt;|&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (&lt;span class="pl-c1"&gt;sqrt&lt;/span&gt; x)
    &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;

&lt;span class="pl-en"&gt;safeReciprocal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeReciprocal x
    &lt;span class="pl-k"&gt;|&lt;/span&gt; x &lt;span class="pl-k"&gt;/=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;/&lt;/span&gt;x)
    &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we have already learned the monadic &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; operator allows to chain such function as in the following example:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;safeRootReciprocal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeRootReciprocal x &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; safeReciprocal &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; safeRoot&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This can be written even more terse as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;safeRootReciprocal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeRootReciprocal &lt;span class="pl-k"&gt;=&lt;/span&gt; safeReciprocal &lt;span class="pl-k"&gt;&amp;gt;=&amp;gt;&lt;/span&gt; safeRoot&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The use of the &lt;a href="https://www.stackage.org/haddock/lts-13.0/base-4.12.0.0/Control-Monad.html#v:-62--61--62-" rel="nofollow"&gt;Kleisli 'fish' operator &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;&lt;/a&gt;  makes it more evident that we are actually aiming at a composition of the monadic functions &lt;code&gt;safeReciprocal&lt;/code&gt; and &lt;code&gt;safeRoot&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are many predefined Monads available in the Haskell curated libraries and it's also possible to combine their effects by making use of &lt;code&gt;MonadTransformers&lt;/code&gt;. But that's a &lt;a href="#aspect-weaving--monad-transformers"&gt;different story...&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/NullObject.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-interpreter--reader-monad" class="anchor" aria-hidden="true" href="#interpreter--reader-monad"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Interpreter → Reader Monad&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer programming, the interpreter pattern is a design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol (terminal or nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and is used to evaluate (interpret) the sentence for a client.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Interpreter_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the section &lt;a href="#singleton--applicative"&gt;Singleton → Applicative&lt;/a&gt; we have already written a simple expression evaluator. From that section it should be obvious how easy the definition of evaluators and interpreters is in functional programming languages.&lt;/p&gt;
&lt;p&gt;The main ingredients are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Algebraic Data Types (ADT) used to define the expression data type which is to be evaluated&lt;/li&gt;
&lt;li&gt;An evaluator function that uses pattern matching on the expression ADT&lt;/li&gt;
&lt;li&gt;'implicit' threading of an environment&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the section on Singleton we have seen that some kind of 'implicit' threading of the environment can be already achieved with `Applicative Functors.
We still had the environment as an explicit parameter of the eval function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;e&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;but we could omit it in the pattern matching equations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)   &lt;span class="pl-k"&gt;=&lt;/span&gt; fetch x
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; p q) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval p  &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval q  
eval (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; p q) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval p  &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; eval q&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By using Monads the handling of the environment can be made even more implicit.&lt;/p&gt;
&lt;p&gt;I'll demonstrate this with a slightly extended version of the evaluator. In the first step we extend the expression syntax to also provide let expressions and generic support for binary operators:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a simple expression ADT&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt;
      &lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;                            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a variable to be looked up&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; (&lt;span class="pl-en"&gt;BinOperator&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a binary operator applied to two expressions&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;Let&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) (&lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a let expression&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;                                 &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; an atomic value&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a binary operator type&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;BinOperator&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt;  &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; the environment is just a list of mappings from variable names to values&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [(&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-smi"&gt;a&lt;/span&gt;)]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this data type we can encode expressions like:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;let&lt;/span&gt; x &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;&lt;span class="pl-k"&gt;+&lt;/span&gt;&lt;span class="pl-c1"&gt;5&lt;/span&gt;
&lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;&lt;span class="pl-k"&gt;*&lt;/span&gt;x&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;Let&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;5&lt;/span&gt;))
        (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to evaluate such expression we must be able to modify the environment at runtime to create a binding for the variable &lt;code&gt;x&lt;/code&gt; which will be referred to in the &lt;code&gt;in&lt;/code&gt; part of the expression.&lt;/p&gt;
&lt;p&gt;Next we define an evaluator function that pattern matches the above expression ADT:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadReader&lt;/span&gt; (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)          &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; asks (fetch x)
eval (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; op e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 op (eval e1) (eval e2)
eval (&lt;span class="pl-ent"&gt;Let&lt;/span&gt; x e1 e2)    &lt;span class="pl-k"&gt;=&lt;/span&gt; eval e1 &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;v &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; local ((x,v)&lt;span class="pl-k"&gt;:&lt;/span&gt;) (eval e2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's explore this dense code line by line.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadReader&lt;/span&gt; (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most simple instance for &lt;code&gt;MonadReader&lt;/code&gt; is the partially applied function type &lt;code&gt;((-&amp;gt;) env)&lt;/code&gt;.
Let's assume the compiler will choose this type as the &lt;code&gt;MonadReader&lt;/code&gt; instance. We can then rewrite the function signature as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; ((&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)) &lt;span class="pl-smi"&gt;a&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expanding m to ((-&amp;gt;) (Env a))&lt;/span&gt;
&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; applying infix notation for (-&amp;gt;)&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is exactly the signature we were using for the &lt;code&gt;Applicative&lt;/code&gt; eval function which matches our original intent to eval an expression of type &lt;code&gt;Exp a&lt;/code&gt; in an environment of type &lt;code&gt;Env a&lt;/code&gt; to a result of type &lt;code&gt;a&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)          &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; i&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this line we are pattern matching for a &lt;code&gt;(Val i)&lt;/code&gt;. The atomic value &lt;code&gt;i&lt;/code&gt; is &lt;code&gt;return&lt;/code&gt;ed, that is lifted to a value of the type &lt;code&gt;Env a -&amp;gt; a&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; asks (fetch x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;asks&lt;/code&gt; is a helper function that applies its argument &lt;code&gt;f :: env -&amp;gt; a&lt;/code&gt; (in our case &lt;code&gt;(fetch x)&lt;/code&gt; which looks up variable &lt;code&gt;x&lt;/code&gt;) to the environment. &lt;code&gt;asks&lt;/code&gt; is thus typically used to handle environment lookups:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;asks&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;MonadReader&lt;/span&gt; &lt;span class="pl-smi"&gt;env&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;env&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
asks f &lt;span class="pl-k"&gt;=&lt;/span&gt; ask &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; f&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now to the next line handling the application of a binary operator:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; op e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 op (eval e1) (eval e2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;op&lt;/code&gt; is a binary function of type &lt;code&gt;a -&amp;gt; a -&amp;gt; a&lt;/code&gt; (typical examples are binary arithmetic functions like &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We want to apply this operation on the two expressions &lt;code&gt;(eval e1)&lt;/code&gt; and &lt;code&gt;(eval e2)&lt;/code&gt;.
As these expressions both are to be executed within the same monadic context we have to use &lt;code&gt;liftM2&lt;/code&gt; to lift &lt;code&gt;op&lt;/code&gt; into this context:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Promote a function to a monad, scanning the monadic arguments from&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; left to right.  For example,&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &amp;gt; liftM2 (+) [0,1] [0,2] = [0,2,1,3]&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &amp;gt; liftM2 (+) (Just 1) Nothing = Nothing&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-en"&gt;liftM2&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a1&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a2&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;r&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a1&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a2&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;r&lt;/span&gt;
liftM2 f m1 m2 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt; { x1 &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; m1; x2 &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; m2; &lt;span class="pl-c1"&gt;return&lt;/span&gt; (f x1 x2) }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The last step is the evaluation of &lt;code&gt;Let x e1 e2&lt;/code&gt; expressions like &lt;code&gt;Let "x" (Val 7) (BinOp (+) (Var "x") (Val 5))&lt;/code&gt;. To make this work we have to evaluate &lt;code&gt;e1&lt;/code&gt; and extend the environment by a binding of the variable &lt;code&gt;x&lt;/code&gt; to the result of that evaluation.
Then we have to evaluate &lt;code&gt;e2&lt;/code&gt; in the context of the extended environment:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;Let&lt;/span&gt; x e1 e2)    &lt;span class="pl-k"&gt;=&lt;/span&gt; eval e1 &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;v &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;           &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; bind the result of (eval e1) to v&lt;/span&gt;
                        local ((x,v)&lt;span class="pl-k"&gt;:&lt;/span&gt;) (eval e2)    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; add (x,v) to the env, eval e2 in the extended env&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting part here is the helper function &lt;code&gt;local f m&lt;/code&gt; which applies &lt;code&gt;f&lt;/code&gt; to the environment and then executes &lt;code&gt;m&lt;/code&gt; against the (locally) changed environment.
Providing a locally modified environment as the scope of the evaluation of &lt;code&gt;e2&lt;/code&gt; is exactly what the &lt;code&gt;let&lt;/code&gt; binding intends:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Executes a computation in a modified environment.&lt;/span&gt;
&lt;span class="pl-en"&gt;local&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;r&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;r&lt;/span&gt;) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;^&lt;/span&gt; The function to modify the environment.&lt;/span&gt;
        &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;^&lt;/span&gt; @Reader@ to run in the modified environment.&lt;/span&gt;
        &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;MonadReader&lt;/span&gt; &lt;span class="pl-smi"&gt;r&lt;/span&gt; ((&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) &lt;span class="pl-smi"&gt;r&lt;/span&gt;) &lt;span class="pl-k"&gt;where&lt;/span&gt;
    local f m &lt;span class="pl-k"&gt;=&lt;/span&gt; m &lt;span class="pl-k"&gt;.&lt;/span&gt; f&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we can use &lt;code&gt;eval&lt;/code&gt; to evaluate our example expression:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;interpreterDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Interpreter -&amp;gt; Reader Monad + ADTs + pattern matching&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; exp1 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Let&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
                (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;5&lt;/span&gt;))
                (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; runReader (eval exp1) env

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; an then in GHCi:&lt;/span&gt;

&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; interpreterDemo
&lt;span class="pl-c1"&gt;18&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By virtue of the &lt;code&gt;local&lt;/code&gt; function we used &lt;code&gt;MonadReader&lt;/code&gt; as if it provided modifiable state. So for many use cases that require only &lt;em&gt;local&lt;/em&gt; state modifications its not required to use the somewhat more tricky &lt;code&gt;MonadState&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Writing the interpreter function with a &lt;code&gt;MonadState&lt;/code&gt; looks like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval1&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;MonadState&lt;/span&gt; (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
eval1 (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)          &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; i
eval1 (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; gets (fetch x)
eval1 (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; op e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 op (eval1 e1) (eval1 e2)
eval1 (&lt;span class="pl-ent"&gt;Let&lt;/span&gt; x e1 e2)    &lt;span class="pl-k"&gt;=&lt;/span&gt; eval1 e1        &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;v &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;
                         modify ((x,v)&lt;span class="pl-k"&gt;:&lt;/span&gt;) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
                         eval1 e2&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This section was inspired by ideas presented in &lt;a href="https://donsbot.wordpress.com/2006/12/11/quick-interpreters-with-the-reader-monad/" rel="nofollow"&gt;Quick Interpreters with the Reader Monad&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Interpreter.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-aspect-weaving--monad-transformers" class="anchor" aria-hidden="true" href="#aspect-weaving--monad-transformers"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Aspect Weaving → Monad Transformers&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. It does so by adding additional behavior to existing code (an advice) without modifying the code itself, instead separately specifying which code is modified via a "pointcut" specification, such as "log all function calls when the function's name begins with 'set'". This allows behaviors that are not central to the business logic (such as logging) to be added to a program without cluttering the code, core to the functionality.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id="user-content-stacking-monads" class="anchor" aria-hidden="true" href="#stacking-monads"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Stacking Monads&lt;/h3&gt;
&lt;p&gt;In section
&lt;a href="#interpreter--reader-monad"&gt;Interpreter -&amp;gt; Reader Monad&lt;/a&gt;
we specified an Interpreter of a simple expression language by defining a monadic &lt;code&gt;eval&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Reader&lt;/span&gt; (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-smi"&gt;a&lt;/span&gt;  
eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; asks (fetch x)
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)          &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; op e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 op (eval e1) (eval e2)
eval (&lt;span class="pl-ent"&gt;Let&lt;/span&gt; x e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; eval e1 &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;v &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; local ((x,v)&lt;span class="pl-k"&gt;:&lt;/span&gt;) (eval e2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the &lt;code&gt;Reader&lt;/code&gt; Monad allows to thread an environment through all recursive calls of &lt;code&gt;eval&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A typical extension to such an interpreter would be to provide a log mechanism that allows tracing of the actual sequence of all performed evaluation steps.&lt;/p&gt;
&lt;p&gt;In Haskell the typical way to provide such a log is by means of the &lt;code&gt;Writer Monad&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But how to combine the capabilities of the &lt;code&gt;Reader&lt;/code&gt; monad code with those of the &lt;code&gt;Writer&lt;/code&gt; monad?&lt;/p&gt;
&lt;p&gt;The answer is &lt;code&gt;MonadTransformer&lt;/code&gt;s: specialized types that allow us to stack two monads into a single one that shares the behavior of both.&lt;/p&gt;
&lt;p&gt;In order to stack the &lt;code&gt;Writer&lt;/code&gt; monad on top of the &lt;code&gt;Reader&lt;/code&gt; we use the transformer type &lt;code&gt;WriterT&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; adding a logging capability to the expression evaluator&lt;/span&gt;
&lt;span class="pl-en"&gt;eval&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WriterT&lt;/span&gt; [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;] (&lt;span class="pl-en"&gt;Reader&lt;/span&gt; (&lt;span class="pl-en"&gt;Env&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)) &lt;span class="pl-smi"&gt;a&lt;/span&gt;
eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; tell [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lookup &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; x] &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; asks (fetch x)
eval (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; i)          &lt;span class="pl-k"&gt;=&lt;/span&gt; tell [&lt;span class="pl-c1"&gt;show&lt;/span&gt; i] &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; i
eval (&lt;span class="pl-ent"&gt;BinOp&lt;/span&gt; op e1 e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; tell [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Op&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;] &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; liftM2 op (eval e1) (eval e2)
eval (&lt;span class="pl-ent"&gt;Let&lt;/span&gt; x e1 e2)    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    tell [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;let &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; x]
    v &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; eval e1
    tell [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;in&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
    local ((x,v)&lt;span class="pl-k"&gt;:&lt;/span&gt;) (eval e2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The signature of &lt;code&gt;eval&lt;/code&gt; has been extended by Wrapping &lt;code&gt;WriterT [String]&lt;/code&gt; around &lt;code&gt;(Reader (Env a))&lt;/code&gt;. This denotes a Monad that combines a &lt;code&gt;Reader (Env a)&lt;/code&gt; with a &lt;code&gt;Writer [String]&lt;/code&gt;.  &lt;code&gt;Writer [String]&lt;/code&gt; is a &lt;code&gt;Writer&lt;/code&gt; that maintains a list of strings as log.&lt;/p&gt;
&lt;p&gt;The resulting Monad supports function of both &lt;code&gt;MonadReader&lt;/code&gt; and &lt;code&gt;MonadWriter&lt;/code&gt; typeclasses. As you can see in the equation for &lt;code&gt;eval (Var x)&lt;/code&gt; we are using &lt;code&gt;MonadWriter.tell&lt;/code&gt; for logging and &lt;code&gt;MonadReader.asks&lt;/code&gt; for obtaining the environment and compose both monadic actions by &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;eval (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)          &lt;span class="pl-k"&gt;=&lt;/span&gt; tell [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lookup &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; x] &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; asks (fetch x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to execute this stacked up monads we have to apply the &lt;code&gt;run&lt;/code&gt; functions of &lt;code&gt;WriterT&lt;/code&gt; and &lt;code&gt;Reader&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; runReader (runWriterT (eval letExp)) [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;pi&lt;/span&gt;)]
(&lt;span class="pl-c1"&gt;6.283185307179586&lt;/span&gt;,[&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;let x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;let y&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Op&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;5.0&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;7.0&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;in&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Op&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lookup y&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;6.0&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;in&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Op&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lookup pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;lookup x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more details on MonadTransformers please have a look at the following tutorials:&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikibooks.org/wiki/Haskell/Monad_transformers" rel="nofollow"&gt;MonadTransformers Wikibook&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://page.mi.fu-berlin.de/scravy/realworldhaskell/materialien/monad-transformers-step-by-step.pdf" rel="nofollow"&gt;Monad Transformers step by step&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-specifying-aop-semantics-with-monadtransformers" class="anchor" aria-hidden="true" href="#specifying-aop-semantics-with-monadtransformers"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Specifying AOP semantics with MonadTransformers&lt;/h3&gt;
&lt;p&gt;What we have seen so far is that it possible to form Monad stacks that combine the functionality of the Monads involved: In a way a MonadTransformer adds capabilities that are cross-cutting to those of the underlying Monad.&lt;/p&gt;
&lt;p&gt;In the following lines I want to show how MonadTransformers can be used to specify the formal semantics of Aspect Oriented Programming. I have taken the example from Mark P. Jones paper
&lt;a href="https://pdfs.semanticscholar.org/c4ce/14364d88d533fac6aa53481b719aa661ce73.pdf" rel="nofollow"&gt;The Essence of AspectJ&lt;/a&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-an-interpreter-for-minipascal" class="anchor" aria-hidden="true" href="#an-interpreter-for-minipascal"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;An interpreter for MiniPascal&lt;/h4&gt;
&lt;p&gt;We start by defining a simple imperative language – MiniPascal:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; an identifier type&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Integer expressions&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:+:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:*:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:-:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:/:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Boolean expressions&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;T&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;F&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;Not&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;BExp&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;amp;:&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;BExp&lt;/span&gt; &lt;span class="pl-k"&gt;:|:&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:=:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;lt;:&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Staments&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Skip&lt;/span&gt;        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; no op&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt;        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; variable assignment&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;Begin&lt;/span&gt; [&lt;span class="pl-en"&gt;Stmt&lt;/span&gt;]      &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a sequence of statements&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;If&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; an if statement&lt;/span&gt;
    | &lt;span class="pl-ent"&gt;While&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt;   &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a while loop&lt;/span&gt;
    &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this igredients its possible to write imperative programs like the following &lt;code&gt;while&lt;/code&gt; loop that sums up the natural numbers from 1 to 10:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; an example program: the MiniPascal equivalent of `sum [1..10]`&lt;/span&gt;
&lt;span class="pl-en"&gt;program&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt;
program &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-ent"&gt;Begin&lt;/span&gt; [
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;,
        &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;,
        &lt;span class="pl-ent"&gt;While&lt;/span&gt; (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;lt;:&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt;)
            (&lt;span class="pl-ent"&gt;Begin&lt;/span&gt; [
                &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:+:&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;),
                &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:+:&lt;/span&gt; &lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
            ])
    ]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We define the semantics of this language with an interpreter:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; the store used for variable assignments&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; evaluate numeric expression.&lt;/span&gt;
&lt;span class="pl-en"&gt;iexp&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
iexp (&lt;span class="pl-ent"&gt;Lit&lt;/span&gt; n) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; n
iexp (e1 &lt;span class="pl-k"&gt;:+:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(+)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:*:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(*)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:-:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(-)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:/:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-c1"&gt;div&lt;/span&gt; (iexp e1) (iexp e2)
iexp (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; i)    &lt;span class="pl-k"&gt;=&lt;/span&gt; getVar i

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; evaluate logic expressions&lt;/span&gt;
&lt;span class="pl-en"&gt;bexp&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;BExp&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;
bexp &lt;span class="pl-ent"&gt;T&lt;/span&gt;           &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
bexp &lt;span class="pl-ent"&gt;F&lt;/span&gt;           &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;False&lt;/span&gt;&lt;/span&gt;
bexp (&lt;span class="pl-ent"&gt;Not&lt;/span&gt; b)     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; &lt;span class="pl-c1"&gt;not&lt;/span&gt; (bexp b)
bexp (b1 &lt;span class="pl-k"&gt;:&amp;amp;:&lt;/span&gt; b2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(&amp;amp;&amp;amp;)&lt;/span&gt; (bexp b1) (bexp b2)
bexp (b1 &lt;span class="pl-k"&gt;:|:&lt;/span&gt; b2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(||)&lt;/span&gt; (bexp b1) (bexp b2)
bexp (e1 &lt;span class="pl-k"&gt;:=:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(==)&lt;/span&gt; (iexp e1) (iexp e2)
bexp (e1 &lt;span class="pl-k"&gt;:&amp;lt;:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(&amp;lt;)&lt;/span&gt;  (iexp e1) (iexp e2)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; evaluate statements&lt;/span&gt;
&lt;span class="pl-en"&gt;stmt&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
stmt &lt;span class="pl-ent"&gt;Skip&lt;/span&gt;       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
stmt (i &lt;span class="pl-k"&gt;:=&lt;/span&gt; e)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; iexp e; setVar i x
stmt (&lt;span class="pl-ent"&gt;Begin&lt;/span&gt; ss) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;mapM_&lt;/span&gt; stmt ss
stmt (&lt;span class="pl-ent"&gt;If&lt;/span&gt; b t e) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; bexp b
    &lt;span class="pl-k"&gt;if&lt;/span&gt; x &lt;span class="pl-k"&gt;then&lt;/span&gt; stmt t
         &lt;span class="pl-k"&gt;else&lt;/span&gt; stmt e
stmt (&lt;span class="pl-ent"&gt;While&lt;/span&gt; b t) &lt;span class="pl-k"&gt;=&lt;/span&gt; loop
    &lt;span class="pl-k"&gt;where&lt;/span&gt; loop &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
            x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; bexp b
            when x &lt;span class="pl-k"&gt;$&lt;/span&gt; stmt t &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; loop

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a variable assignments updates the store (which is maintained in the state)&lt;/span&gt;
&lt;span class="pl-en"&gt;setVar&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;MonadState&lt;/span&gt; (&lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-smi"&gt;m&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
setVar i x &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    store &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; get
    put (&lt;span class="pl-c1"&gt;Map.&lt;/span&gt;insert i x store)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; lookup a variable in the store. return 0 if no value is found&lt;/span&gt;
&lt;span class="pl-en"&gt;getVar&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
getVar i &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    s &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; get
    &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;&lt;span class="pl-c1"&gt;lookup&lt;/span&gt; i s &lt;span class="pl-k"&gt;of&lt;/span&gt;
        &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;
        (&lt;span class="pl-ent"&gt;Just&lt;/span&gt; v) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; v

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; evaluate a statement&lt;/span&gt;
&lt;span class="pl-en"&gt;run&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt;
run s &lt;span class="pl-k"&gt;=&lt;/span&gt; execState (stmt s) (&lt;span class="pl-c1"&gt;Map.&lt;/span&gt;fromList &lt;span class="pl-c1"&gt;[]&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run program
fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;55&lt;/span&gt;)]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far this is nothing special, just a minimal interpreter for an imperative language. Side effects in form of variable assignments are modelled with an environment that is maintained in a state monad.&lt;/p&gt;
&lt;p&gt;In the next step we want to extend this language with features of aspect oriented programming in the style of &lt;em&gt;AspectJ&lt;/em&gt;: join points, point cuts, and advices.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-an-interpreter-for-aspectpascal" class="anchor" aria-hidden="true" href="#an-interpreter-for-aspectpascal"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;An Interpreter for AspectPascal&lt;/h4&gt;
&lt;p&gt;To keep things simple we will specify only two types of joint points: variable assignment and variable reading:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;JoinPointDesc&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Get&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; | &lt;span class="pl-ent"&gt;Set&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Get i&lt;/code&gt; describes a join point at which the variable &lt;code&gt;i&lt;/code&gt; is read, while &lt;code&gt;Set i&lt;/code&gt; described a join point at which
a value is assigned to the variable &lt;code&gt;i&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Following the concepts of ApectJ pointcut expressions are used to describe sets of join points.
The abstract syntax for pointcuts is as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Setter&lt;/span&gt;                  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the pointcut of all join points at which a variable is being set&lt;/span&gt;
              | &lt;span class="pl-ent"&gt;Getter&lt;/span&gt;                  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the pointcut of all join points at which a variable is being read&lt;/span&gt;
              | &lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt;                &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the point cut of all join points at which a the variable is being set or read&lt;/span&gt;
              | &lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt;          &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; not a&lt;/span&gt;
              | &lt;span class="pl-ent"&gt;PointCut&lt;/span&gt; &lt;span class="pl-k"&gt;:||:&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a or b&lt;/span&gt;
              | &lt;span class="pl-ent"&gt;PointCut&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a and b&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example this syntax can be used to specify the pointcut of
all join points at which the variable &lt;code&gt;x&lt;/code&gt; is set:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;(&lt;span class="pl-ent"&gt;Setter&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;x&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The following function computes whether a &lt;code&gt;PointCut&lt;/code&gt; contains a given &lt;code&gt;JoinPoint&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;includes&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;JoinPointDesc&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;)
includes &lt;span class="pl-ent"&gt;Setter&lt;/span&gt;     (&lt;span class="pl-ent"&gt;Set&lt;/span&gt; i) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
includes &lt;span class="pl-ent"&gt;Getter&lt;/span&gt;     (&lt;span class="pl-ent"&gt;Get&lt;/span&gt; i) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
includes (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; i)  (&lt;span class="pl-ent"&gt;Get&lt;/span&gt; j) &lt;span class="pl-k"&gt;=&lt;/span&gt; i &lt;span class="pl-k"&gt;==&lt;/span&gt; j
includes (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; i)  (&lt;span class="pl-ent"&gt;Set&lt;/span&gt; j) &lt;span class="pl-k"&gt;=&lt;/span&gt; i &lt;span class="pl-k"&gt;==&lt;/span&gt; j
includes (&lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; p)  d       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;not&lt;/span&gt; (includes p d)
includes (p &lt;span class="pl-k"&gt;:||:&lt;/span&gt; q) d       &lt;span class="pl-k"&gt;=&lt;/span&gt; includes p d &lt;span class="pl-k"&gt;||&lt;/span&gt; includes q d
includes (p &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; q) d       &lt;span class="pl-k"&gt;=&lt;/span&gt; includes p d &lt;span class="pl-k"&gt;&amp;amp;&amp;amp;&lt;/span&gt; includes q d
includes _ _                &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In AspectJ aspect oriented extensions to a program are described using the notion of advices.
We follow the same design here: each advice includes a pointcut to specify the join points at which the
advice should be used, and a statement (in MiniPascal syntax) to specify the action that should be performed at each matching join point.&lt;/p&gt;
&lt;p&gt;In AspectPascal we only support two kinds of advice: &lt;code&gt;Before&lt;/code&gt;, which will be executed on entry to a join point, and
&lt;code&gt;After&lt;/code&gt; which will be executed on the exit from a join point:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Advice&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Before&lt;/span&gt; &lt;span class="pl-en"&gt;PointCut&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt;
            | &lt;span class="pl-ent"&gt;After&lt;/span&gt;  &lt;span class="pl-en"&gt;PointCut&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This allows to define &lt;code&gt;Advice&lt;/code&gt;s like the following:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the countSets Advice traces each setting of a variable and increments the counter "countSet"&lt;/span&gt;
countSets &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;After&lt;/span&gt; (&lt;span class="pl-ent"&gt;Setter&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countGet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))
                  (&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:+:&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;))

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the countGets Advice traces each lookup of a variable and increments the counter "countGet"&lt;/span&gt;
countGets &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;After&lt;/span&gt; (&lt;span class="pl-ent"&gt;Getter&lt;/span&gt; &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;:&amp;amp;&amp;amp;:&lt;/span&gt; &lt;span class="pl-ent"&gt;NotAt&lt;/span&gt; (&lt;span class="pl-ent"&gt;AtVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countGet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))
                  (&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countGet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countGet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:+:&lt;/span&gt; &lt;span class="pl-ent"&gt;Lit&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The rather laborious PointCut definition is used to select access to all variable apart from &lt;code&gt;countGet&lt;/code&gt; and &lt;code&gt;countSet&lt;/code&gt;.
This is required as the action part of the &lt;code&gt;Advices&lt;/code&gt; are normal MiniPascal statements that are executed by the same interpreter as the main program which is to be extended by advices. If those filters were not present execution of those advices would result in non-terminating loops, as the action statements also access variables.&lt;/p&gt;
&lt;p&gt;A complete AspectPascal program will now consist of a &lt;code&gt;stmt&lt;/code&gt; (the original program) plus a list of &lt;code&gt;advices&lt;/code&gt; that should be executed to implement the cross-cutting aspects:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Aspects are just a list of Advices&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [&lt;span class="pl-en"&gt;Advice&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to extend our interpreter to execute additional behaviour decribed in &lt;code&gt;advices&lt;/code&gt; we will have to provide all evaluating functions with access to the &lt;code&gt;Aspects&lt;/code&gt;.
As the &lt;code&gt;Aspects&lt;/code&gt; will not be modified at runtime the typical solution would be to provide them by a &lt;code&gt;Reader Aspects&lt;/code&gt; monad.
We already have learnt that we can use a MonadTransformer to stack our existing &lt;code&gt;State&lt;/code&gt; monad with a &lt;code&gt;Reader&lt;/code&gt; monad. The respective Transformer is &lt;code&gt;ReaderT&lt;/code&gt;.
We thus extend the signature of the evaluation functions accordingly, eg:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; from:&lt;/span&gt;
&lt;span class="pl-en"&gt;iexp&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; to:&lt;/span&gt;
&lt;span class="pl-en"&gt;iexp&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ReaderT&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Apart from extendig the signatures we have to modify all places where variables are accessed to apply the matching advices.
So for instance in the equation for &lt;code&gt;iexp (IVar i)&lt;/code&gt; we specify that &lt;code&gt;(getVar i)&lt;/code&gt; should be executed with applying all advices that match the read access to variable &lt;code&gt;i&lt;/code&gt; – that is &lt;code&gt;(Get i)&lt;/code&gt; by writing:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;iexp (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; i)    &lt;span class="pl-k"&gt;=&lt;/span&gt; withAdvice (&lt;span class="pl-ent"&gt;Get&lt;/span&gt; i) (getVar i)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So the complete definition of &lt;code&gt;iexp&lt;/code&gt; is:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;iexp&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;IExp&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ReaderT&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
iexp (&lt;span class="pl-ent"&gt;Lit&lt;/span&gt; n) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; n
iexp (e1 &lt;span class="pl-k"&gt;:+:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(+)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:*:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(*)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:-:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-en"&gt;(-)&lt;/span&gt; (iexp e1) (iexp e2)
iexp (e1 &lt;span class="pl-k"&gt;:/:&lt;/span&gt; e2) &lt;span class="pl-k"&gt;=&lt;/span&gt; liftM2 &lt;span class="pl-c1"&gt;div&lt;/span&gt; (iexp e1) (iexp e2)
iexp (&lt;span class="pl-ent"&gt;IVar&lt;/span&gt; i)    &lt;span class="pl-k"&gt;=&lt;/span&gt; withAdvice (&lt;span class="pl-ent"&gt;Get&lt;/span&gt; i) (getVar i)&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] if &lt;code&gt;c&lt;/code&gt; is a computation corresponding to some join point with description &lt;code&gt;d&lt;/code&gt;, then &lt;code&gt;withAdvice d c&lt;/code&gt; wraps the
execution of &lt;code&gt;c&lt;/code&gt; with the execution of the appropriate Before and After advice, if any:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withAdvice&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;JoinPointDesc&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ReaderT&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ReaderT&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
withAdvice d c &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    aspects &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; ask                &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; obtaining the Aspects from the Reader monad&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mapM_&lt;/span&gt; stmt (before d aspects) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execute the statements of all Before advices&lt;/span&gt;
    x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; c                        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execute the actual business logic&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mapM_&lt;/span&gt; stmt (after d aspects)  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execute the statements of all After advices&lt;/span&gt;
    &lt;span class="pl-c1"&gt;return&lt;/span&gt; x

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; collect the statements of Before and After advices matching the join point&lt;/span&gt;
&lt;span class="pl-en"&gt;before&lt;/span&gt;, &lt;span class="pl-en"&gt;after&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;JoinPointDesc&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-en"&gt;Stmt&lt;/span&gt;]
before d as &lt;span class="pl-k"&gt;=&lt;/span&gt; [s &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-ent"&gt;Before&lt;/span&gt; c s &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; as, includes c d]
after  d as &lt;span class="pl-k"&gt;=&lt;/span&gt; [s &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-ent"&gt;After&lt;/span&gt;  c s &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; as, includes c d]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the same way the equation for variable assignment &lt;code&gt;stmt (i := e)&lt;/code&gt; we specify that &lt;code&gt;(setVar i x)&lt;/code&gt; should be executed with applying all advices that match the write access to variable &lt;code&gt;i&lt;/code&gt; – that is &lt;code&gt;(Set i)&lt;/code&gt; by noting:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;stmt (i &lt;span class="pl-k"&gt;:=&lt;/span&gt; e)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; iexp e; withAdvice (&lt;span class="pl-ent"&gt;Set&lt;/span&gt; i) (setVar i x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The complete implementation for &lt;code&gt;stmt&lt;/code&gt; then looks like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;stmt&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MonadState&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ReaderT&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
stmt &lt;span class="pl-ent"&gt;Skip&lt;/span&gt;       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
stmt (i &lt;span class="pl-k"&gt;:=&lt;/span&gt; e)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; iexp e; withAdvice (&lt;span class="pl-ent"&gt;Set&lt;/span&gt; i) (setVar i x)
stmt (&lt;span class="pl-ent"&gt;Begin&lt;/span&gt; ss) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;mapM_&lt;/span&gt; stmt ss
stmt (&lt;span class="pl-ent"&gt;If&lt;/span&gt; b t e) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; bexp b
    &lt;span class="pl-k"&gt;if&lt;/span&gt; x &lt;span class="pl-k"&gt;then&lt;/span&gt; stmt t
         &lt;span class="pl-k"&gt;else&lt;/span&gt; stmt e
stmt (&lt;span class="pl-ent"&gt;While&lt;/span&gt; b t) &lt;span class="pl-k"&gt;=&lt;/span&gt; loop
    &lt;span class="pl-k"&gt;where&lt;/span&gt; loop &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
            x &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; bexp b
            when x &lt;span class="pl-k"&gt;$&lt;/span&gt; stmt t &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; loop&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally we have to extend &lt;code&gt;run&lt;/code&gt; function to properly handle the monad stack:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;run&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Aspects&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Stmt&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Store&lt;/span&gt;
run a s &lt;span class="pl-k"&gt;=&lt;/span&gt; execState (runReaderT (stmt s) a) (&lt;span class="pl-c1"&gt;Map.&lt;/span&gt;fromList &lt;span class="pl-c1"&gt;[]&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run &lt;span class="pl-c1"&gt;[]&lt;/span&gt; program
fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;55&lt;/span&gt;)]

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run [countSets] program
fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;22&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;55&lt;/span&gt;)]

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run [countSets, countGets] program
fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;count&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countGet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;41&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;countSet&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;22&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;total&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;55&lt;/span&gt;)]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So executing the program with an empty list of advices yields the same result as executing the program with initial interpreter. Once we execute the program with the advices &lt;code&gt;countGets&lt;/code&gt; and &lt;code&gt;countSets&lt;/code&gt; the resulting map contains values for the variables &lt;code&gt;countGet&lt;/code&gt; and &lt;code&gt;countSet&lt;/code&gt; which have been incremented by the statements of both advices.&lt;/p&gt;
&lt;p&gt;We have utilized Monad Transformers to extend our original interpreter in a minamally invasive way, to provide a formal and executable semantics for a simple aspect-oriented language in the style of AspectJ.&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-composite--semigroup--monoid" class="anchor" aria-hidden="true" href="#composite--semigroup--monoid"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Composite → SemiGroup → Monoid&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, the composite pattern is a partitioning design pattern. The composite pattern describes a group of objects that is treated the same way as a single instance of the same type of object. The intent of a composite is to "compose" objects into tree structures to represent part-whole hierarchies. Implementing the composite pattern lets clients treat individual objects and compositions uniformly.
(Quoted from &lt;a href="https://en.wikipedia.org/wiki/Composite_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A typical example for the composite pattern is the hierarchical grouping of test cases to TestSuites in a testing framework. Take for instance the following class diagram from the &lt;a href="http://junit.sourceforge.net/doc/cookstour/cookstour.htm" rel="nofollow"&gt;JUnit cooks tour&lt;/a&gt; which shows how JUnit applies the Composite pattern to group &lt;code&gt;TestCases&lt;/code&gt; to &lt;code&gt;TestSuites&lt;/code&gt; while both of them implement the &lt;code&gt;Test&lt;/code&gt; interface:&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/8dbb90ac5365e950324889aefa6a76346a9ab3ca/687474703a2f2f6a756e69742e736f75726365666f7267652e6e65742f646f632f636f6f6b73746f75722f496d616765352e676966"&gt;&lt;img src="https://camo.githubusercontent.com/8dbb90ac5365e950324889aefa6a76346a9ab3ca/687474703a2f2f6a756e69742e736f75726365666f7267652e6e65742f646f632f636f6f6b73746f75722f496d616765352e676966" alt="Composite Pattern used in Junit" data-canonical-src="http://junit.sourceforge.net/doc/cookstour/Image5.gif" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In Haskell we could model this kind of hierachy with an algebraic data type (ADT):&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the composite data structure: a Test can be either a single TestCase&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; or a TestSuite holding a list of Tests&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; &lt;span class="pl-en"&gt;TestCase&lt;/span&gt;
          | &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; [&lt;span class="pl-en"&gt;Test&lt;/span&gt;]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a test case produces a boolean when executed&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;TestCase&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function &lt;code&gt;run&lt;/code&gt; as defined below can either execute a single TestCase or a composite TestSuite:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execution of a Test.&lt;/span&gt;
&lt;span class="pl-en"&gt;run&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;
run (&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; t)  &lt;span class="pl-k"&gt;=&lt;/span&gt; t &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; evaluating the TestCase by applying t to ()&lt;/span&gt;
run (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;all&lt;/span&gt; (&lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;==&lt;/span&gt;) (&lt;span class="pl-c1"&gt;map&lt;/span&gt; run l) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; running all tests in l and return True if all tests pass&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a few most simple test cases&lt;/span&gt;
&lt;span class="pl-en"&gt;t1&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt;
t1 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;&lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;)
&lt;span class="pl-en"&gt;t2&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt;
t2 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;&lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;)
&lt;span class="pl-en"&gt;t3&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt;
t3 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;&lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;False&lt;/span&gt;&lt;/span&gt;)
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; collecting all test cases in a TestSuite&lt;/span&gt;
ts &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; [t1,t2,t3]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As run is of type &lt;code&gt;run :: Test -&amp;gt; Bool&lt;/code&gt; we can use it to execute single &lt;code&gt;TestCases&lt;/code&gt; or complete &lt;code&gt;TestSuites&lt;/code&gt;.
Let's try it in GHCI:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run t1
&lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; run ts
&lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to aggregate TestComponents we follow the design of JUnit and define a function &lt;code&gt;addTest&lt;/code&gt;. Adding two atomic Tests will result in a TestSuite holding a list with the two Tests. If a Test is added to a TestSuite, the test is added to the list of tests of the suite. Adding TestSuites will merge them.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; adding Tests&lt;/span&gt;
&lt;span class="pl-en"&gt;addTest&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt;
addTest t1&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _) t2&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; [t1,t2]
addTest t1&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _) (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; list)  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; ([t1] &lt;span class="pl-k"&gt;++&lt;/span&gt; list)
addTest (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; list) t2&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _)  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; (list &lt;span class="pl-k"&gt;++&lt;/span&gt; [t2])
addTest (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l1) (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l2)     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; (l1 &lt;span class="pl-k"&gt;++&lt;/span&gt; l2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If we take a closer look at &lt;code&gt;addTest&lt;/code&gt; we will see that it is a associative binary operation on the set of &lt;code&gt;Test&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;In mathemathics a set with an associative binary operation is a &lt;a href="https://en.wikipedia.org/wiki/Semigroup" rel="nofollow"&gt;Semigroup&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can thus make our type &lt;code&gt;Test&lt;/code&gt; an instance of the type class &lt;code&gt;Semigroup&lt;/code&gt; with the following declaration:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;(&amp;lt;&amp;gt;)&lt;/span&gt;   &lt;span class="pl-k"&gt;=&lt;/span&gt; addTest&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What's not visible from the JUnit class diagram is how typical object oriented implementations will have to deal with null-references. That is the implementations would have to make sure that the methods &lt;code&gt;run&lt;/code&gt; and &lt;code&gt;addTest&lt;/code&gt; will handle empty references correctly.
With Haskells algebraic data types we would rather make this explicit with a dedicated &lt;code&gt;Empty&lt;/code&gt; element.
Here are the changes we have to add to our code:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the composite data structure: a Test can be Empty, a single TestCase&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; or a TestSuite holding a list of Tests&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Empty&lt;/span&gt;
          | &lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; &lt;span class="pl-en"&gt;TestCase&lt;/span&gt;
          | &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; [&lt;span class="pl-en"&gt;Test&lt;/span&gt;]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execution of a Test.&lt;/span&gt;
&lt;span class="pl-en"&gt;run&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;
run &lt;span class="pl-ent"&gt;Empty&lt;/span&gt;         &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; empty tests will pass&lt;/span&gt;
run (&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; t)  &lt;span class="pl-k"&gt;=&lt;/span&gt; t &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; evaluating the TestCase by applying t to ()&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;run (TestSuite l) = foldr ((&amp;amp;&amp;amp;) . run) True l&lt;/span&gt;
run (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;all&lt;/span&gt; (&lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;==&lt;/span&gt;) (&lt;span class="pl-c1"&gt;map&lt;/span&gt; run l) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; running all tests in l and return True if all tests pass&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; addTesting Tests&lt;/span&gt;
&lt;span class="pl-en"&gt;addTest&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt;
addTest &lt;span class="pl-ent"&gt;Empty&lt;/span&gt; t                           &lt;span class="pl-k"&gt;=&lt;/span&gt; t
addTest t &lt;span class="pl-ent"&gt;Empty&lt;/span&gt;                           &lt;span class="pl-k"&gt;=&lt;/span&gt; t
addTest t1&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _) t2&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; [t1,t2]
addTest t1&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _) (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; list)  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; ([t1] &lt;span class="pl-k"&gt;++&lt;/span&gt; list)
addTest (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; list) t2&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;TestCase&lt;/span&gt; _)  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; (list &lt;span class="pl-k"&gt;++&lt;/span&gt; [t2])
addTest (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l1) (&lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; l2)     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;TestSuite&lt;/span&gt; (l1 &lt;span class="pl-k"&gt;++&lt;/span&gt; l2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From our additions it's obvious that &lt;code&gt;Empty&lt;/code&gt; is the identity element of the &lt;code&gt;addTest&lt;/code&gt; function. In Algebra a Semigroup with an identity element is called &lt;em&gt;Monoid&lt;/em&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In abstract algebra, [...] a monoid is an algebraic structure with a single associative binary operation and an identity element.
&lt;a href="https://en.wikipedia.org/wiki/Monoid" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;With haskell we can declare &lt;code&gt;Test&lt;/code&gt; as an instance of the &lt;code&gt;Monoid&lt;/code&gt; type class by defining:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Test&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mempty&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Empty&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now use all functions provided by the &lt;code&gt;Monoid&lt;/code&gt; type class to work with our &lt;code&gt;Test&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;compositeDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run &lt;span class="pl-k"&gt;$&lt;/span&gt; t1 &lt;span class="pl-k"&gt;&amp;lt;&amp;gt;&lt;/span&gt; t2
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run &lt;span class="pl-k"&gt;$&lt;/span&gt; t1 &lt;span class="pl-k"&gt;&amp;lt;&amp;gt;&lt;/span&gt; t2 &lt;span class="pl-k"&gt;&amp;lt;&amp;gt;&lt;/span&gt; t3&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can also use the function &lt;code&gt;mconcat :: Monoid a =&amp;gt; [a] -&amp;gt; a&lt;/code&gt; on a list of &lt;code&gt;Tests&lt;/code&gt;: mconcat composes a list of Tests into a single Test. That's exactly the mechanism of forming a TestSuite from atomic TestCases.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;compositeDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; [t1,t2]
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; [t1,t2,t3]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This particular feature of &lt;code&gt;mconcat :: Monoid a =&amp;gt; [a] -&amp;gt; a&lt;/code&gt; to condense a list of Monoids to a single Monoid can be used to drastically simplify the design of our test framework.&lt;/p&gt;
&lt;p&gt;We need just one more hint from our mathematician friends:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Functions are monoids if they return monoids
&lt;a href="http://blog.ploeh.dk/2018/05/17/composite-as-a-monoid-a-business-rules-example/" rel="nofollow"&gt;Quoted from blog.ploeh.dk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Currently our &lt;code&gt;TestCases&lt;/code&gt; are defined as functions yielding boolean values:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;TestCase&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If &lt;code&gt;Bool&lt;/code&gt; was a &lt;code&gt;Monoid&lt;/code&gt; we could use &lt;code&gt;mconcat&lt;/code&gt; to form test suite aggregates. &lt;code&gt;Bool&lt;/code&gt; in itself is not a Monoid; but together with a binary associative operation like &lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt; or &lt;code&gt;(||)&lt;/code&gt; it will form a Monoid.&lt;/p&gt;
&lt;p&gt;The intuitive semantics of a TestSuite is that a whole Suite is "green" only when all enclosed TestCases succeed. That is the conjunction of all TestCases must return &lt;code&gt;True&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So we are looking for the Monoid of boolean values under conjunction &lt;code&gt;(&amp;amp;&amp;amp;)&lt;/code&gt;. In Haskell this Monoid is called &lt;code&gt;All&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Boolean monoid under conjunction ('&amp;amp;&amp;amp;').&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; getAll (All True &amp;lt;&amp;gt; mempty &amp;lt;&amp;gt; All False)&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; False&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &amp;gt;&amp;gt;&amp;gt; getAll (mconcat (map (\x -&amp;gt; All (even x)) [2,4,6,7,8]))&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; False&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;All&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;All&lt;/span&gt; &lt;span class="pl-k"&gt;{&lt;/span&gt; &lt;span class="pl-e"&gt;getAll&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;}&lt;/span&gt;

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-en"&gt;All&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
        &lt;span class="pl-en"&gt;(&amp;lt;&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; coerce &lt;span class="pl-en"&gt;(&amp;amp;&amp;amp;)&lt;/span&gt;

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;All&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
        &lt;span class="pl-c1"&gt;mempty&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;All&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Making use of &lt;code&gt;All&lt;/code&gt; our improved definition of TestCases is as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;SmartTestCase&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;All&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now our test cases do not directly return a boolean value but an &lt;code&gt;All&lt;/code&gt; wrapper, which allows automatic conjunction of test results to a single value.
Here are our redefined TestCases:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;tc1&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;SmartTestCase&lt;/span&gt;
tc1 &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;All&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-en"&gt;tc2&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;SmartTestCase&lt;/span&gt;
tc2 &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;All&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-en"&gt;tc3&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;SmartTestCase&lt;/span&gt;
tc3 &lt;span class="pl-c1"&gt;()&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;All&lt;/span&gt; &lt;span class="pl-ent"&gt;&lt;span class="pl-c1"&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We now implement a new evaluation function &lt;code&gt;run'&lt;/code&gt; which evaluates a &lt;code&gt;SmartTestCase&lt;/code&gt; (which may be either an atomic TestCase or a TestSuite assembled by &lt;code&gt;mconcat&lt;/code&gt;) to a single boolean result.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;run'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;SmartTestCase&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;
run' tc &lt;span class="pl-k"&gt;=&lt;/span&gt; getAll &lt;span class="pl-k"&gt;$&lt;/span&gt; tc &lt;span class="pl-c1"&gt;()&lt;/span&gt;  &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This version of &lt;code&gt;run&lt;/code&gt; is much simpler than the original and we can completely avoid the rather laborious &lt;code&gt;addTest&lt;/code&gt; function. We also don't need any composite type &lt;code&gt;Test&lt;/code&gt;.
By just sticking to the Haskell built-in type classes we achieve cleanly designed functionality with just a few lines of code.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;compositeDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execute a single test case&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run' tc1

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;- execute a complex test suite&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run' &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; [tc1,tc2]
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; run' &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; [tc1,tc2,tc3]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more details on Composite as a Monoid please refer to the following blog:
&lt;a href="http://blog.ploeh.dk/2018/03/12/composite-as-a-monoid/" rel="nofollow"&gt;Composite as Monoid&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Composite.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-visitor--foldable" class="anchor" aria-hidden="true" href="#visitor--foldable"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Visitor → Foldable&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] the visitor design pattern is a way of separating an algorithm from an object structure on which it operates. A practical result of this separation is the ability to add new operations to existent object structures without modifying the structures. It is one way to follow the open/closed principle.
(Quoted from &lt;a href="https://en.wikipedia.org/wiki/Visitor_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In functional languages - and Haskell in particular - we have a whole armada of tools serving this purpose:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;higher order functions like map, fold, filter and all their variants allow to "visit" lists&lt;/li&gt;
&lt;li&gt;The Haskell type classes &lt;code&gt;Functor&lt;/code&gt;, &lt;code&gt;Foldable&lt;/code&gt;, &lt;code&gt;Traversable&lt;/code&gt;, etc. provide a generic framework to allow visiting any algebraic datatype by just deriving one of these type classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a id="user-content-using-foldable" class="anchor" aria-hidden="true" href="#using-foldable"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using Foldable&lt;/h4&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; we are re-using the Exp data type from the Singleton example&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and transform it into a Foldable type:&lt;/span&gt;
&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Foldable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; x)   &lt;span class="pl-k"&gt;=&lt;/span&gt; f x
    &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; x y) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f x &lt;span class="pl-k"&gt;`mappend`&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f y
    &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; x y) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f x &lt;span class="pl-k"&gt;`mappend`&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f y

&lt;span class="pl-en"&gt;filterF&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Foldable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
filterF p &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;a &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; p a &lt;span class="pl-k"&gt;then&lt;/span&gt; [a] &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;)

visitorDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-c1"&gt;exp&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;3&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;))
                  (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;6&lt;/span&gt;))
    &lt;span class="pl-c1"&gt;putStr&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;size of exp: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-c1"&gt;exp&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;filter even numbers from tree&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; filterF &lt;span class="pl-c1"&gt;even&lt;/span&gt; &lt;span class="pl-c1"&gt;exp&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By virtue of the instance declaration Exp becomes a Foldable instance an can be used with arbitrary functions defined on Foldable like &lt;code&gt;length&lt;/code&gt; in the example.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;foldMap&lt;/code&gt; can for example be used to write a filtering function &lt;code&gt;filterF&lt;/code&gt;that collects all elements matching a predicate into a list.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-alternative-approaches" class="anchor" aria-hidden="true" href="#alternative-approaches"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Alternative approaches&lt;/h5&gt;
&lt;p&gt;&lt;a href="http://blog.ploeh.dk/2018/06/25/visitor-as-a-sum-type/" rel="nofollow"&gt;Visitory as Sum type&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Visitor.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-iterator--traversable" class="anchor" aria-hidden="true" href="#iterator--traversable"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Iterator → Traversable&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] the iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples algorithms from containers; in some cases, algorithms are necessarily container-specific and thus cannot be decoupled.
&lt;a href="https://en.wikipedia.org/wiki/Iterator_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a id="user-content-iterating-over-a-tree" class="anchor" aria-hidden="true" href="#iterating-over-a-tree"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Iterating over a Tree&lt;/h4&gt;
&lt;p&gt;The most generic type class enabling iteration over algebraic data types is &lt;code&gt;Traversable&lt;/code&gt; as it allows combinations of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;fold&lt;/code&gt; operations.
We are re-using the &lt;code&gt;Exp&lt;/code&gt; type from earlier examples to show what's needed for enabling iteration in functional languages.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Var&lt;/span&gt; x
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; a)       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; f a
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; x y)     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Add&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f x) (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f y)
    &lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; x y)     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f x) (&lt;span class="pl-c1"&gt;fmap&lt;/span&gt; f y)

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Traversable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Exp&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; x)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pure&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Var&lt;/span&gt; x
    &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; x)   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; g x
    &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; x y) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Add&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g x &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g y
    &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; x y) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;$&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g x &lt;span class="pl-k"&gt;&amp;lt;*&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; g y&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this declaration we can traverse an &lt;code&gt;Exp&lt;/code&gt; tree:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;iteratorDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Iterator -&amp;gt; Traversable&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; &lt;span class="pl-c1"&gt;exp&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Add&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;3&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;))
                (&lt;span class="pl-ent"&gt;Mul&lt;/span&gt; (&lt;span class="pl-ent"&gt;Val&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;) (&lt;span class="pl-ent"&gt;Var&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;))
        env &lt;span class="pl-k"&gt;=&lt;/span&gt; [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-c1"&gt;pi&lt;/span&gt;)]
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;x c &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; &lt;span class="pl-c1"&gt;even&lt;/span&gt; x &lt;span class="pl-k"&gt;then&lt;/span&gt; [x] &lt;span class="pl-k"&gt;else&lt;/span&gt; [&lt;span class="pl-c1"&gt;2&lt;/span&gt;&lt;span class="pl-k"&gt;*&lt;/span&gt;x]) &lt;span class="pl-c1"&gt;exp&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example we are touching all (nested) &lt;code&gt;Val&lt;/code&gt; elements and multiply all odd values by 2.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-combining-traversal-operations" class="anchor" aria-hidden="true" href="#combining-traversal-operations"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Combining traversal operations&lt;/h4&gt;
&lt;p&gt;Compared with &lt;code&gt;Foldable&lt;/code&gt; or &lt;code&gt;Functor&lt;/code&gt; the declaration of a &lt;code&gt;Traversable&lt;/code&gt; instance looks a bit intimidating. In particular the type signature of &lt;code&gt;traverse&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;traverse&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Traversable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; (&lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;looks like quite a bit of over-engineering for simple traversals as in the above example.&lt;/p&gt;
&lt;p&gt;In oder to explain the real power of the &lt;code&gt;Traversable&lt;/code&gt; type class we will look at a more sophisticated example in this section. This example was taken from the paper
&lt;a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf" rel="nofollow"&gt;The Essence of the Iterator Pattern&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The Unix utility &lt;code&gt;wc&lt;/code&gt; is a good example for a traversal operation that performs several different tasks while traversing its input:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;echo&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;counting lines, words and characters in one traversal&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;|&lt;/span&gt; wc
      1       8      54&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The output simply means that our input has 1 line, 8 words and a total of 54 characters.
Obviously an efficients implementation of &lt;code&gt;wc&lt;/code&gt; will accumulate the three counters for lines, words and characters in a single pass of the input and will not run three iterations to compute the three counters separately.&lt;/p&gt;
&lt;p&gt;Here is a Java implementation:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;int&lt;/span&gt;[] wordCount(&lt;span class="pl-smi"&gt;String&lt;/span&gt; str) {
    &lt;span class="pl-k"&gt;int&lt;/span&gt; nl&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;0&lt;/span&gt;, nw&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;0&lt;/span&gt;, nc&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;0&lt;/span&gt;;         &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; number of lines, number of words, number of characters&lt;/span&gt;
    &lt;span class="pl-k"&gt;boolean&lt;/span&gt; readingWord &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;false&lt;/span&gt;;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; state information for "parsing" words&lt;/span&gt;
    &lt;span class="pl-k"&gt;for&lt;/span&gt; (&lt;span class="pl-smi"&gt;Character&lt;/span&gt; c &lt;span class="pl-k"&gt;:&lt;/span&gt; asList(str)) {
        nc&lt;span class="pl-k"&gt;++&lt;/span&gt;;                     &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; count just any character&lt;/span&gt;
        &lt;span class="pl-k"&gt;if&lt;/span&gt; (c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;) {
            nl&lt;span class="pl-k"&gt;++&lt;/span&gt;;                 &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; count only newlines&lt;/span&gt;
        }
        &lt;span class="pl-k"&gt;if&lt;/span&gt; (c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt; &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;||&lt;/span&gt; c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;||&lt;/span&gt; c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\t&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;) {
            readingWord &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;false&lt;/span&gt;;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; when detecting white space, signal end of word&lt;/span&gt;
        } &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; (readingWord &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-c1"&gt;false&lt;/span&gt;) {
            readingWord &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;true&lt;/span&gt;;   &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; when switching from white space to characters, signal new word&lt;/span&gt;
            nw&lt;span class="pl-k"&gt;++&lt;/span&gt;;                 &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; increase the word counter only once while in a word&lt;/span&gt;
        }
    }
    &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;int&lt;/span&gt;[]{nl,nw,nc};
}

&lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;List&amp;lt;&lt;span class="pl-smi"&gt;Character&lt;/span&gt;&amp;gt;&lt;/span&gt; asList(&lt;span class="pl-smi"&gt;String&lt;/span&gt; str) {
    &lt;span class="pl-k"&gt;return&lt;/span&gt; str&lt;span class="pl-k"&gt;.&lt;/span&gt;chars()&lt;span class="pl-k"&gt;.&lt;/span&gt;mapToObj(c &lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-k"&gt;char&lt;/span&gt;) c)&lt;span class="pl-k"&gt;.&lt;/span&gt;collect(&lt;span class="pl-smi"&gt;Collectors&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;toList());
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Please note that the &lt;code&gt;for (Character c : asList(str)) {...}&lt;/code&gt; notation is just syntactic sugar for&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;for&lt;/span&gt; (&lt;span class="pl-k"&gt;Iterator&amp;lt;&lt;span class="pl-smi"&gt;Character&lt;/span&gt;&amp;gt;&lt;/span&gt; iter &lt;span class="pl-k"&gt;=&lt;/span&gt; asList(str)&lt;span class="pl-k"&gt;.&lt;/span&gt;iterator(); iter&lt;span class="pl-k"&gt;.&lt;/span&gt;hasNext();) {
    &lt;span class="pl-smi"&gt;Character&lt;/span&gt; c &lt;span class="pl-k"&gt;=&lt;/span&gt; iter&lt;span class="pl-k"&gt;.&lt;/span&gt;next();
    &lt;span class="pl-c1"&gt;...&lt;/span&gt;
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For efficiency reasons this solution may be okay, but from a design perspective the solution lacks clarity as the required logic for accumulating the three counters is heavily entangled within one code block. Just imagine how the complexity of the for-loop will increase once we have to add new features like counting bytes, counting white space or counting maximum line width.&lt;/p&gt;
&lt;p&gt;So we would like to be able to isolate the different counting algorithms (&lt;em&gt;separation of concerns&lt;/em&gt;) and be able to combine them in a way that provides efficient one-time traversal.&lt;/p&gt;
&lt;p&gt;We start with the simple task of character counting:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;Sum&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;)

&lt;span class="pl-en"&gt;count&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
count _ &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Const&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;

&lt;span class="pl-en"&gt;cciBody&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Char&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
cciBody &lt;span class="pl-k"&gt;=&lt;/span&gt; count

&lt;span class="pl-en"&gt;cci&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
cci &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; cciBody

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in ghci:&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; cci &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Const&lt;/span&gt; (&lt;span class="pl-ent"&gt;Sum&lt;/span&gt; {getSum &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;11&lt;/span&gt;})&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For each character we just emit a &lt;code&gt;Const 1&lt;/code&gt; which are elements of type &lt;code&gt;Const (Sum Integer)&lt;/code&gt;.
As &lt;code&gt;(Sum Integer)&lt;/code&gt; is the monoid of Integers under addition, this design allows automatic summation over all collected &lt;code&gt;Const&lt;/code&gt; values.&lt;/p&gt;
&lt;p&gt;The next step of counting newlines looks similar:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; return (Sum 1) if true, else (Sum 0)&lt;/span&gt;
&lt;span class="pl-en"&gt;test&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Sum&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;
test b &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Sum&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; b &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; use the test function to emit (Sum 1) only when a newline char is detected&lt;/span&gt;
&lt;span class="pl-en"&gt;lciBody&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Char&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
lciBody c &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Const&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; test (c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; define the linecount using traverse&lt;/span&gt;
&lt;span class="pl-en"&gt;lci&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
lci &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; lciBody

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and the in ghci:&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; lci &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello &lt;span class="pl-cce"&gt;\n&lt;/span&gt; world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Const&lt;/span&gt; (&lt;span class="pl-ent"&gt;Sum&lt;/span&gt; {getSum &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;})&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's try to combine character counting and line counting.
In order to match the type declaration for &lt;code&gt;traverse&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;traverse&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Traversable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Applicative&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;f&lt;/span&gt; (&lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We had to define &lt;code&gt;cciBody&lt;/code&gt; and &lt;code&gt;lciBody&lt;/code&gt; so that their return types are &lt;code&gt;Applicative Functors&lt;/code&gt;.
The good news is that the product of two &lt;code&gt;Applicatives&lt;/code&gt; is again an &lt;code&gt;Applicative&lt;/code&gt; (the same holds true for Composition of &lt;code&gt;Applicatives&lt;/code&gt;).
With this knowledge we can now use &lt;code&gt;traverse&lt;/code&gt; to use the product of &lt;code&gt;cciBody&lt;/code&gt; and &lt;code&gt;lciBody&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-c1"&gt;Data.Functor.Product&lt;/span&gt;             &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; Product of Functors&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; define infix operator for building a Functor Product&lt;/span&gt;
&lt;span class="pl-en"&gt;(&amp;lt;#&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;n&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;n&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Product&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;n&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;)
(f &lt;span class="pl-k"&gt;&amp;lt;#&amp;gt;&lt;/span&gt; g) y &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Pair&lt;/span&gt; (f y) (g y)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; use a single traverse to apply the Product of cciBody and lciBody&lt;/span&gt;
&lt;span class="pl-en"&gt;clci&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Product&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
clci &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; (cciBody &lt;span class="pl-k"&gt;&amp;lt;#&amp;gt;&lt;/span&gt; lciBody)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in ghci:&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; clci &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello &lt;span class="pl-cce"&gt;\n&lt;/span&gt; world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Pair&lt;/span&gt; (&lt;span class="pl-ent"&gt;Const&lt;/span&gt; (&lt;span class="pl-ent"&gt;Sum&lt;/span&gt; {getSum &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;13&lt;/span&gt;})) (&lt;span class="pl-ent"&gt;Const&lt;/span&gt; (&lt;span class="pl-ent"&gt;Sum&lt;/span&gt; {getSum &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;}))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we have achieved our aim of separating line counting and character counting in separate functions while still being able to apply them in only one traversal.&lt;/p&gt;
&lt;p&gt;The only piece missing is the word counting. This is a bit tricky as we can not just increase a counter by looking at each single character but we have to take into account the status of the previously read character as well:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the previous character was non-whitespace and the current is also non-whitespace we are still reading the same word and don't increment the word count.&lt;/li&gt;
&lt;li&gt;If the previous character was non-whitespace and the current is a whitespace character the last word was ended but we don't increment the word count.&lt;/li&gt;
&lt;li&gt;If the previous character was whitespace and the current is also whitespace we are still reading whitespace between words and don't increment the word count.&lt;/li&gt;
&lt;li&gt;If the previous character was whitespace and the current is a non-whitespace character the next word has started and we increment the word count.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Keeping track of the state of the last character could be achieved by using a state monad (and wrapping it as an Applicative Functor to make it compatible with &lt;code&gt;traverse&lt;/code&gt;). The actual code for this solution is kept in the sourcecode for this section (functions &lt;code&gt;wciBody'&lt;/code&gt; and &lt;code&gt;wci'&lt;/code&gt; in particular). But as this approach is a bit noisy I'm presenting a simpler solution suggested by &lt;a href="https://www.reddit.com/r/haskell/comments/cfjnyu/type_classes_and_software_design_patterns/eub06p5?utm_source=share&amp;amp;utm_medium=web2x" rel="nofollow"&gt;Noughtmare&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In his approach we'll define a data structure that will keep track of the changes between whitespace and non-whitespace:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;SC&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;
  &lt;span class="pl-k"&gt;deriving&lt;/span&gt; &lt;span class="pl-e"&gt;Show&lt;/span&gt;

&lt;span class="pl-en"&gt;mkSepCount&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;
mkSepCount &lt;span class="pl-c1"&gt;pred&lt;/span&gt; x &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;SC&lt;/span&gt; p p (&lt;span class="pl-k"&gt;if&lt;/span&gt; p &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;)
  &lt;span class="pl-k"&gt;where&lt;/span&gt;
    p &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;pred&lt;/span&gt; x

&lt;span class="pl-en"&gt;getSepCount&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;
getSepCount (&lt;span class="pl-ent"&gt;SC&lt;/span&gt; _ _ n) &lt;span class="pl-k"&gt;=&lt;/span&gt; n    &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We then define the semantics for &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; which implements the actual bookkeeping needed when &lt;code&gt;mappend&lt;/code&gt;ing two &lt;code&gt;SepCount&lt;/code&gt; items:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
  (&lt;span class="pl-ent"&gt;SC&lt;/span&gt; l0 r0 n) &lt;span class="pl-k"&gt;&amp;lt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-ent"&gt;SC&lt;/span&gt; l1 r1 m) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;SC&lt;/span&gt; l0 r1 x &lt;span class="pl-k"&gt;where&lt;/span&gt;
    x &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;not&lt;/span&gt; r0 &lt;span class="pl-k"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="pl-c1"&gt;not&lt;/span&gt; l1 &lt;span class="pl-k"&gt;=&lt;/span&gt; n &lt;span class="pl-k"&gt;+&lt;/span&gt; m &lt;span class="pl-k"&gt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
      &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; n &lt;span class="pl-k"&gt;+&lt;/span&gt; m&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on these definitions we can then implement the wordcounting as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;wciBody&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Char&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;) &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;
wciBody &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Const&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; mkSepCount isSpace &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;isSpace&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Char&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;
    isSpace c &lt;span class="pl-k"&gt;=&lt;/span&gt; c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt; &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;||&lt;/span&gt; c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;||&lt;/span&gt; c &lt;span class="pl-k"&gt;==&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-cce"&gt;\t&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; using traverse to count words in a String&lt;/span&gt;
&lt;span class="pl-en"&gt;wci&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;) [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;]
wci &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; wciBody 

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; Forming the Product of character counting, line counting and word counting&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and performing a one go traversal using this Functor product&lt;/span&gt;
&lt;span class="pl-en"&gt;clwci&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Product&lt;/span&gt; (&lt;span class="pl-en"&gt;Product&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt; &lt;span class="pl-en"&gt;Count&lt;/span&gt;) (&lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;))) [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;]
clwci &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;traverse&lt;/span&gt; (cciBody &lt;span class="pl-k"&gt;&amp;lt;#&amp;gt;&lt;/span&gt; lciBody &lt;span class="pl-k"&gt;&amp;lt;#&amp;gt;&lt;/span&gt; wciBody)  

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; extracting the actual Integer value from a `Const (Maybe SepCount) a` expression &lt;/span&gt;
&lt;span class="pl-en"&gt;extractCount&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;) &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;
extractCount (&lt;span class="pl-ent"&gt;Const&lt;/span&gt; (&lt;span class="pl-ent"&gt;Just&lt;/span&gt; sepCount)) &lt;span class="pl-k"&gt;=&lt;/span&gt;  getSepCount sepCount  

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the actual wordcount implementation.&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; for any String a triple of linecount, wordcount, charactercount is returned&lt;/span&gt;
&lt;span class="pl-en"&gt;wc&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;)
wc str &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; raw &lt;span class="pl-k"&gt;=&lt;/span&gt; clwci str
        cc  &lt;span class="pl-k"&gt;=&lt;/span&gt; coerce &lt;span class="pl-k"&gt;$&lt;/span&gt; pfst (pfst raw)
        lc  &lt;span class="pl-k"&gt;=&lt;/span&gt; coerce &lt;span class="pl-k"&gt;$&lt;/span&gt; psnd (pfst raw)
        wc  &lt;span class="pl-k"&gt;=&lt;/span&gt; extractCount  (psnd raw)
    &lt;span class="pl-k"&gt;in&lt;/span&gt; (lc,wc,cc)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This sections was meant to motivate the usage of the &lt;code&gt;Traversable&lt;/code&gt; type. Of course the word count example could be solved in much simpler ways. Here is one solution suggested by &lt;a href="https://www.reddit.com/r/haskell/comments/cfjnyu/type_classes_and_software_design_patterns/ev4m6u6?utm_source=share&amp;amp;utm_medium=web2x" rel="nofollow"&gt;NoughtMare&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We simply use &lt;code&gt;foldMap&lt;/code&gt; to perform a map / reduce based on our already defined &lt;code&gt;cciBody&lt;/code&gt;, &lt;code&gt;lciBody&lt;/code&gt; and &lt;code&gt;wciBody&lt;/code&gt; functions. As &lt;code&gt;clwci''&lt;/code&gt; now returns a simple tuple instead of the more clumsy &lt;code&gt;Product&lt;/code&gt; type also the final wordcound function &lt;code&gt;wc''&lt;/code&gt; now looks way simpler:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;clwci''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Foldable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Char&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Count&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;], &lt;span class="pl-en"&gt;Count&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;], &lt;span class="pl-en"&gt;Const&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;SepCount&lt;/span&gt;) &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;)
clwci'' &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;x &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (cciBody x,  lciBody x, wciBody x))

&lt;span class="pl-en"&gt;wc''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;)
wc'' str &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; (rawCC, rawLC, rawWC) &lt;span class="pl-k"&gt;=&lt;/span&gt; clwci'' str
        cc  &lt;span class="pl-k"&gt;=&lt;/span&gt; coerce rawCC
        lc  &lt;span class="pl-k"&gt;=&lt;/span&gt; coerce rawLC
        wc  &lt;span class="pl-k"&gt;=&lt;/span&gt; extractCount rawWC
    &lt;span class="pl-k"&gt;in&lt;/span&gt; (lc,wc,cc)    &lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As map / reduce with &lt;code&gt;foldMap&lt;/code&gt; is such a powerful tool I've written a &lt;a href="#map-reduce"&gt;dedicated section on this topic&lt;/a&gt; further down in this study.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Iterator.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-the-pattern-behind-the-patterns--category" class="anchor" aria-hidden="true" href="#the-pattern-behind-the-patterns--category"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The Pattern behind the Patterns → Category&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;If you've ever used Unix pipes, you'll understand the importance and flexibility of composing small reusable programs to get powerful and emergent behaviors. Similarly, if you program functionally, you'll know how cool it is to compose a bunch of small reusable functions into a fully featured program.&lt;/p&gt;
&lt;p&gt;Category theory codifies this compositional style into a design pattern, the category.
&lt;a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html" rel="nofollow"&gt;Quoted from HaskellForAll&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In most of the patterns and type classes discussed so far we have seen a common theme: providing means to
compose behaviour and structure is one of the most important tools to design complex software by combining
simpler components.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-function-composition" class="anchor" aria-hidden="true" href="#function-composition"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Function Composition&lt;/h4&gt;
&lt;p&gt;Function composition is a powerful and elegant tool to compose complex functionality out of simpler building blocks. We already have seen several examples of it in the course of this study.
Functions can be composed by using the binary &lt;code&gt;(.)&lt;/code&gt; operator:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;(.)&lt;/span&gt;
&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;(.)&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is defined as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;(f &lt;span class="pl-k"&gt;.&lt;/span&gt; g) x &lt;span class="pl-k"&gt;=&lt;/span&gt; f (g x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This operator can be used to combine simple functions to awesome one-liners (and of course much more useful stuff):&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;product&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;filter&lt;/span&gt; &lt;span class="pl-c1"&gt;odd&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;reverse&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;function composition is awesome&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;77&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Function composition is associative &lt;code&gt;(f . g) . h = f . (g . h)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (((&lt;span class="pl-k"&gt;^&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;) &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt;) &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt;) &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;4&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; ((&lt;span class="pl-k"&gt;^&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;) &lt;span class="pl-k"&gt;.&lt;/span&gt; (&lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt;)) &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-c1"&gt;4&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And composition has a neutral (or identity) element &lt;code&gt;id&lt;/code&gt; so that &lt;code&gt;f . id = id . f&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;length&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;id&lt;/span&gt;) [&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;]
&lt;span class="pl-c1"&gt;3&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt;) [&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;]
&lt;span class="pl-c1"&gt;3&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The definitions of &lt;code&gt;(.)&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; plus the laws of associativity and identity match exactly the definition of a category:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In mathematics, a category [...] is a collection of "objects" that are linked by "arrows". A category has two basic properties: the ability to compose the arrows associatively and the existence of an identity arrow for each object.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Category_(mathematics)" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In Haskell a category is defined as as a type class:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;Category&lt;/span&gt; &lt;span class="pl-smi"&gt;cat&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; the identity morphism&lt;/span&gt;
    &lt;span class="pl-en"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;cat&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; morphism composition&lt;/span&gt;
    &lt;span class="pl-en"&gt;(.)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;cat&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;cat&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;cat&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Please note: The name &lt;code&gt;Category&lt;/code&gt; may be a bit misleading, since this type class cannot represent arbitrary categories, but only categories whose objects are objects of &lt;a href="https://wiki.haskell.org/Hask" rel="nofollow"&gt;&lt;code&gt;Hask&lt;/code&gt;, the category of Haskell types&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Instances of &lt;code&gt;Category&lt;/code&gt; should satisfy that &lt;code&gt;(.)&lt;/code&gt; and &lt;code&gt;id&lt;/code&gt; form a Monoid – that is &lt;code&gt;id&lt;/code&gt; should be the identity of &lt;code&gt;(.)&lt;/code&gt; and &lt;code&gt;(.)&lt;/code&gt; should be associative:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;f  &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;id&lt;/span&gt;      &lt;span class="pl-k"&gt;=&lt;/span&gt;  f            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; (right identity)&lt;/span&gt;
&lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; f       &lt;span class="pl-k"&gt;=&lt;/span&gt;  f            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; (left identity)&lt;/span&gt;
f &lt;span class="pl-k"&gt;.&lt;/span&gt; (g &lt;span class="pl-k"&gt;.&lt;/span&gt; h)  &lt;span class="pl-k"&gt;=&lt;/span&gt;  (f &lt;span class="pl-k"&gt;.&lt;/span&gt; g) &lt;span class="pl-k"&gt;.&lt;/span&gt; h  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; (associativity)&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As function composition fulfills these category laws the function type constructor &lt;code&gt;(-&amp;gt;)&lt;/code&gt; can be defined as an instance of the category type class:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Category&lt;/span&gt; (&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;id&lt;/span&gt;  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;GHC.Base.&lt;/span&gt;&lt;span class="pl-c1"&gt;id&lt;/span&gt;
    &lt;span class="pl-en"&gt;(.)&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;(&lt;span class="pl-c1"&gt;GHC.Base.&lt;/span&gt;.)&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-monadic-composition" class="anchor" aria-hidden="true" href="#monadic-composition"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Monadic Composition&lt;/h4&gt;
&lt;p&gt;In the section on the &lt;a href="#avoiding-partial-functions-by-using-maybe"&gt;Maybe Monad&lt;/a&gt; we have seen that monadic operations can be chained with the Kleisli operator &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;safeRoot&lt;/span&gt;           &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeRoot x
    &lt;span class="pl-k"&gt;|&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (&lt;span class="pl-c1"&gt;sqrt&lt;/span&gt; x)
    &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;

&lt;span class="pl-en"&gt;safeReciprocal&lt;/span&gt;     &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeReciprocal x
    &lt;span class="pl-k"&gt;|&lt;/span&gt; x &lt;span class="pl-k"&gt;/=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;/&lt;/span&gt;x)
    &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;

&lt;span class="pl-en"&gt;safeRootReciprocal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
safeRootReciprocal &lt;span class="pl-k"&gt;=&lt;/span&gt; safeReciprocal &lt;span class="pl-k"&gt;&amp;gt;=&amp;gt;&lt;/span&gt; safeRoot&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The operator &lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt; just flips the arguments of &lt;code&gt;&amp;gt;=&amp;gt;&lt;/code&gt; and thus provides right-to-left composition.
When we compare the signature of &lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt; with the signature of &lt;code&gt;.&lt;/code&gt; we notice the similarity of both concepts:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;(.)&lt;/span&gt;&lt;/span&gt;   &lt;span class="pl-k"&gt;::&lt;/span&gt;            (&lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;   &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;   &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;   &lt;span class="pl-smi"&gt;c&lt;/span&gt;
&lt;span class="pl-en"&gt;(&amp;lt;=&amp;lt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even the implementation of &lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt; is quite similar to the definition of &lt;code&gt;.&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;(f  &lt;span class="pl-k"&gt;.&lt;/span&gt;  g) x &lt;span class="pl-k"&gt;=&lt;/span&gt; f     (g x)
(f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) x &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The essential diffenerce is that &lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt; maintains a monadic structure when producing its result.&lt;/p&gt;
&lt;p&gt;Next we compare signatures of &lt;code&gt;id&lt;/code&gt; and its monadic counterpart &lt;code&gt;return&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;id&lt;/span&gt;     &lt;span class="pl-k"&gt;::&lt;/span&gt;              (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;   &lt;span class="pl-smi"&gt;a&lt;/span&gt;)
&lt;span class="pl-en"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here again &lt;code&gt;return&lt;/code&gt; always produces a monadic structure.&lt;/p&gt;
&lt;p&gt;So the category for Monads can simply be defined as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Kleisli arrows of a monad.&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Kleisli&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Kleisli&lt;/span&gt; &lt;span class="pl-k"&gt;{&lt;/span&gt; &lt;span class="pl-e"&gt;runKleisli&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;}&lt;/span&gt;

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monad&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Category&lt;/span&gt; (&lt;span class="pl-en"&gt;Kleisli&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Kleisli&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;
    (&lt;span class="pl-ent"&gt;Kleisli&lt;/span&gt; f) &lt;span class="pl-k"&gt;.&lt;/span&gt; (&lt;span class="pl-ent"&gt;Kleisli&lt;/span&gt; g) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Kleisli&lt;/span&gt; (f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So if monadic actions form a category we expect that the law of identity and associativity hold:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; f    &lt;span class="pl-k"&gt;=&lt;/span&gt; f                &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; left identity&lt;/span&gt;

f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt; f                &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; right identity&lt;/span&gt;

(f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h)  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; associativity&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let's try to prove it by applying some equational reasoning.
First we take the definition of &lt;code&gt;&amp;lt;=&amp;lt;&lt;/code&gt;: &lt;code&gt;(f &amp;lt;=&amp;lt; g) x = f =&amp;lt;&amp;lt; (g x)&lt;/code&gt;
to expand the above equations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 1. left identity&lt;/span&gt;
&lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; f     &lt;span class="pl-k"&gt;=&lt;/span&gt; f    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; left identity (to be proven)&lt;/span&gt;
(&lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; f) x &lt;span class="pl-k"&gt;=&lt;/span&gt; f x  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta expand&lt;/span&gt;
&lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (f x) &lt;span class="pl-k"&gt;=&lt;/span&gt; f x  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expand &amp;lt;=&amp;lt; by above definition&lt;/span&gt;
&lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; f     &lt;span class="pl-k"&gt;=&lt;/span&gt; f    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta reduce&lt;/span&gt;
f &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; f    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments&lt;/span&gt;


&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 2 right identity&lt;/span&gt;
f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; f    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; right identity (to be proven)&lt;/span&gt;
(f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;) x &lt;span class="pl-k"&gt;=&lt;/span&gt; f x  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta expand&lt;/span&gt;
f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (&lt;span class="pl-c1"&gt;return&lt;/span&gt; x) &lt;span class="pl-k"&gt;=&lt;/span&gt; f x  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expand &amp;lt;=&amp;lt; by above definition&lt;/span&gt;
&lt;span class="pl-c1"&gt;return&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f   &lt;span class="pl-k"&gt;=&lt;/span&gt; f x  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 3. associativity&lt;/span&gt;
(f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h             &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h)  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; associativity (to be proven)&lt;/span&gt;
((f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h) x         &lt;span class="pl-k"&gt;=&lt;/span&gt; (f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h)) x &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta expand&lt;/span&gt;
(f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (h x)         &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; ((g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h) x) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expand outer &amp;lt;=&amp;lt; on both sides&lt;/span&gt;
(&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (f &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; g) y) &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; h x &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; ((g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h) x) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta expand on left hand side&lt;/span&gt;
(&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g y)) &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; h x &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; ((g &lt;span class="pl-k"&gt;&amp;lt;=&amp;lt;&lt;/span&gt; h) x) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expand inner &amp;lt;=&amp;lt; on the lhs&lt;/span&gt;
(&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g y)) &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; h x &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (h x)) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; expand inner &amp;lt;=&amp;lt; on the rhs&lt;/span&gt;
h x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g y)) &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (h x)) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace outer =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments on lhs&lt;/span&gt;
h x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; g y &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f)   &lt;span class="pl-k"&gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (g &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (h x)) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace inner =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments on lhs&lt;/span&gt;
h x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; g y &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f)   &lt;span class="pl-k"&gt;=&lt;/span&gt; (g &lt;span class="pl-k"&gt;=&amp;lt;&amp;lt;&lt;/span&gt; (h x)) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace outer =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments on rhs&lt;/span&gt;
h x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; g y &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f)   &lt;span class="pl-k"&gt;=&lt;/span&gt; ((h x) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; replace inner =&amp;lt;&amp;lt; with &amp;gt;&amp;gt;= and flip arguments on rhs&lt;/span&gt;
h &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; g y &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f)     &lt;span class="pl-k"&gt;=&lt;/span&gt; (h &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f     &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; eta reduce&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we have transformed our three formulas to the following form:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;f &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;   &lt;span class="pl-k"&gt;=&lt;/span&gt; f

&lt;span class="pl-c1"&gt;return&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; f x

h &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;y &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; g y &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f)  &lt;span class="pl-k"&gt;=&lt;/span&gt;  (h &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; g) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; f&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These three equations are equivalent to the &lt;a href="https://wiki.haskell.org/Monad_laws" rel="nofollow"&gt;Monad Laws&lt;/a&gt;, which all Monad instances are required to satisfy:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;m &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt;    &lt;span class="pl-k"&gt;=&lt;/span&gt;  m

&lt;span class="pl-c1"&gt;return&lt;/span&gt; a &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; k  &lt;span class="pl-k"&gt;=&lt;/span&gt;  k a

m &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;x &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; k x &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; h)  &lt;span class="pl-k"&gt;=&lt;/span&gt;  (m &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; k) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; h&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So by virtue of this equivalence any Monad that satisfies the Monad laws automatically satisfies the Category laws.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you have ever wondered where those monad laws came from, now you know! They are just the category laws in disguise.
Consequently, every new Monad we define gives us a category for free!&lt;/p&gt;
&lt;p&gt;Quoted from &lt;a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html" rel="nofollow"&gt;The Category Design Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;&lt;a id="user-content-conclusion-1" class="anchor" aria-hidden="true" href="#conclusion-1"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Conclusion&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Category theory codifies [the] compositional style into a design pattern, the category. Moreover, category theory gives us a precise
prescription for how to create our own abstractions that follow this design pattern: the category laws. These laws differentiate category
theory from other design patterns by providing rigorous criteria for what does and does not qualify as compositional.&lt;/p&gt;
&lt;p&gt;One could easily dismiss this compositional ideal as just that: an ideal, something unsuitable for "real-world" scenarios. However, the
theory behind category theory provides the meat that shows that this compositional ideal appears everywhere and can rise to the challenge of &amp;gt; messy problems and complex business logic.&lt;/p&gt;
&lt;p&gt;Quoted from &lt;a href="http://www.haskellforall.com/2012/08/the-category-design-pattern.html" rel="nofollow"&gt;The Category Design Pattern&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;&lt;a id="user-content-fluent-api--comonad" class="anchor" aria-hidden="true" href="#fluent-api--comonad"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Fluent Api → Comonad&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, a fluent interface [...] is a method for designing object oriented APIs based extensively on method chaining with the goal of making the readability of the source code close to that of ordinary written prose, essentially creating a domain-specific language within the interface.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Fluent_interface" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The &lt;a href="#builder--record-syntax-smart-constructor"&gt;Builder Pattern&lt;/a&gt; is a typical example for a fluent API. The following short Java snippet show the essential elements:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;creating a builder instance&lt;/li&gt;
&lt;li&gt;invoking a sequence of mutators &lt;code&gt;with...&lt;/code&gt; on the builder instance&lt;/li&gt;
&lt;li&gt;finally calling &lt;code&gt;build()&lt;/code&gt; to let the Builder create an object&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-smi"&gt;ConfigBuilder&lt;/span&gt; builder &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;ConfigBuilder&lt;/span&gt;();
&lt;span class="pl-smi"&gt;Config&lt;/span&gt; config &lt;span class="pl-k"&gt;=&lt;/span&gt; builder
        .withProfiling()        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Add profiling&lt;/span&gt;
        .withOptimization()     &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Add optimization&lt;/span&gt;
        .build();
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The interesting point is that all the &lt;code&gt;with...&lt;/code&gt; methods are not implemented as &lt;code&gt;void&lt;/code&gt; method but instead all return the Builder instance, which thus allows to fluently chain the next &lt;code&gt;with...&lt;/code&gt; call.&lt;/p&gt;
&lt;p&gt;Let's try to recreate this fluent chaining of calls in Haskell.
We start with a configuration type &lt;code&gt;Config&lt;/code&gt; that represents a set of option strings (&lt;code&gt;Options&lt;/code&gt;):&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;]

&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Conf&lt;/span&gt; &lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next we define a function &lt;code&gt;configBuilder&lt;/code&gt; which takes &lt;code&gt;Options&lt;/code&gt; as input and returns a &lt;code&gt;Config&lt;/code&gt; instance:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;configBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;
configBuilder options &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Conf&lt;/span&gt; options

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; we can use this to construct a Config instance from a list of Option strings:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; configBuilder [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-O2&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
&lt;span class="pl-ent"&gt;Conf&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-O2&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to allow chaining of the &lt;code&gt;with...&lt;/code&gt; functions they always must return a new &lt;code&gt;Options -&amp;gt; Config&lt;/code&gt; function. So for example &lt;code&gt;withProfiling&lt;/code&gt; would have the following signature:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withProfiling&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This signature is straightforward but the implementation needs some thinking: we take a function &lt;code&gt;builder&lt;/code&gt; of type &lt;code&gt;Options -&amp;gt; Config&lt;/code&gt; as input and must return a new function of the same type that will use the same builder but will add profiling options to the &lt;code&gt;Options&lt;/code&gt; parameter &lt;code&gt;opts&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;withProfiling builder &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;opts &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;HLint tells us that this can be written more terse as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;withProfiling builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to keep notation dense we introduce a type alias for the function type &lt;code&gt;Options -&amp;gt; Config&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this shortcut we can implement the other &lt;code&gt;with...&lt;/code&gt; functions as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withWarnings&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withWarnings builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-Wall&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])

&lt;span class="pl-en"&gt;withOptimization&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withOptimization builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-O2&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])

&lt;span class="pl-en"&gt;withLogging&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withLogging builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-logall&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;build()&lt;/code&gt; function is also quite straightforward. It constructs the actual &lt;code&gt;Config&lt;/code&gt; instance by invoking a given &lt;code&gt;ConfigBuilder&lt;/code&gt; on an empty list:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;build&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;
build builder &lt;span class="pl-k"&gt;=&lt;/span&gt; builder &lt;span class="pl-c1"&gt;mempty&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; now we can use it in ghci:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt; (build (withOptimization (withProfiling configBuilder)))
&lt;span class="pl-ent"&gt;Conf&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-O2&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This does not yet look quite object oriented but with a tiny tweak we'll get quite close. We introduce a special operator &lt;code&gt;#&lt;/code&gt; that allows to write functional expression in an object-oriented style:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;(#)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
x &lt;span class="pl-k"&gt;#&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; f x
&lt;span class="pl-k"&gt;infixl&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;#&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this operator we can write the above example as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;config &lt;span class="pl-k"&gt;=&lt;/span&gt; configBuilder
    &lt;span class="pl-k"&gt;#&lt;/span&gt; withProfiling    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; add profiling&lt;/span&gt;
    &lt;span class="pl-k"&gt;#&lt;/span&gt; withOptimization &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; add optimizations&lt;/span&gt;
    &lt;span class="pl-k"&gt;#&lt;/span&gt; build&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far so good. But what does this have to do with Comonads?
In the following I'll demonstrate how the chaining of functions as shown in our &lt;code&gt;ConfigBuilder&lt;/code&gt; example follows a pattern that is covered by the &lt;code&gt;Comonad&lt;/code&gt; type class.&lt;/p&gt;
&lt;p&gt;Let's have a second look at the &lt;code&gt;with*&lt;/code&gt; functions:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withWarnings&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withWarnings builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-Wall&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])

&lt;span class="pl-en"&gt;withProfiling&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withProfiling builder opts &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts &lt;span class="pl-k"&gt;++&lt;/span&gt; [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These functions all are containing code for explicitely concatenating the &lt;code&gt;opts&lt;/code&gt; argument with additional &lt;code&gt;Options&lt;/code&gt;.
In order to reduce repetitive coding we are looking for a way to factor out the concrete concatenation of &lt;code&gt;Options&lt;/code&gt;.
Going this route the &lt;code&gt;with*&lt;/code&gt; function could be rewritten as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withWarnings''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withWarnings'' builder &lt;span class="pl-k"&gt;=&lt;/span&gt; extend' builder [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-Wall&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]

&lt;span class="pl-en"&gt;withProfiling''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
withProfiling'' builder &lt;span class="pl-k"&gt;=&lt;/span&gt; extend' builder [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Here &lt;code&gt;extend'&lt;/code&gt; is a higher order function that takes a &lt;code&gt;ConfigBuilder&lt;/code&gt; and an &lt;code&gt;Options&lt;/code&gt; argument (&lt;code&gt;opts2&lt;/code&gt;) and returns a new function that returns a new &lt;code&gt;ConfigBuilder&lt;/code&gt; that concatenates its input &lt;code&gt;opts1&lt;/code&gt; with the original &lt;code&gt;opts2&lt;/code&gt; arguments:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;extend'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
extend' builder opts2 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;\&lt;/span&gt;opts1 &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; builder (opts1 &lt;span class="pl-k"&gt;++&lt;/span&gt; opts2)
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; or even denser without explicit lambda:&lt;/span&gt;
extend' builder opts2 opts1 &lt;span class="pl-k"&gt;=&lt;/span&gt; builder (opts1 &lt;span class="pl-k"&gt;++&lt;/span&gt; opts2)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We could carry this idea of refactoring repetitive code even further by eliminating the &lt;code&gt;extend'&lt;/code&gt; from the &lt;code&gt;with*&lt;/code&gt; functions. Of course this will change the signature of the functions:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;withWarnings'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;
withWarnings' builder &lt;span class="pl-k"&gt;=&lt;/span&gt; builder [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-Wall&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]

&lt;span class="pl-en"&gt;withProfiling'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;
withProfiling' builder &lt;span class="pl-k"&gt;=&lt;/span&gt; builder [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-prof&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;-auto-all&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to form fluent sequences of such function calls we need an improved version of the &lt;code&gt;extend&lt;/code&gt; function  which transparently handles the concatenation of &lt;code&gt;Option&lt;/code&gt; arguments and also keeps the chain of &lt;code&gt;with*&lt;/code&gt; functions open for the next &lt;code&gt;with*&lt;/code&gt; function being applied:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;extend''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
extend'' withFun builder opt2 &lt;span class="pl-k"&gt;=&lt;/span&gt; withFun (&lt;span class="pl-k"&gt;\&lt;/span&gt;opt1 &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; builder (opt1 &lt;span class="pl-k"&gt;++&lt;/span&gt; opt2))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to use &lt;code&gt;extend''&lt;/code&gt; efficiently in user code we have to modify our &lt;code&gt;#&lt;/code&gt; operator slightly to transparently handle the extending of &lt;code&gt;ConfigBuilder&lt;/code&gt; instances when chaining functions of type &lt;code&gt;ConfigBuilder -&amp;gt; Config&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;(#&amp;gt;&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;ConfigBuilder&lt;/span&gt;
x &lt;span class="pl-k"&gt;#&amp;gt;&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; extend'' f x
&lt;span class="pl-k"&gt;infixl&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;#&amp;gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;User code would then look like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;configBuilder
    &lt;span class="pl-k"&gt;#&amp;gt;&amp;gt;&lt;/span&gt; withProfiling'
    &lt;span class="pl-k"&gt;#&amp;gt;&amp;gt;&lt;/span&gt; withOptimization'
    &lt;span class="pl-k"&gt;#&amp;gt;&amp;gt;&lt;/span&gt; withLogging'
    &lt;span class="pl-k"&gt;#&lt;/span&gt; build
    &lt;span class="pl-k"&gt;#&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's have a look at the definition of the &lt;code&gt;Comonad&lt;/code&gt; type class. Being the dual of &lt;code&gt;Monad&lt;/code&gt; it defines two functions &lt;code&gt;extract&lt;/code&gt; and &lt;code&gt;extend&lt;/code&gt; which are the duals of &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Functor&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Comonad&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;extract&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-en"&gt;extend&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With the knowledge that &lt;code&gt;((-&amp;gt;) a)&lt;/code&gt; is an instance of &lt;code&gt;Functor&lt;/code&gt; we can define a &lt;code&gt;Comonad&lt;/code&gt; instance for &lt;code&gt;((-&amp;gt;) Options)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; {-# &lt;span class="pl-k"&gt;OVERLAPPING&lt;/span&gt; #-} &lt;span class="pl-en"&gt;Comonad&lt;/span&gt; ((&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) &lt;span class="pl-en"&gt;Options&lt;/span&gt;) &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;extract&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config&lt;/span&gt;
    extract builder &lt;span class="pl-k"&gt;=&lt;/span&gt; builder &lt;span class="pl-c1"&gt;mempty&lt;/span&gt;
    &lt;span class="pl-en"&gt;extend&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; ((&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config'&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;  (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;config'&lt;/span&gt;)
    extend withFun builder opt2 &lt;span class="pl-k"&gt;=&lt;/span&gt; withFun (&lt;span class="pl-k"&gt;\&lt;/span&gt;opt1 &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; builder (opt1 &lt;span class="pl-k"&gt;++&lt;/span&gt; opt2))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's again look at the functions &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;extend''&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;build&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;
build builder &lt;span class="pl-k"&gt;=&lt;/span&gt; builder &lt;span class="pl-c1"&gt;mempty&lt;/span&gt;

&lt;span class="pl-en"&gt;extend''&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; ((&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;Options&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Config&lt;/span&gt;)
extend'' withFun builder opt2 &lt;span class="pl-k"&gt;=&lt;/span&gt; withFun (&lt;span class="pl-k"&gt;\&lt;/span&gt;opt1 &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; builder (opt1 &lt;span class="pl-k"&gt;++&lt;/span&gt; opt2))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It's obvious that &lt;code&gt;build&lt;/code&gt; and &lt;code&gt;extract&lt;/code&gt; are equivalent as well as &lt;code&gt;extend''&lt;/code&gt; and &lt;code&gt;extend&lt;/code&gt;. So we have been inventing a &lt;code&gt;Comonad&lt;/code&gt; without knowing about it.&lt;/p&gt;
&lt;p&gt;But we are even more lucky! Our &lt;code&gt;Options&lt;/code&gt; type (being just a synonym for &lt;code&gt;[String]&lt;/code&gt;) together with the concatenation operator &lt;code&gt;(++)&lt;/code&gt; forms a &lt;code&gt;Monoid&lt;/code&gt;.
And for any &lt;code&gt;Monoid m&lt;/code&gt; &lt;code&gt;((-&amp;gt;) m)&lt;/code&gt; is a Comonad:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Comonad&lt;/span&gt; ((&lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt;) &lt;span class="pl-smi"&gt;m&lt;/span&gt;)  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; as defined in Control.Comonad&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So we don't have to define our own instance of Comonad but can rely on the predefined and more generic &lt;code&gt;((-&amp;gt;) m)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Equipped with this knowledge we define a more generic version of our &lt;code&gt;#&amp;gt;&amp;gt;&lt;/code&gt; chaining operator:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;(#&amp;gt;)&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Comonad&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;w&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
x &lt;span class="pl-k"&gt;#&amp;gt;&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; extend f x
&lt;span class="pl-k"&gt;infixl&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;#&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on this definition we can finally rewrite the user code as follows&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;    configBuilder
        &lt;span class="pl-k"&gt;#&amp;gt;&lt;/span&gt; withProfiling'
        &lt;span class="pl-k"&gt;#&amp;gt;&lt;/span&gt; withOptimization'
        &lt;span class="pl-k"&gt;#&amp;gt;&lt;/span&gt; withLogging'
        &lt;span class="pl-k"&gt;#&lt;/span&gt; extract  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; # build would be fine as well&lt;/span&gt;
        &lt;span class="pl-k"&gt;#&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This section is based on examples from &lt;a href="http://www.haskellforall.com/2013/02/you-could-have-invented-comonads.html" rel="nofollow"&gt;You could have invented Comonads&lt;/a&gt;. Please also check this &lt;a href="http://gelisam.blogspot.com/2013/07/comonads-are-neighbourhoods-not-objects.html" rel="nofollow"&gt;blogpost&lt;/a&gt; which comments on the notion of &lt;em&gt;comonads as objects&lt;/em&gt; in Gabriel Gonzales original posting.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/FluentApi.hs"&gt;Sourcecode for this section&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-beyond-type-class-patterns" class="anchor" aria-hidden="true" href="#beyond-type-class-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Beyond type class patterns&lt;/h2&gt;
&lt;p&gt;The patterns presented in this chapter don't have a direct correspondence to specific type classes. They rather map to more general concepts of functional programming.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-dependency-injection--parameter-binding-partial-application" class="anchor" aria-hidden="true" href="#dependency-injection--parameter-binding-partial-application"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Dependency Injection → Parameter Binding, Partial Application&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] Dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it. The service is made part of the client's state. Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern.&lt;/p&gt;
&lt;p&gt;This fundamental requirement means that using values (services) produced within the class from new or static methods is prohibited. The client should accept values passed in from outside. This allows the client to make acquiring dependencies someone else's problem.
(Quoted from &lt;a href="https://en.wikipedia.org/wiki/Dependency_injection" rel="nofollow"&gt;Wikipedia&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In functional languages this is achieved by binding the formal parameters of a function to values.&lt;/p&gt;
&lt;p&gt;Let's see how this works in a real world example. Say we have been building a renderer that allows to produce a markdown representation of a data type that represents the table of contents of a document:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a table of contents consists of a heading and a list of entries&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; &lt;span class="pl-en"&gt;Heading&lt;/span&gt; [&lt;span class="pl-en"&gt;TocEntry&lt;/span&gt;]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a ToC entry can be a heading or a sub-table of contents&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;TocEntry&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-en"&gt;Heading&lt;/span&gt; | &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a heading can be just a title string or an url with a title and the actual link&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Heading&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; | &lt;span class="pl-ent"&gt;Url&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; render a ToC entry as a Markdown String with the proper indentation&lt;/span&gt;
&lt;span class="pl-en"&gt;teToMd&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;TocEntry&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
teToMd depth (&lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-c1"&gt;head&lt;/span&gt;) &lt;span class="pl-k"&gt;=&lt;/span&gt; headToMd depth &lt;span class="pl-c1"&gt;head&lt;/span&gt;
teToMd depth (&lt;span class="pl-ent"&gt;Sub&lt;/span&gt; toc)   &lt;span class="pl-k"&gt;=&lt;/span&gt; tocToMd  depth toc

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; render a heading as a Markdown String with the proper indentation&lt;/span&gt;
&lt;span class="pl-en"&gt;headToMd&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Heading&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
headToMd depth (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; str)     &lt;span class="pl-k"&gt;=&lt;/span&gt; indent depth &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;* &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; str &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
headToMd depth (&lt;span class="pl-ent"&gt;Url&lt;/span&gt; title url) &lt;span class="pl-k"&gt;=&lt;/span&gt; indent depth &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;* [&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; title &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;](&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; url &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;)&lt;span class="pl-cce"&gt;\n&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; convert a ToC to Markdown String. The parameter depth is used for proper indentation.&lt;/span&gt;
&lt;span class="pl-en"&gt;tocToMd&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
tocToMd depth (&lt;span class="pl-ent"&gt;Section&lt;/span&gt; heading entries) &lt;span class="pl-k"&gt;=&lt;/span&gt; headToMd depth heading &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;concatMap&lt;/span&gt; (teToMd (depth&lt;span class="pl-k"&gt;+&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;)) entries

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; produce a String of length n, consisting only of blanks&lt;/span&gt;
&lt;span class="pl-en"&gt;indent&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
indent n &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;replicate&lt;/span&gt; n &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt; &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; render a ToC as a Text (consisting of properly indented Markdown)&lt;/span&gt;
&lt;span class="pl-en"&gt;tocToMDText&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;
tocToMDText &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;T.&lt;/span&gt;pack &lt;span class="pl-k"&gt;.&lt;/span&gt; tocToMd &lt;span class="pl-c1"&gt;0&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use these definitions to create a table of contents data structure and to render it to markdown syntax:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;demoDI &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; toc &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Chapter 1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                [ &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Section a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                    [&lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;First Heading&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
                     &lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Url&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Second Heading&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
                , &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Url&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Section b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.section.b.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                    [ &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;UnderSection b1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                        [&lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;First&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Second&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]]]
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;T.&lt;/span&gt;unpack &lt;span class="pl-k"&gt;$&lt;/span&gt; tocToMDText toc

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and the in ghci:&lt;/span&gt;
ghci &lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; demoDI
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;*&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Chapter&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
  &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; a
    &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;First&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;
    &lt;span class="pl-k"&gt;*&lt;/span&gt; [&lt;span class="pl-ent"&gt;Second&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;](http&lt;span class="pl-k"&gt;://&lt;/span&gt;the&lt;span class="pl-k"&gt;.&lt;/span&gt;url)
  &lt;span class="pl-k"&gt;*&lt;/span&gt; [&lt;span class="pl-ent"&gt;Section&lt;/span&gt; b](http&lt;span class="pl-k"&gt;://&lt;/span&gt;the&lt;span class="pl-k"&gt;.&lt;/span&gt;section&lt;span class="pl-k"&gt;.&lt;/span&gt;b&lt;span class="pl-k"&gt;.&lt;/span&gt;url)
    &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;UnderSection&lt;/span&gt; b1
      &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;First&lt;/span&gt;
      &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;Second&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So far so good. But of course we also want to be able to render our &lt;code&gt;TableOfContent&lt;/code&gt; to HTML.
As we don't want to repeat all the coding work for HTML we think about using an existing Markdown library.&lt;/p&gt;
&lt;p&gt;But we don't want any hard coded dependencies to a specific library in our code.&lt;/p&gt;
&lt;p&gt;With these design ideas in mind we specify a rendering processor:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; render a ToC as a Text with html markup.&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;   we specify this function as a chain of parse and rendering functions&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;   which must be provided externally&lt;/span&gt;
&lt;span class="pl-en"&gt;tocToHtmlText&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 1. a renderer function from ToC to Text with markdown markups&lt;/span&gt;
              &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;MarkDown&lt;/span&gt;)        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 2. a parser function from Text to a MarkDown document&lt;/span&gt;
              &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;MarkDown&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;HTML&lt;/span&gt;)          &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 3. a renderer function from MarkDown to an HTML document&lt;/span&gt;
              &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; (&lt;span class="pl-en"&gt;HTML&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;)            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 4. a renderer function from HTML to Text&lt;/span&gt;
              &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt;             &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the actual ToC to be rendered&lt;/span&gt;
              &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;                      &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the Text output (containing html markup)&lt;/span&gt;
tocToHtmlText tocToMdText textToMd mdToHtml htmlToText &lt;span class="pl-k"&gt;=&lt;/span&gt;
    tocToMdText &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 1. render a ToC as a Text (consisting of properly indented Markdown)&lt;/span&gt;
    textToMd    &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 2. parse text with Markdown to a MarkDown data structure&lt;/span&gt;
    mdToHtml    &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 3. convert the MarkDown data to an HTML data structure&lt;/span&gt;
    htmlToText         &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; 4. render the HTML data to a Text with hmtl markup&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea is simple:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We render our &lt;code&gt;TableOfContents&lt;/code&gt; to a Markdown &lt;code&gt;Text&lt;/code&gt; (e.g. using our already defined &lt;code&gt;tocToMDText&lt;/code&gt; function).&lt;/li&gt;
&lt;li&gt;This text is then parsed into a &lt;code&gt;MarkDown&lt;/code&gt; data structure.&lt;/li&gt;
&lt;li&gt;The &lt;code&gt;Markdown&lt;/code&gt; document is rendered into an &lt;code&gt;HTML&lt;/code&gt; data structure,&lt;/li&gt;
&lt;li&gt;which is then rendered to a &lt;code&gt;Text&lt;/code&gt; containing html markup.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To notate the chaining of functions in their natural order I have used the &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; operator from &lt;code&gt;Control.Arrow&lt;/code&gt; which is defined as follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;f &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; g &lt;span class="pl-k"&gt;=&lt;/span&gt; g &lt;span class="pl-k"&gt;.&lt;/span&gt; f&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is just left to right composition of functions which makes reading of longer composition chains much easier to read (at least for people trained to read from left to right).&lt;/p&gt;
&lt;p&gt;Please note that at this point we have not defined the types &lt;code&gt;HTML&lt;/code&gt; and &lt;code&gt;Markdown&lt;/code&gt;. They are just abstract placeholders and we just expect them to be provided externally.
In the same way we just specified that there must be functions available that can be bound to the formal parameters
&lt;code&gt;tocToText&lt;/code&gt;, &lt;code&gt;textToMd&lt;/code&gt;, &lt;code&gt;mdToHtml&lt;/code&gt; and  &lt;code&gt;htmlToText&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If such functions are avaliable we can &lt;em&gt;inject&lt;/em&gt; them (or rather bind them to the formal parameters) as in the following definition:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a default implementation of a ToC to html Text renderer.&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;   this function is constructed by partially applying `tocToHtmlText` to four functions&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;   matching the signature of `tocToHtmlText`.&lt;/span&gt;
&lt;span class="pl-en"&gt;defaultTocToHtmlText&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;TableOfContents&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;
defaultTocToHtmlText &lt;span class="pl-k"&gt;=&lt;/span&gt;
    tocToHtmlText
        tocToMDText         &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the ToC to markdown Text renderer as defined above&lt;/span&gt;
        textToMarkDown      &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a MarkDown parser, externally provided via import&lt;/span&gt;
        markDownToHtml      &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a MarkDown to HTML renderer, externally provided via import&lt;/span&gt;
        htmlToText          &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a HTML to Text with html markup, externally provided via import&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This definition assumes that apart from &lt;code&gt;tocToMDText&lt;/code&gt; which has already been defined the functions &lt;code&gt;textToMarkDown&lt;/code&gt;, &lt;code&gt;markDownToHtml&lt;/code&gt; and &lt;code&gt;htmlToText&lt;/code&gt; are also present in the current scope.
This is achieved by the following import statement:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-c1"&gt;CheapskateRenderer&lt;/span&gt; (&lt;span class="pl-en"&gt;HTML&lt;/span&gt;, &lt;span class="pl-en"&gt;MarkDown&lt;/span&gt;, &lt;span class="pl-en"&gt;textToMarkDown&lt;/span&gt;, &lt;span class="pl-en"&gt;markDownToHtml&lt;/span&gt;, &lt;span class="pl-en"&gt;htmlToText&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The implementation in file CheapskateRenderer.hs then looks like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;module&lt;/span&gt; &lt;span class="pl-c1"&gt;CheapskateRenderer&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-k"&gt;qualified&lt;/span&gt; &lt;span class="pl-c1"&gt;Cheapskate&lt;/span&gt;                      &lt;span class="pl-k"&gt;as&lt;/span&gt; &lt;span class="pl-c1"&gt;C&lt;/span&gt;
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-k"&gt;qualified&lt;/span&gt; &lt;span class="pl-c1"&gt;Data.Text&lt;/span&gt;                       &lt;span class="pl-k"&gt;as&lt;/span&gt; &lt;span class="pl-c1"&gt;T&lt;/span&gt;
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-k"&gt;qualified&lt;/span&gt; &lt;span class="pl-c1"&gt;Text.Blaze.Html&lt;/span&gt;                 &lt;span class="pl-k"&gt;as&lt;/span&gt; &lt;span class="pl-c1"&gt;H&lt;/span&gt;
&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-k"&gt;qualified&lt;/span&gt; &lt;span class="pl-c1"&gt;Text.Blaze.Html.Renderer.Pretty&lt;/span&gt; &lt;span class="pl-k"&gt;as&lt;/span&gt; &lt;span class="pl-c1"&gt;R&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a type synonym that hides the Cheapskate internal Doc type&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;MarkDown&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;C.&lt;/span&gt;Doc&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a type synonym the hides the Blaze.Html internal Html type&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;HTML&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;H.&lt;/span&gt;Html&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; parse Markdown from a Text (with markdown markup). Using the Cheapskate library.&lt;/span&gt;
&lt;span class="pl-en"&gt;textToMarkDown&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;MarkDown&lt;/span&gt;
textToMarkDown &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;C.&lt;/span&gt;markdown &lt;span class="pl-c1"&gt;C.&lt;/span&gt;def

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; convert MarkDown to HTML by using the Blaze.Html library&lt;/span&gt;
&lt;span class="pl-en"&gt;markDownToHtml&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;MarkDown&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;HTML&lt;/span&gt;
markDownToHtml &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;H.&lt;/span&gt;toHtml

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; rendering a Text with html markup from HTML. Using Blaze again.&lt;/span&gt;
&lt;span class="pl-en"&gt;htmlToText&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;HTML&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;T.&lt;/span&gt;Text&lt;/span&gt;
htmlToText &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;T.&lt;/span&gt;pack &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;R.&lt;/span&gt;renderHtml&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now let's try it out:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;demoDI &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; toc &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Chapter 1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                [ &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Section a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                    [&lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;First Heading&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,
                     &lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Url&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Second Heading&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
                , &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Url&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Section b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.section.b.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                    [ &lt;span class="pl-ent"&gt;Sub&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; (&lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;UnderSection b1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                        [&lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;First&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-ent"&gt;Head&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Title&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Second&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]]]

    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;T.&lt;/span&gt;unpack &lt;span class="pl-k"&gt;$&lt;/span&gt; tocToMDText toc

    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;T.&lt;/span&gt;unpack &lt;span class="pl-k"&gt;$&lt;/span&gt; defaultTocToHtmlText toc  

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; using this in ghci:&lt;/span&gt;
ghci &lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; demoDI
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;*&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Chapter&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
  &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;Section&lt;/span&gt; a
    &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;First&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;
    &lt;span class="pl-k"&gt;*&lt;/span&gt; [&lt;span class="pl-ent"&gt;Second&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;](http&lt;span class="pl-k"&gt;://&lt;/span&gt;the&lt;span class="pl-k"&gt;.&lt;/span&gt;url)
  &lt;span class="pl-k"&gt;*&lt;/span&gt; [&lt;span class="pl-ent"&gt;Section&lt;/span&gt; b](http&lt;span class="pl-k"&gt;://&lt;/span&gt;the&lt;span class="pl-k"&gt;.&lt;/span&gt;section&lt;span class="pl-k"&gt;.&lt;/span&gt;b&lt;span class="pl-k"&gt;.&lt;/span&gt;url)
    &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;UnderSection&lt;/span&gt; b1
      &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;First&lt;/span&gt;
      &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-ent"&gt;Second&lt;/span&gt;

&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;Chapter&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;Section&lt;/span&gt; a
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;First&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;&lt;/span&gt;a href&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;Second&lt;/span&gt; &lt;span class="pl-ent"&gt;Heading&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;a&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;&lt;/span&gt;a href&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;http://the.section.b.url&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;Section&lt;/span&gt; b&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;a&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;UnderSection&lt;/span&gt; b1
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;First&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;lt;&lt;/span&gt;&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;span class="pl-ent"&gt;Second&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;li&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;&amp;lt;/&lt;/span&gt;ul&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By inlining this output into the present Markdown document we can see that Markdown and HTML rendering produce the same structure:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Chapter 1
&lt;ul&gt;
&lt;li&gt;Section a
&lt;ul&gt;
&lt;li&gt;First Heading&lt;/li&gt;
&lt;li&gt;&lt;a href="http://the.url" rel="nofollow"&gt;Second Heading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="http://the.section.b.url" rel="nofollow"&gt;Section b&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;UnderSection b1
&lt;ul&gt;
&lt;li&gt;First&lt;/li&gt;
&lt;li&gt;Second&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Chapter 1
&lt;ul&gt;
&lt;li&gt;Section a
&lt;ul&gt;
&lt;li&gt;First Heading&lt;/li&gt;
&lt;li&gt;&lt;a href="http://the.url" rel="nofollow"&gt;Second Heading&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://the.section.b.url" rel="nofollow"&gt;Section b&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;UnderSection b1
&lt;ul&gt;
&lt;li&gt;First&lt;/li&gt;
&lt;li&gt;Second&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/DependencyInjection.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-command--functions-as-first-class-citizens" class="anchor" aria-hidden="true" href="#command--functions-as-first-class-citizens"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Command → Functions as First Class Citizens&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In object-oriented programming, the command pattern is a behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later time. This information includes the method name, the object that owns the method and values for the method parameters.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Command_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Wikipedia article features implementation of a simple example in several languages. I'm quoting the Java version here:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-smi"&gt;java.util.ArrayList&lt;/span&gt;;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt;* The Command interface &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;interface&lt;/span&gt; &lt;span class="pl-en"&gt;Command&lt;/span&gt; {
   &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;execute&lt;/span&gt;();
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt;* The Invoker class &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;Switch&lt;/span&gt; {
   &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;final&lt;/span&gt; &lt;span class="pl-k"&gt;ArrayList&amp;lt;&lt;span class="pl-smi"&gt;Command&lt;/span&gt;&amp;gt;&lt;/span&gt; history &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-k"&gt;ArrayList&amp;lt;&amp;gt;&lt;/span&gt;();

   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;storeAndExecute&lt;/span&gt;(&lt;span class="pl-smi"&gt;Command&lt;/span&gt; &lt;span class="pl-v"&gt;cmd&lt;/span&gt;) {
      &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;history&lt;span class="pl-k"&gt;.&lt;/span&gt;add(cmd);
      cmd&lt;span class="pl-k"&gt;.&lt;/span&gt;execute();
   }
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt;* The Receiver class &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;Light&lt;/span&gt; {
   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;turnOn&lt;/span&gt;() {
      &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;The light is on&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;);
   }

   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;turnOff&lt;/span&gt;() {
      &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;The light is off&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;);
   }
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt;* The Command for turning on the light - ConcreteCommand #1 &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;FlipUpCommand&lt;/span&gt; &lt;span class="pl-k"&gt;implements&lt;/span&gt; &lt;span class="pl-e"&gt;Command&lt;/span&gt; {
   &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;final&lt;/span&gt; &lt;span class="pl-smi"&gt;Light&lt;/span&gt; light;

   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-en"&gt;FlipUpCommand&lt;/span&gt;(&lt;span class="pl-smi"&gt;Light&lt;/span&gt; &lt;span class="pl-v"&gt;light&lt;/span&gt;) {
      &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;light &lt;span class="pl-k"&gt;=&lt;/span&gt; light;
   }

   &lt;span class="pl-k"&gt;@Override&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Command&lt;/span&gt;
   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;execute&lt;/span&gt;() {
      light&lt;span class="pl-k"&gt;.&lt;/span&gt;turnOn();
   }
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt;* The Command for turning off the light - ConcreteCommand #2 &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;FlipDownCommand&lt;/span&gt; &lt;span class="pl-k"&gt;implements&lt;/span&gt; &lt;span class="pl-e"&gt;Command&lt;/span&gt; {
   &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;final&lt;/span&gt; &lt;span class="pl-smi"&gt;Light&lt;/span&gt; light;

   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-en"&gt;FlipDownCommand&lt;/span&gt;(&lt;span class="pl-smi"&gt;Light&lt;/span&gt; &lt;span class="pl-v"&gt;light&lt;/span&gt;) {
      &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;light &lt;span class="pl-k"&gt;=&lt;/span&gt; light;
   }

   &lt;span class="pl-k"&gt;@Override&lt;/span&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Command&lt;/span&gt;
   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;execute&lt;/span&gt;() {
      light&lt;span class="pl-k"&gt;.&lt;/span&gt;turnOff();
   }
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;/*&lt;/span&gt; The test class or client &lt;span class="pl-c"&gt;*/&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;PressSwitch&lt;/span&gt; {
   &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;main&lt;/span&gt;(&lt;span class="pl-k"&gt;final&lt;/span&gt; &lt;span class="pl-k"&gt;String&lt;/span&gt;[] &lt;span class="pl-v"&gt;arguments&lt;/span&gt;){
      &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; Check number of arguments&lt;/span&gt;
      &lt;span class="pl-k"&gt;if&lt;/span&gt; (arguments&lt;span class="pl-k"&gt;.&lt;/span&gt;length &lt;span class="pl-k"&gt;!=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;) {
         &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;err&lt;span class="pl-k"&gt;.&lt;/span&gt;println(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Argument &lt;span class="pl-cce"&gt;\"&lt;/span&gt;ON&lt;span class="pl-cce"&gt;\"&lt;/span&gt; or &lt;span class="pl-cce"&gt;\"&lt;/span&gt;OFF&lt;span class="pl-cce"&gt;\"&lt;/span&gt; is required!&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;);
         &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;exit(&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;);
      }

      &lt;span class="pl-smi"&gt;Light&lt;/span&gt; lamp &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;Light&lt;/span&gt;();

      &lt;span class="pl-smi"&gt;Command&lt;/span&gt; switchUp &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;FlipUpCommand&lt;/span&gt;(lamp);
      &lt;span class="pl-smi"&gt;Command&lt;/span&gt; switchDown &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;FlipDownCommand&lt;/span&gt;(lamp);

      &lt;span class="pl-smi"&gt;Switch&lt;/span&gt; mySwitch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;Switch&lt;/span&gt;();

      &lt;span class="pl-k"&gt;switch&lt;/span&gt;(arguments[&lt;span class="pl-c1"&gt;0&lt;/span&gt;]) {
         &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;ON&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt;
            mySwitch&lt;span class="pl-k"&gt;.&lt;/span&gt;storeAndExecute(switchUp);
            &lt;span class="pl-k"&gt;break&lt;/span&gt;;
         &lt;span class="pl-k"&gt;case&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;OFF&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt;
            mySwitch&lt;span class="pl-k"&gt;.&lt;/span&gt;storeAndExecute(switchDown);
            &lt;span class="pl-k"&gt;break&lt;/span&gt;;
         &lt;span class="pl-k"&gt;default&lt;/span&gt;&lt;span class="pl-k"&gt;:&lt;/span&gt;
            &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;err&lt;span class="pl-k"&gt;.&lt;/span&gt;println(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Argument &lt;span class="pl-cce"&gt;\"&lt;/span&gt;ON&lt;span class="pl-cce"&gt;\"&lt;/span&gt; or &lt;span class="pl-cce"&gt;\"&lt;/span&gt;OFF&lt;span class="pl-cce"&gt;\"&lt;/span&gt; is required.&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;);
            &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;exit(&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;);
      }
   }
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rewriting this in Haskell is much denser:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt;           &lt;span class="pl-c1"&gt;Control.Monad.Writer&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the writer monad is used to implement the history&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; The Light data type with two nullary operations to turn the light on or off &lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Light&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Light&lt;/span&gt; &lt;span class="pl-k"&gt;{&lt;/span&gt;
      &lt;span class="pl-e"&gt;turnOn&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
    , &lt;span class="pl-e"&gt;turnOff&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;}&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; our default instance of a Light&lt;/span&gt;
simpleLamp &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Light&lt;/span&gt; { 
      turnOn  &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;The Light is on&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;  &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;on&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    , turnOff &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;The Light is off&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;return&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;off&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
}

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a command to flip on a Light&lt;/span&gt;
&lt;span class="pl-en"&gt;flipUpCommand&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Light&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
flipUpCommand &lt;span class="pl-k"&gt;=&lt;/span&gt; turnOn

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a command to flipDown a Light&lt;/span&gt;
&lt;span class="pl-en"&gt;flipDownCommand&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Light&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
flipDownCommand &lt;span class="pl-k"&gt;=&lt;/span&gt; turnOff

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; execute a command and log it&lt;/span&gt;
&lt;span class="pl-en"&gt;storeAndExecute&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WriterT&lt;/span&gt;[&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;] &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
storeAndExecute command &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    logEntry &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; liftIO command
    tell [logEntry]
  
&lt;span class="pl-en"&gt;commandDemo&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
commandDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; lamp &lt;span class="pl-k"&gt;=&lt;/span&gt; simpleLamp
    result &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; execWriterT &lt;span class="pl-k"&gt;$&lt;/span&gt;
        storeAndExecute (flipUpCommand lamp)   &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
        storeAndExecute (flipDownCommand lamp) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt;
        storeAndExecute (flipUpCommand lamp)

    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;switch history: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt; result&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Command.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-adapter--function-composition" class="anchor" aria-hidden="true" href="#adapter--function-composition"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Adapter → Function Composition&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;"The adapter pattern is a software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source code."
(Quoted from &lt;a href="https://en.wikipedia.org/wiki/Adapter_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;An example is an adapter that converts the interface of a Document Object Model of an XML document into a tree structure that can be displayed.&lt;/p&gt;
&lt;p&gt;What does an adapter do? It translates a call to the adapter into a call of the adapted backend code. Which may also involve translation of the argument data.&lt;/p&gt;
&lt;p&gt;Say we have some &lt;code&gt;backend&lt;/code&gt; function that we want to provide with an adapter. we assume that &lt;code&gt;backend&lt;/code&gt; has type &lt;code&gt;c -&amp;gt; d&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;backend&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;d&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Our adapter should be of type &lt;code&gt;a -&amp;gt; b&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;adapter&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to write this adapter we have to write two function. The first is:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;marshal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which translated the input argument of &lt;code&gt;adapter&lt;/code&gt; into the correct type &lt;code&gt;c&lt;/code&gt; that can be digested by the backend.
And the second function is:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;unmarshal&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;d&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which translates the result of the &lt;code&gt;backend&lt;/code&gt;function into the correct return type of &lt;code&gt;adapter&lt;/code&gt;.
&lt;code&gt;adapter&lt;/code&gt; will then look like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;adapter&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
adapter &lt;span class="pl-k"&gt;=&lt;/span&gt; unmarshal &lt;span class="pl-k"&gt;.&lt;/span&gt; backend &lt;span class="pl-k"&gt;.&lt;/span&gt; marshal&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So in essence the Adapter Patterns is just function composition.&lt;/p&gt;
&lt;p&gt;Here is a simple example. Say we have a backend that understands only 24 hour arithmetics (eg. 23:50 + 0:20 = 0:10).&lt;/p&gt;
&lt;p&gt;But in our frontend we don't want to see this ugly arithmetics and want to be able to add minutes to a time representation in minutes (eg. 100 + 200 = 300).&lt;/p&gt;
&lt;p&gt;We solve this by using the above mentioned function composition of &lt;code&gt;unmarshal . backend . marshal&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a 24:00 hour clock representation of time&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; this is our backend. It can add minutes to a WallTime representation&lt;/span&gt;
&lt;span class="pl-en"&gt;addMinutesToWallTime&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt;
addMinutesToWallTime x (&lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (h, m)) &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; (hAdd, mAdd) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;`quotRem`&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt;
        hNew &lt;span class="pl-k"&gt;=&lt;/span&gt; h &lt;span class="pl-k"&gt;+&lt;/span&gt; hAdd
        mNew &lt;span class="pl-k"&gt;=&lt;/span&gt; m &lt;span class="pl-k"&gt;+&lt;/span&gt; mAdd
    &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; mNew &lt;span class="pl-k"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt;
        &lt;span class="pl-k"&gt;then&lt;/span&gt;
            &lt;span class="pl-k"&gt;let&lt;/span&gt; (dnew, hnew') &lt;span class="pl-k"&gt;=&lt;/span&gt; (hNew &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;) &lt;span class="pl-k"&gt;`quotRem`&lt;/span&gt; &lt;span class="pl-c1"&gt;24&lt;/span&gt;
            &lt;span class="pl-k"&gt;in&lt;/span&gt;  &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (&lt;span class="pl-c1"&gt;24&lt;/span&gt;&lt;span class="pl-k"&gt;*&lt;/span&gt;dnew &lt;span class="pl-k"&gt;+&lt;/span&gt; hnew', mNew&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;60&lt;/span&gt;)
        &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (hNew, mNew)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; this is our time representation in Minutes that we want to use in the frontend&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Minute&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; convert a Minute value into a WallTime representation&lt;/span&gt;
&lt;span class="pl-en"&gt;marshalMW&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt;
marshalMW (&lt;span class="pl-ent"&gt;Minute&lt;/span&gt; x) &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; (h,m) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;`quotRem`&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt;
    &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (h &lt;span class="pl-k"&gt;`rem`&lt;/span&gt; &lt;span class="pl-c1"&gt;24&lt;/span&gt;, m)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; convert a WallTime value back to Minutes&lt;/span&gt;
&lt;span class="pl-en"&gt;unmarshalWM&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
unmarshalWM (&lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (h,m)) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt; &lt;span class="pl-k"&gt;*&lt;/span&gt; h &lt;span class="pl-k"&gt;+&lt;/span&gt; m

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; this is our frontend that add Minutes to a time of a day&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; measured in minutes&lt;/span&gt;
&lt;span class="pl-en"&gt;addMinutesAdapter&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
addMinutesAdapter x &lt;span class="pl-k"&gt;=&lt;/span&gt; unmarshalWM &lt;span class="pl-k"&gt;.&lt;/span&gt; addMinutesToWallTime x &lt;span class="pl-k"&gt;.&lt;/span&gt; marshalMW

adapterDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Adapter vs. function composition&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; addMinutesAdapter &lt;span class="pl-c1"&gt;100&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Minute&lt;/span&gt; &lt;span class="pl-c1"&gt;400&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Adapter.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-template-method--type-class-default-functions" class="anchor" aria-hidden="true" href="#template-method--type-class-default-functions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Template Method → type class default functions&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In software engineering, the template method pattern is a behavioral design pattern that defines the program skeleton of an algorithm in an operation, deferring some steps to subclasses.
It lets one redefine certain steps of an algorithm without changing the algorithm's structure.
&lt;a href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The TemplateMethod pattern is quite similar to the &lt;a href="#strategy---functor"&gt;StrategyPattern&lt;/a&gt;. The main difference is the level of granularity.
In Strategy a complete block of functionality - the Strategy - can be replaced.
In TemplateMethod the overall layout of an algorithm is predefined and only specific parts of it may be replaced.&lt;/p&gt;
&lt;p&gt;In functional programming the answer to this kind of problem is again the usage of higher order functions.&lt;/p&gt;
&lt;p&gt;In the following example we come back to the example for the &lt;a href="#adapter---function-composition"&gt;Adapter&lt;/a&gt;.
The function &lt;code&gt;addMinutesAdapter&lt;/code&gt; lays out a structure for interfacing to some kind of backend:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;marshalling the arguments into the backend format&lt;/li&gt;
&lt;li&gt;apply the backend logic to the marshalled arguments&lt;/li&gt;
&lt;li&gt;unmarshal the backend result data into the frontend format&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;addMinutesAdapter&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
addMinutesAdapter x &lt;span class="pl-k"&gt;=&lt;/span&gt; unmarshalWM &lt;span class="pl-k"&gt;.&lt;/span&gt; addMinutesToWallTime x &lt;span class="pl-k"&gt;.&lt;/span&gt; marshalMW&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this code the backend functionality - &lt;code&gt;addMinutesToWallTime&lt;/code&gt; - is a hardcoded part of the overall structure.&lt;/p&gt;
&lt;p&gt;Let's assume we want to use different kind of backend implementations - for instance a mock replacement.
In this case we would like to keep the overall structure - the template - and would just make a specific part of it flexible.
This sounds like an ideal candidate for the TemplateMethod pattern:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;addMinutesTemplate&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
addMinutesTemplate f x &lt;span class="pl-k"&gt;=&lt;/span&gt;
    unmarshalWM &lt;span class="pl-k"&gt;.&lt;/span&gt;
    f x &lt;span class="pl-k"&gt;.&lt;/span&gt;
    marshalMW&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;addMinutesTemplate&lt;/code&gt; has an additional parameter f of type &lt;code&gt;(Int -&amp;gt; WallTime -&amp;gt; WallTime)&lt;/code&gt;. This parameter may be bound to &lt;code&gt;addMinutesToWallTime&lt;/code&gt; or alternative implementations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; implements linear addition (the normal case) even for values &amp;gt; 1440&lt;/span&gt;
&lt;span class="pl-en"&gt;linearTimeAdd&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
linearTimeAdd &lt;span class="pl-k"&gt;=&lt;/span&gt; addMinutesTemplate addMinutesToWallTime

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; implements cyclic addition, respecting a 24 hour (1440 Min) cycle&lt;/span&gt;
&lt;span class="pl-en"&gt;cyclicTimeAdd&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Minute&lt;/span&gt;
cyclicTimeAdd &lt;span class="pl-k"&gt;=&lt;/span&gt; addMinutesTemplate addMinutesToWallTime'&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;code&gt;addMinutesToWallTime'&lt;/code&gt; implements a silly 24 hour cyclic addition:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a 24 hour (1440 min) cyclic version of addition: 1400 + 100 = 60&lt;/span&gt;
&lt;span class="pl-en"&gt;addMinutesToWallTime'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt;
addMinutesToWallTime' x (&lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (h, m)) &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; (hAdd, mAdd) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;`quotRem`&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt;
        hNew &lt;span class="pl-k"&gt;=&lt;/span&gt; h &lt;span class="pl-k"&gt;+&lt;/span&gt; hAdd
        mNew &lt;span class="pl-k"&gt;=&lt;/span&gt; m &lt;span class="pl-k"&gt;+&lt;/span&gt; mAdd
    &lt;span class="pl-k"&gt;in&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; mNew &lt;span class="pl-k"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;60&lt;/span&gt;
        &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; ((hNew &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;) &lt;span class="pl-k"&gt;`rem`&lt;/span&gt; &lt;span class="pl-c1"&gt;24&lt;/span&gt;, mNew&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;60&lt;/span&gt;)
        &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (hNew, mNew)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And here is how we use it to do actual computations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;templateMethodDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;linear time: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; (&lt;span class="pl-c1"&gt;show&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; linearTimeAdd &lt;span class="pl-c1"&gt;100&lt;/span&gt; (&lt;span class="pl-ent"&gt;Minute&lt;/span&gt; &lt;span class="pl-c1"&gt;1400&lt;/span&gt;))
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;cyclic time: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; (&lt;span class="pl-c1"&gt;show&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; cyclicTimeAdd &lt;span class="pl-c1"&gt;100&lt;/span&gt; (&lt;span class="pl-ent"&gt;Minute&lt;/span&gt; &lt;span class="pl-c1"&gt;1400&lt;/span&gt;))&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;a id="user-content-type-class-minimal-implementations-as-template-method" class="anchor" aria-hidden="true" href="#type-class-minimal-implementations-as-template-method"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;type class minimal implementations as template method&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The template method is used in frameworks, where each implements the invariant parts of a domain's architecture,
leaving "placeholders" for customization options. This is an example of inversion of control.
&lt;a href="https://en.wikipedia.org/wiki/Template_method_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The type classes in Haskells base library apply this template approach frequently to reduce the effort for implementing type class instances and to provide a predefined structure with specific 'customization options'.&lt;/p&gt;
&lt;p&gt;As an example let's extend the type &lt;code&gt;WallTime&lt;/code&gt; by an associative binary operation &lt;code&gt;addWallTimes&lt;/code&gt; to form an instance of the &lt;code&gt;Monoid&lt;/code&gt; type class:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;addWallTimes&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt;
addWallTimes a&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (h,m)) b &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; aMin &lt;span class="pl-k"&gt;=&lt;/span&gt; h&lt;span class="pl-k"&gt;*&lt;/span&gt;&lt;span class="pl-c1"&gt;60&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; m
    &lt;span class="pl-k"&gt;in&lt;/span&gt;  addMinutesToWallTime aMin b

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-en"&gt;(&amp;lt;&amp;gt;)&lt;/span&gt;   &lt;span class="pl-k"&gt;=&lt;/span&gt; addWallTimes
&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WallTime&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mempty&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (&lt;span class="pl-c1"&gt;0&lt;/span&gt;,&lt;span class="pl-c1"&gt;0&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Even though we specified only &lt;code&gt;mempty&lt;/code&gt; and &lt;code&gt;(&amp;lt;&amp;gt;)&lt;/code&gt; we can now use the functions &lt;code&gt;mappend :: Monoid a =&amp;gt; a -&amp;gt; a -&amp;gt; a&lt;/code&gt; and &lt;code&gt;mconcat :: Monoid a =&amp;gt; [a] -&amp;gt; a&lt;/code&gt; on WallTime instances:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;templateMethodDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; a &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WallTime&lt;/span&gt; (&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;)
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mappend&lt;/span&gt; a a
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; [a,a,a,a,a,a,a,a,a]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By looking at the definition of the &lt;code&gt;Monoid&lt;/code&gt; type class we can see how this 'magic' is made possible:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Identity of 'mappend'&lt;/span&gt;
    &lt;span class="pl-en"&gt;mempty&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; An associative operation&lt;/span&gt;
    &lt;span class="pl-en"&gt;mappend&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mappend&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;(&amp;lt;&amp;gt;)&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Fold a list using the monoid.&lt;/span&gt;
    &lt;span class="pl-en"&gt;mconcat&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mconcat&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; &lt;span class="pl-c1"&gt;mappend&lt;/span&gt; &lt;span class="pl-c1"&gt;mempty&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For &lt;code&gt;mempty&lt;/code&gt; only a type requirement but no definition is given.
But for &lt;code&gt;mappend&lt;/code&gt; and &lt;code&gt;mconcat&lt;/code&gt; default implementations are provided.
So the Monoid type class definition forms a &lt;em&gt;template&lt;/em&gt; where the default implementations define the 'invariant parts' of the type class and the part specified by us form the 'customization options'.&lt;/p&gt;
&lt;p&gt;(please note that it's generally possible to override the default implementations)&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/TemplateMethod.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-creational-patterns" class="anchor" aria-hidden="true" href="#creational-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Creational Patterns&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-abstract-factory--functions-as-data-type-values" class="anchor" aria-hidden="true" href="#abstract-factory--functions-as-data-type-values"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Abstract Factory → functions as data type values&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The abstract factory pattern provides a way to encapsulate a group of individual factories that have a common theme without specifying their concrete classes.
In normal usage, the client software creates a concrete implementation of the abstract factory and then uses the generic interface of the factory to create the concrete objects that are part of the theme.
The client doesn't know (or care) which concrete objects it gets from each of these internal factories, since it uses only the generic interfaces of their products.
This pattern separates the details of implementation of a set of objects from their general usage and relies on object composition, as object creation is implemented in methods exposed in the factory interface.
&lt;a href="https://en.wikipedia.org/wiki/Abstract_factory_pattern" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is a classic example that demonstrates the application of this pattern in the context of a typical problem in object oriented software design:&lt;/p&gt;
&lt;p&gt;The example revolves around a small GUI framework that needs different implementations to render Buttons for different OS Platforms (called WIN and OSX in this example).
A client of the GUI API should work with a uniform API that hides the specifics of the different platforms. The problem then is: how can the  client be provided with a platform specific implementation without explicitely asking for a given implementation and how can we maintain a uniform API that hides the implementation specifics.&lt;/p&gt;
&lt;p&gt;In OO languages like Java the abstract factory pattern would be the canonical answer to this problem:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The client calls an abstract factory &lt;code&gt;GUIFactory&lt;/code&gt; interface to create a &lt;code&gt;Button&lt;/code&gt; by calling &lt;code&gt;createButton() : Button&lt;/code&gt; that somehow chooses (typically by some kind of configuration) which concrete factory has to be used to create concrete &lt;code&gt;Button&lt;/code&gt; instances.&lt;/li&gt;
&lt;li&gt;The concrete classes &lt;code&gt;WinButton&lt;/code&gt; and &lt;code&gt;OSXButton&lt;/code&gt; implement the interface &lt;code&gt;Button&lt;/code&gt; and provide platform specific implementations of &lt;code&gt;paint () : void&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;As the client uses only the interface methods &lt;code&gt;createButton()&lt;/code&gt; and &lt;code&gt;paint()&lt;/code&gt; it does not have to deal with any platform specific code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following diagram depicts the structure of interfaces and classes in this scenario:&lt;/p&gt;
&lt;p&gt;&lt;a target="_blank" rel="noopener noreferrer" href="https://camo.githubusercontent.com/69edd7efc7f7087cc312c23e164180fc37806ee3/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f612f61372f41627374726163745f666163746f72792e7376672f35313770782d41627374726163745f666163746f72792e7376672e706e67"&gt;&lt;img src="https://camo.githubusercontent.com/69edd7efc7f7087cc312c23e164180fc37806ee3/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f612f61372f41627374726163745f666163746f72792e7376672f35313770782d41627374726163745f666163746f72792e7376672e706e67" alt="The abstract Button Factory" data-canonical-src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Abstract_factory.svg/517px-Abstract_factory.svg.png" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In a functional language this kind of problem would be solved quite differently. In FP functions are first class citizens and thus it is much easier to treat function that represent platform specific actions as "normal" values that can be reached around.&lt;/p&gt;
&lt;p&gt;So we could represent a Button type as a data type with a label (holding the text to display on the button) and an &lt;code&gt;IO ()&lt;/code&gt; action that represents the platform specific rendering:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; representation of a Button UI widget&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt;
    &lt;span class="pl-k"&gt;{&lt;/span&gt; &lt;span class="pl-e"&gt;label&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;           &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the text label of the button&lt;/span&gt;
    , &lt;span class="pl-e"&gt;render&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a platform specific rendering action&lt;/span&gt;
    &lt;span class="pl-k"&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Platform specific actions to render a &lt;code&gt;Button&lt;/code&gt; would look like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; rendering a Button for the WIN platform (we just simulate it by printing the label)&lt;/span&gt;
&lt;span class="pl-en"&gt;winPaint&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
winPaint btn &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;winButton: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; label btn

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; rendering a Button for the OSX platform&lt;/span&gt;
&lt;span class="pl-en"&gt;osxPaint&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
osxPaint btn &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;osxButton: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; label btn

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; paint a button by using the Buttons render function&lt;/span&gt;
&lt;span class="pl-en"&gt;paint&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
paint btn&lt;span class="pl-k"&gt;@&lt;/span&gt;(&lt;span class="pl-ent"&gt;Button&lt;/span&gt; _ render) &lt;span class="pl-k"&gt;=&lt;/span&gt; render btn&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(Of course a real implementation would be quite more complex, but we don't care about the nitty gritty details here.)&lt;/p&gt;
&lt;p&gt;With this code we can now create and use concrete Buttons like so:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; button &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Okay&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; winPaint
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt;&lt;span class="pl-k"&gt;type&lt;/span&gt; button
&lt;span class="pl-en"&gt;button&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; paint button
winButton&lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-ent"&gt;Okay&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We created a button with &lt;code&gt;Button "Okay" winPaint&lt;/code&gt;. The field &lt;code&gt;render&lt;/code&gt; of that button instance now holds the function winPaint.
The function &lt;code&gt;paint&lt;/code&gt; now applies this &lt;code&gt;render&lt;/code&gt; function -- i.e. winPaint -- to draw the Button.&lt;/p&gt;
&lt;p&gt;Applying this scheme it is now very simple to create buttons with different &lt;code&gt;render&lt;/code&gt; implementations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a representation of the operating system platform&lt;/span&gt;
&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Platform&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;OSX&lt;/span&gt; | &lt;span class="pl-ent"&gt;WIN&lt;/span&gt; | &lt;span class="pl-ent"&gt;NIX&lt;/span&gt; | &lt;span class="pl-ent"&gt;Other&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; determine Platform by inspecting System.Info.os string&lt;/span&gt;
&lt;span class="pl-en"&gt;platform&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Platform&lt;/span&gt;
platform &lt;span class="pl-k"&gt;=&lt;/span&gt;
  &lt;span class="pl-k"&gt;case&lt;/span&gt; os &lt;span class="pl-k"&gt;of&lt;/span&gt;
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;darwin&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;OSX&lt;/span&gt;
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;mingw32&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;WIN&lt;/span&gt;
    &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;linux&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;   &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;NIX&lt;/span&gt;
    _         &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Other&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; create a button for os platform with label lbl&lt;/span&gt;
&lt;span class="pl-en"&gt;createButton&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Button&lt;/span&gt;
createButton lbl &lt;span class="pl-k"&gt;=&lt;/span&gt;
  &lt;span class="pl-k"&gt;case&lt;/span&gt; platform &lt;span class="pl-k"&gt;of&lt;/span&gt;
    &lt;span class="pl-ent"&gt;OSX&lt;/span&gt;    &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; lbl osxPaint
    &lt;span class="pl-ent"&gt;WIN&lt;/span&gt;    &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; lbl winPaint
    &lt;span class="pl-ent"&gt;NIX&lt;/span&gt;    &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; lbl (&lt;span class="pl-k"&gt;\&lt;/span&gt;btn &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;nixButton: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;   &lt;span class="pl-k"&gt;++&lt;/span&gt; label btn)
    &lt;span class="pl-ent"&gt;Other&lt;/span&gt;  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; lbl (&lt;span class="pl-k"&gt;\&lt;/span&gt;btn &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;otherButton: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; label btn)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function &lt;code&gt;createButton&lt;/code&gt; determines the actual execution environment and accordingly creates platform specific buttons.&lt;/p&gt;
&lt;p&gt;Now we have an API that hides all implementation specifics from the client and allows him to use only &lt;code&gt;createButton&lt;/code&gt; and &lt;code&gt;paint&lt;/code&gt; to work with Buttons for different OS platforms:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;abstractFactoryDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;AbstractFactory -&amp;gt; functions as data type values&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; exit &lt;span class="pl-k"&gt;=&lt;/span&gt; createButton &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Exit&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;            &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; using the "abstract" API to create buttons&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; ok   &lt;span class="pl-k"&gt;=&lt;/span&gt; createButton &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;OK&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    paint ok                                  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; using the "abstract" API to paint buttons&lt;/span&gt;
    paint exit

    paint &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Apple&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; osxPaint           &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; paint a platform specific button&lt;/span&gt;
    paint &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-ent"&gt;Button&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Pi&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;                       &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; paint a user-defined button&lt;/span&gt;
        (&lt;span class="pl-k"&gt;\&lt;/span&gt;btn &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;raspberryButton: &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; label btn)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/AbstractFactory.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-builder--record-syntax-smart-constructor" class="anchor" aria-hidden="true" href="#builder--record-syntax-smart-constructor"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Builder → record syntax, smart constructor&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;The Builder is a design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming. The intent of the Builder design pattern is to separate the construction of a complex object from its representation.&lt;/p&gt;
&lt;p&gt;Quoted from &lt;a href="https://en.wikipedia.org/wiki/Builder_pattern" rel="nofollow"&gt;Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The Builder patterns is frequently used to ease the construction of complex objects by providing a safe and convenient API to client code.
In the following Java example we define a POJO Class &lt;code&gt;BankAccount&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccount&lt;/span&gt; {

    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;int&lt;/span&gt; accountNo;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; name;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; branch;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; balance;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; interestRate;

    &lt;span class="pl-en"&gt;BankAccount&lt;/span&gt;(&lt;span class="pl-k"&gt;int&lt;/span&gt; &lt;span class="pl-v"&gt;accountNo&lt;/span&gt;, &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-v"&gt;name&lt;/span&gt;, &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-v"&gt;branch&lt;/span&gt;, &lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;balance&lt;/span&gt;, &lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;interestRate&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; accountNo;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;name &lt;span class="pl-k"&gt;=&lt;/span&gt; name;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;branch &lt;span class="pl-k"&gt;=&lt;/span&gt; branch;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;balance &lt;span class="pl-k"&gt;=&lt;/span&gt; balance;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; interestRate;
    }

    &lt;span class="pl-k"&gt;@Override&lt;/span&gt;
    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-en"&gt;toString&lt;/span&gt;() {
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;BankAccount {accountNo = &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; accountNo &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;, name = &lt;span class="pl-cce"&gt;\"&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; name
                &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;span class="pl-cce"&gt;\"&lt;/span&gt;, branch = &lt;span class="pl-cce"&gt;\"&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; branch &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;span class="pl-cce"&gt;\"&lt;/span&gt;, balance = &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; balance &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;, interestRate = &lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; interestRate &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;}&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The class provides a package private constructor that takes 5 arguments that are used to fill the instance attributes.
Using constructors with so many arguments is often considered inconvenient and potentially unsafe as certain constraints on the arguments might not be maintained by client code invoking this constructor.&lt;/p&gt;
&lt;p&gt;The typical solution is to provide a Builder class that is responsible for maintaining internal data constraints and providing a robust and convenient API.
In the following example the Builder ensures that a BankAccount must have an accountNo and that non null values are provided for the String attributes:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccountBuilder&lt;/span&gt; {

    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;int&lt;/span&gt; accountNo;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; name;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-smi"&gt;String&lt;/span&gt; branch;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; balance;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;double&lt;/span&gt; interestRate;

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccountBuilder&lt;/span&gt;(&lt;span class="pl-k"&gt;int&lt;/span&gt; &lt;span class="pl-v"&gt;accountNo&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; accountNo;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Dummy Customer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;London&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;;
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; &lt;span class="pl-en"&gt;withAccountNo&lt;/span&gt;(&lt;span class="pl-k"&gt;int&lt;/span&gt; &lt;span class="pl-v"&gt;accountNo&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; accountNo;
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;this&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; &lt;span class="pl-en"&gt;withName&lt;/span&gt;(&lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-v"&gt;name&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;name &lt;span class="pl-k"&gt;=&lt;/span&gt; name;
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;this&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; &lt;span class="pl-en"&gt;withBranch&lt;/span&gt;(&lt;span class="pl-smi"&gt;String&lt;/span&gt; &lt;span class="pl-v"&gt;branch&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;branch &lt;span class="pl-k"&gt;=&lt;/span&gt; branch;
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;this&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; &lt;span class="pl-en"&gt;withBalance&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;balance&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;balance &lt;span class="pl-k"&gt;=&lt;/span&gt; balance;
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;this&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; &lt;span class="pl-en"&gt;withInterestRate&lt;/span&gt;(&lt;span class="pl-k"&gt;double&lt;/span&gt; &lt;span class="pl-v"&gt;interestRate&lt;/span&gt;) {
        &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; interestRate;
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-c1"&gt;this&lt;/span&gt;;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccount&lt;/span&gt; &lt;span class="pl-en"&gt;build&lt;/span&gt;() {
        &lt;span class="pl-k"&gt;return&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccount&lt;/span&gt;(&lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;accountNo, &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;name, &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;branch, &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;balance, &lt;span class="pl-c1"&gt;this&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;interestRate);
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next comes an example of how the builder is used in client code:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccountTest&lt;/span&gt; {

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;main&lt;/span&gt;(&lt;span class="pl-k"&gt;String&lt;/span&gt;[] &lt;span class="pl-v"&gt;args&lt;/span&gt;) {
        &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountTest&lt;/span&gt;()&lt;span class="pl-k"&gt;.&lt;/span&gt;testAccount();
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; &lt;span class="pl-en"&gt;testAccount&lt;/span&gt;() {
        &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt; builder &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; &lt;span class="pl-smi"&gt;BankAccountBuilder&lt;/span&gt;(&lt;span class="pl-c1"&gt;1234&lt;/span&gt;);
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; the builder can provide a dummy instance, that might be used for testing&lt;/span&gt;
        &lt;span class="pl-smi"&gt;BankAccount&lt;/span&gt; account &lt;span class="pl-k"&gt;=&lt;/span&gt; builder&lt;span class="pl-k"&gt;.&lt;/span&gt;build();
        &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(account);
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; the builder provides a fluent API to construct regular instances&lt;/span&gt;
        &lt;span class="pl-smi"&gt;BankAccount&lt;/span&gt; account1 &lt;span class="pl-k"&gt;=&lt;/span&gt;
                 builder&lt;span class="pl-k"&gt;.&lt;/span&gt;withName(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin Mejer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                        .withBranch(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Paris&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;)
                        .withBalance(&lt;span class="pl-c1"&gt;10000&lt;/span&gt;)
                        .withInterestRate(&lt;span class="pl-c1"&gt;2&lt;/span&gt;)
                        .build();

        &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(account1);
    }
}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As we see the Builder can be either used to create dummy instaces that are still safe to use (e.g. for test cases) or by using the &lt;code&gt;withXxx&lt;/code&gt; methods to populate all attributes:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1234&lt;/span&gt;, name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Dummy Customer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;London&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0.0&lt;/span&gt;, interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0.0&lt;/span&gt;}
&lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1234&lt;/span&gt;, name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin Mejer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Paris&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;10000.0&lt;/span&gt;, interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2.0&lt;/span&gt;}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From an API client perspective the Builder pattern can help to provide safe and convenient object construction which is not provided by the Java core language.
As the Builder code is quite a redundant (e.g. having all attributes of the actual instance class) Builders are typically generated (e.g. with &lt;a href="https://projectlombok.org/features/Builder" rel="nofollow"&gt;Lombok&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;In functional languages there is usually no need for the Builder pattern as the languages already provide the necessary infrastructure.&lt;/p&gt;
&lt;p&gt;The following example shows how the above example would be solved in Haskell:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccount&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; &lt;span class="pl-k"&gt;{&lt;/span&gt;
    &lt;span class="pl-e"&gt;accountNo&lt;/span&gt;    &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;
  , &lt;span class="pl-e"&gt;name&lt;/span&gt;         &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
  , &lt;span class="pl-e"&gt;branch&lt;/span&gt;       &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
  , &lt;span class="pl-e"&gt;balance&lt;/span&gt;      &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
  , &lt;span class="pl-e"&gt;interestRate&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Double&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;}&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a "smart constructor" that just needs a unique int to construct a BankAccount&lt;/span&gt;
&lt;span class="pl-en"&gt;buildAccount&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;BankAccount&lt;/span&gt;
buildAccount i &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; i &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Dummy Customer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;London&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;

builderDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; construct a dummmy instance&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; account &lt;span class="pl-k"&gt;=&lt;/span&gt; buildAccount &lt;span class="pl-c1"&gt;1234&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; account
    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; use record syntax to create a modified clone of the dummy instance&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; account1 &lt;span class="pl-k"&gt;=&lt;/span&gt; account {name&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin Mejer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Paris&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;10000&lt;/span&gt;, interestRate&lt;span class="pl-k"&gt;=&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;}
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; account1

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; directly using record syntax to create an instance&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; account2 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {
          accountNo    &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;5678&lt;/span&gt;
        , name         &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
        , branch       &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Reikjavik&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
        , balance      &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1000&lt;/span&gt;
        , interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2.5&lt;/span&gt;
        }
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; account2

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in Ghci:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; builderDemo
&lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1234&lt;/span&gt;, name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Dummy Customer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;London&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0.0&lt;/span&gt;, interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0.0&lt;/span&gt;}
&lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1234&lt;/span&gt;, name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin Mejer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Paris&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;10000.0&lt;/span&gt;, interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2.0&lt;/span&gt;}
&lt;span class="pl-ent"&gt;BankAccount&lt;/span&gt; {accountNo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;5678&lt;/span&gt;, name &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Marjin Mejer&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, branch &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Reikjavik&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, balance &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1000.0&lt;/span&gt;, interestRate &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2.5&lt;/span&gt;}&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Builder.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-functional-programming-patterns" class="anchor" aria-hidden="true" href="#functional-programming-patterns"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Functional Programming Patterns&lt;/h2&gt;
&lt;p&gt;The patterns presented in this chapter all stem from functional languages.
That is, they have been first developed in functional languages like Lisp, Scheme or Haskell and have later been adopted in other languages.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-higher-order-functions" class="anchor" aria-hidden="true" href="#higher-order-functions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Higher Order Functions&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In mathematics and computer science, a higher-order function is a function that does at least one of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;takes one or more functions as arguments (i.e. procedural parameters),&lt;/li&gt;
&lt;li&gt;returns a function as its result.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;All other functions are first-order functions. In mathematics higher-order functions are also termed operators or functionals. The differential operator in calculus is a common example since it maps a function to its derivative, also a function.
&lt;a href="https://en.wikipedia.org/wiki/Higher-order_function" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We have already talked about higher order functions throughout this study – in particular in the section on the &lt;a href="#strategy--functor"&gt;Strategy Pattern&lt;/a&gt;. But as higher order functions are such a central pillar of the strength of functional languages I'd like to cover them in some more depths.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-higher-order-functions-taking-functions-as-arguments" class="anchor" aria-hidden="true" href="#higher-order-functions-taking-functions-as-arguments"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Higher Order Functions taking functions as arguments&lt;/h4&gt;
&lt;p&gt;Let's have a look at two typical functions that work on lists; &lt;code&gt;sum&lt;/code&gt; is calculating the sum of all values in a list, &lt;code&gt;product&lt;/code&gt; likewise is computing the product of all values in the list:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;sum&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
&lt;span class="pl-c1"&gt;sum&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;
&lt;span class="pl-c1"&gt;sum&lt;/span&gt; (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-c1"&gt;sum&lt;/span&gt; xs

&lt;span class="pl-en"&gt;product&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
&lt;span class="pl-c1"&gt;product&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
&lt;span class="pl-c1"&gt;product&lt;/span&gt; (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;*&lt;/span&gt; &lt;span class="pl-c1"&gt;product&lt;/span&gt; xs

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;sum&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
&lt;span class="pl-c1"&gt;55&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;product&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
&lt;span class="pl-c1"&gt;3628800&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;These two functions &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt; have exactly the same structure. They both apply a mathematical operation &lt;code&gt;(+)&lt;/code&gt; or &lt;code&gt;(*)&lt;/code&gt; on a list by handling two cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;providing a neutral (or unit) value in the empty list &lt;code&gt;[]&lt;/code&gt; case and&lt;/li&gt;
&lt;li&gt;applying the mathematical operation and recursing into the tail of the list in the &lt;code&gt;(x:xs)&lt;/code&gt; case.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The two functions differ only in the concrete value for the empty list &lt;code&gt;[]&lt;/code&gt; and the concrete mathematical operation to be applied in the &lt;code&gt;(x:xs)&lt;/code&gt; case.&lt;/p&gt;
&lt;p&gt;In order to avoid repetetive code when writing functions that work on lists, wise functional programmers have invented &lt;code&gt;fold&lt;/code&gt; functions:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;foldr&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
&lt;span class="pl-c1"&gt;foldr&lt;/span&gt; fn z &lt;span class="pl-c1"&gt;[]&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; z
&lt;span class="pl-c1"&gt;foldr&lt;/span&gt; fn z (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; fn x y
    &lt;span class="pl-k"&gt;where&lt;/span&gt; y &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; fn z xs&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This &lt;em&gt;higher order function&lt;/em&gt; takes a function &lt;code&gt;fn&lt;/code&gt; of type &lt;code&gt;(a -&amp;gt; b -&amp;gt; b)&lt;/code&gt;, a value &lt;code&gt;z&lt;/code&gt; for the &lt;code&gt;[]&lt;/code&gt; case and the actual list as parameters.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;in the &lt;code&gt;[]&lt;/code&gt; case the value &lt;code&gt;z&lt;/code&gt; is returned&lt;/li&gt;
&lt;li&gt;in the &lt;code&gt;(x:xs)&lt;/code&gt; case the  function &lt;code&gt;fn&lt;/code&gt; is applied to &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, where &lt;code&gt;y&lt;/code&gt; is computed by recursively applying &lt;code&gt;foldr fn z&lt;/code&gt; on the tail of the list &lt;code&gt;xs&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We can use &lt;code&gt;foldr&lt;/code&gt; to define functions like &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;product&lt;/code&gt; much more terse:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;sum'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
sum' &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;

&lt;span class="pl-en"&gt;product'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
product' &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;foldr&lt;/code&gt; can also be used to define &lt;em&gt;higher order functions&lt;/em&gt; on lists like &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; much denser than with the naive approach of writing pattern matching equations for &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;(x:xs)&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; naive approach:&lt;/span&gt;
&lt;span class="pl-en"&gt;map&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;b&lt;/span&gt;]
&lt;span class="pl-c1"&gt;map&lt;/span&gt; _ &lt;span class="pl-c1"&gt;[]&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;
&lt;span class="pl-c1"&gt;map&lt;/span&gt; f (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; f x &lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt; f xs

&lt;span class="pl-en"&gt;filter&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
&lt;span class="pl-c1"&gt;filter&lt;/span&gt; _ &lt;span class="pl-c1"&gt;[]&lt;/span&gt;     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;
&lt;span class="pl-c1"&gt;filter&lt;/span&gt; p (x&lt;span class="pl-k"&gt;:&lt;/span&gt;xs) &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; p x &lt;span class="pl-k"&gt;then&lt;/span&gt; x &lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-c1"&gt;filter&lt;/span&gt; p xs &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-c1"&gt;filter&lt;/span&gt; p xs

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; wise functional programmers approach:&lt;/span&gt;
&lt;span class="pl-en"&gt;map'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;b&lt;/span&gt;]
map' f &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; (&lt;span class="pl-en"&gt;(:)&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; f) &lt;span class="pl-c1"&gt;[]&lt;/span&gt;

&lt;span class="pl-en"&gt;filter'&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Bool&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
filter' p &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;x xs &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; p x &lt;span class="pl-k"&gt;then&lt;/span&gt; x &lt;span class="pl-k"&gt;:&lt;/span&gt; xs &lt;span class="pl-k"&gt;else&lt;/span&gt; xs) &lt;span class="pl-c1"&gt;[]&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt; (&lt;span class="pl-k"&gt;*&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;) [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;,&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;14&lt;/span&gt;,&lt;span class="pl-c1"&gt;16&lt;/span&gt;,&lt;span class="pl-c1"&gt;18&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;]
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;filter&lt;/span&gt; &lt;span class="pl-c1"&gt;even&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;10&lt;/span&gt;]
[&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The idea to use &lt;code&gt;fold&lt;/code&gt; operations to provide a generic mechanism to fold lists can be extented to cover other algebraic data types as well. Let's take a binary tree as an example:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Leaf&lt;/span&gt;
            | &lt;span class="pl-ent"&gt;Node&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; (&lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) (&lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)

&lt;span class="pl-en"&gt;sumTree&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
sumTree &lt;span class="pl-ent"&gt;Leaf&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;
sumTree (&lt;span class="pl-ent"&gt;Node&lt;/span&gt; x l r) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;+&lt;/span&gt; sumTree l &lt;span class="pl-k"&gt;+&lt;/span&gt; sumTree r

&lt;span class="pl-en"&gt;productTree&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
productTree &lt;span class="pl-ent"&gt;Leaf&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
productTree (&lt;span class="pl-ent"&gt;Node&lt;/span&gt; x l r) &lt;span class="pl-k"&gt;=&lt;/span&gt; x &lt;span class="pl-k"&gt;*&lt;/span&gt; sumTree l &lt;span class="pl-k"&gt;*&lt;/span&gt; sumTree r

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; sumTree tree
&lt;span class="pl-c1"&gt;9&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; productTree tree
&lt;span class="pl-c1"&gt;24&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The higher order &lt;code&gt;foldTree&lt;/code&gt; operation takes a function &lt;code&gt;fn&lt;/code&gt; of type &lt;code&gt;(a -&amp;gt; b -&amp;gt; b)&lt;/code&gt;, a value &lt;code&gt;z&lt;/code&gt; for the &lt;code&gt;Leaf&lt;/code&gt; case and the actual &lt;code&gt;Tree a&lt;/code&gt; as parameters:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;foldTree&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;
foldTree fn z &lt;span class="pl-ent"&gt;Leaf&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; z
foldTree fn z (&lt;span class="pl-ent"&gt;Node&lt;/span&gt; a left right) &lt;span class="pl-k"&gt;=&lt;/span&gt; foldTree fn z' left &lt;span class="pl-k"&gt;where&lt;/span&gt;
   z'  &lt;span class="pl-k"&gt;=&lt;/span&gt; fn a z''
   z'' &lt;span class="pl-k"&gt;=&lt;/span&gt; foldTree fn z right&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The sum and product functions can now elegantly be defined by making use of &lt;code&gt;foldTree&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;sumTree' &lt;span class="pl-k"&gt;=&lt;/span&gt; foldTree &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;

productTree' &lt;span class="pl-k"&gt;=&lt;/span&gt; foldTree &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the family of &lt;code&gt;fold&lt;/code&gt; operation is useful for many data types the GHC compiler even provides a special pragma that allows automatic provisioning of this functionality by declaring the data type as an instance of the type class &lt;code&gt;Foldable&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;{-# &lt;span class="pl-k"&gt;LANGUAGE&lt;/span&gt; DeriveFoldable #-}

&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Leaf&lt;/span&gt;
            | &lt;span class="pl-ent"&gt;Node&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; (&lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) (&lt;span class="pl-en"&gt;Tree&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Foldable&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
&lt;span class="pl-k"&gt;&lt;span class="pl-c1"&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; tree
&lt;span class="pl-c1"&gt;9&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Apart from several &lt;code&gt;fold&lt;/code&gt; operations the &lt;code&gt;Foldable&lt;/code&gt; type class also provides useful functions like &lt;code&gt;maximum&lt;/code&gt; and &lt;code&gt;minimum&lt;/code&gt;: &lt;a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/Prelude.html#t:Foldable" rel="nofollow"&gt;Foldable documentation on hackage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;In this section we have seen how higher order functions that take functions as parameters can be very useful tools to provide generic algorithmic templates that can be applied in a wide range of situations.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-origami-programming-style" class="anchor" aria-hidden="true" href="#origami-programming-style"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Origami programming style&lt;/h5&gt;
&lt;p&gt;Mathematicians love symmetry. So it comes with littly surprise that the Haskell standard library &lt;code&gt;Data.List&lt;/code&gt; provides a dual to &lt;code&gt;foldr&lt;/code&gt;: the higher order function &lt;code&gt;unfoldr&lt;/code&gt;.
The function &lt;code&gt;foldr&lt;/code&gt; allows to project a list of values on a single value. &lt;code&gt;unfoldr&lt;/code&gt; allows to create a list of values starting from an initial value:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;unfoldr&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-smi"&gt;b&lt;/span&gt;)) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
unfoldr f u &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;case&lt;/span&gt; f u &lt;span class="pl-k"&gt;of&lt;/span&gt;
    &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;     &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;[]&lt;/span&gt;
    &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (x, v) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; x&lt;span class="pl-k"&gt;:&lt;/span&gt;(unfoldr f v)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This mechanism can be used to generate finite and infinite lists:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; a list [10..0]&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; unfoldr (&lt;span class="pl-k"&gt;\&lt;/span&gt;n &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; n&lt;span class="pl-k"&gt;==&lt;/span&gt;&lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (n, n&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;)) &lt;span class="pl-c1"&gt;10&lt;/span&gt;
[&lt;span class="pl-c1"&gt;10&lt;/span&gt;,&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; the list of all fibonacci numbers&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; fibs &lt;span class="pl-k"&gt;=&lt;/span&gt; unfoldr (&lt;span class="pl-k"&gt;\&lt;/span&gt;(a, b) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (a, (b, a&lt;span class="pl-k"&gt;+&lt;/span&gt;b))) (&lt;span class="pl-c1"&gt;0&lt;/span&gt;, &lt;span class="pl-c1"&gt;1&lt;/span&gt;)
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;20&lt;/span&gt; fibs
[&lt;span class="pl-c1"&gt;0&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;13&lt;/span&gt;,&lt;span class="pl-c1"&gt;21&lt;/span&gt;,&lt;span class="pl-c1"&gt;34&lt;/span&gt;,&lt;span class="pl-c1"&gt;55&lt;/span&gt;,&lt;span class="pl-c1"&gt;89&lt;/span&gt;,&lt;span class="pl-c1"&gt;144&lt;/span&gt;,&lt;span class="pl-c1"&gt;233&lt;/span&gt;,&lt;span class="pl-c1"&gt;377&lt;/span&gt;,&lt;span class="pl-c1"&gt;610&lt;/span&gt;,&lt;span class="pl-c1"&gt;987&lt;/span&gt;,&lt;span class="pl-c1"&gt;1597&lt;/span&gt;,&lt;span class="pl-c1"&gt;2584&lt;/span&gt;,&lt;span class="pl-c1"&gt;4181&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;unfoldr&lt;/code&gt; can also be used to formulate algorithms like bubble sort in quite a dense form:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; bubble out the minimum element of a list:&lt;/span&gt;
&lt;span class="pl-en"&gt;bubble&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt;, [&lt;span class="pl-smi"&gt;a&lt;/span&gt;])
bubble &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; step &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    step x &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (x, &lt;span class="pl-c1"&gt;[]&lt;/span&gt;)
    step x (&lt;span class="pl-ent"&gt;Just&lt;/span&gt; (y, ys))
        &lt;span class="pl-k"&gt;|&lt;/span&gt; x &lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt; y     &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (x, y&lt;span class="pl-k"&gt;:&lt;/span&gt;ys)
        &lt;span class="pl-k"&gt;|&lt;/span&gt; &lt;span class="pl-c1"&gt;otherwise&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (y, x&lt;span class="pl-k"&gt;:&lt;/span&gt;ys)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute minimum, cons it with the minimum of the remaining list and so forth&lt;/span&gt;
&lt;span class="pl-en"&gt;bubbleSort&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
bubbleSort &lt;span class="pl-k"&gt;=&lt;/span&gt; unfoldr bubble&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfolds produce data structures, and folds consume them. It is thus quite natural to compose these two operations.  The pattern of an unfold followed by a fold (called &lt;a href="https://en.wikipedia.org/wiki/Hylomorphism_(computer_science)" rel="nofollow"&gt;&lt;em&gt;hylomorphism&lt;/em&gt;&lt;/a&gt; is fairly common. As a simple example we define the factorial function with our new tools:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;factorial &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; unfoldr (&lt;span class="pl-k"&gt;\&lt;/span&gt;n &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; n &lt;span class="pl-k"&gt;==&lt;/span&gt;&lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt; &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; (n, n&lt;span class="pl-k"&gt;-&lt;/span&gt;&lt;span class="pl-c1"&gt;1&lt;/span&gt;))&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;unfold&lt;/code&gt; part generates a list of integers &lt;code&gt;[1..n]&lt;/code&gt; and the &lt;code&gt;foldr&lt;/code&gt; part reduces this list by computing the product &lt;code&gt;[1..n]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But hylomorphisms are not limited to ivory tower examples: a typical compiler that takes some source code as input to generate an abstract syntax tree (unfolding) from which it then generates the object code of the target platform (folding) is quite a practical example of the same concept.&lt;/p&gt;
&lt;p&gt;One interesting properties of hylomorphisms is that they may be fused – the intermediate data structure needs not actually be constructed. This technique is called &lt;em&gt;deforestation&lt;/em&gt; and can be done automatically by a compiler.&lt;/p&gt;
&lt;p&gt;Compressing data and uncompressing it later may be understood as a sequence of first folding and then unfolding. Algorithms that apply this pattern have been coined &lt;a href="https://patternsinfp.wordpress.com/2017/10/04/metamorphisms/" rel="nofollow"&gt;&lt;em&gt;metamorphism&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The programming style that uses combinations of higher order functions like fold and unfold operations on algebraic data structure has been dubbed &lt;a href="https://www.cs.ox.ac.uk/jeremy.gibbons/publications/origami.pdf" rel="nofollow"&gt;&lt;em&gt;Origami Programming&lt;/em&gt;&lt;/a&gt; after the Japanese art form based on paper folds.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-higher-order-functions-returning-functions" class="anchor" aria-hidden="true" href="#higher-order-functions-returning-functions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Higher Order Functions returning functions&lt;/h4&gt;
&lt;p&gt;Functions returning new functions are ubiqituous in functional programming as well.
If we look at a simple binary arithmetic functions like &lt;code&gt;(+)&lt;/code&gt; or &lt;code&gt;(*)&lt;/code&gt; it would be quite natural to think that they have a type signature like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;(+)&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But by inspecting the signature in GHCi (with &lt;code&gt;:t (+)&lt;/code&gt;) we see that the actual signature is&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;(+)&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is because in Haskell all functions are considered curried: That is, all functions in Haskell take just one argument. The curried form is usually more convenient because it allows &lt;a href="https://github.com/thma/LtuPatternFactory#dependency-injection--parameter-binding-partial-application"&gt;partial application&lt;/a&gt;. It allows us to create new functions by applying the original function to a subset of the formal parameters:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; double &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;(*)&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt;t double
&lt;span class="pl-en"&gt;double&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; double &lt;span class="pl-c1"&gt;7&lt;/span&gt;
&lt;span class="pl-c1"&gt;14&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So even if we read a signature like &lt;code&gt;Int -&amp;gt; Int -&amp;gt; Int&lt;/code&gt; informally as "takes two &lt;code&gt;Int&lt;/code&gt;s and returns an &lt;code&gt;Int&lt;/code&gt;", It actually should be understood as &lt;code&gt;Int -&amp;gt; (Int -&amp;gt; Int)&lt;/code&gt; which really says "takes an &lt;code&gt;Int&lt;/code&gt; and returns a function of type &lt;code&gt;Int -&amp;gt; Int&lt;/code&gt;".&lt;/p&gt;
&lt;p&gt;Apart from this implicit occurrence of "functions returning functions" there are also more explicit use cases of this pattern. I'll illustrate this with a simple generator for key/value mapping functions.&lt;/p&gt;
&lt;p&gt;We start by defing a function type &lt;code&gt;Lookup&lt;/code&gt; that can be used to define functions mapping keys to values:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Lookup is a function type from a key to a Maybe value:&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-smi"&gt;key&lt;/span&gt; &lt;span class="pl-smi"&gt;value&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-smi"&gt;key&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Maybe&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;value&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a lookup function that always returns Nothing&lt;/span&gt;
&lt;span class="pl-en"&gt;nada&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt;
nada _ &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a function that knows it's abc...&lt;/span&gt;
&lt;span class="pl-en"&gt;abc&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt;
abc &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
abc &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;
abc &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;c&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;3&lt;/span&gt;
abc _   &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we write a &lt;code&gt;Lookup&lt;/code&gt; function generator &lt;code&gt;put&lt;/code&gt; that adds a new key to value mapping to an existing lookup function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; put returns a new Lookup function based on a key, a value and an existing lookup function:&lt;/span&gt;
&lt;span class="pl-en"&gt;put&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Eq&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-smi"&gt;k&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt;
put k v &lt;span class="pl-c1"&gt;lookup&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt;
    &lt;span class="pl-k"&gt;\&lt;/span&gt;key &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;if&lt;/span&gt; key &lt;span class="pl-k"&gt;==&lt;/span&gt; k
            &lt;span class="pl-k"&gt;then&lt;/span&gt; &lt;span class="pl-ent"&gt;Just&lt;/span&gt; v
            &lt;span class="pl-k"&gt;else&lt;/span&gt; &lt;span class="pl-c1"&gt;lookup&lt;/span&gt; key

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get &lt;span class="pl-k"&gt;=&lt;/span&gt; put &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt; nada

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt;t get
&lt;span class="pl-en"&gt;get&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Lookup&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;v&lt;/span&gt;

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;

ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can now use &lt;code&gt;put&lt;/code&gt; to stack more key value mappings onto the &lt;code&gt;get&lt;/code&gt; function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get' &lt;span class="pl-k"&gt;=&lt;/span&gt; put &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; get
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get' &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;a&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get' &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;b&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Just&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; get' &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;c&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;Nothing&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A framework for symbolic derivation of functions in calculus would be another possible application of this approach, but as it involves several more advanced features (like Template Haskell and tagged types) I won't cover it here but just point the fearless reader directly to the sourcecode: &lt;a href="http://hackage.haskell.org/package/liboleg-2010.1.10.0/docs/src/Data-Symbolic-Diff.html" rel="nofollow"&gt;A symbolic differentiator for a subset of Haskell functions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/HigherOrder.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-map-reduce" class="anchor" aria-hidden="true" href="#map-reduce"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Map Reduce&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;MapReduce is a programming model and an associated implementation for processing and generating large data sets. Users specify a map function that processes a key/value pair to generate a set of intermediate key/value pairs, and a reduce function that merges all intermediate values associated with the same intermediate key.&lt;/p&gt;
&lt;p&gt;Our abstraction is inspired by the map and reduce primitives present in Lisp and many other functional languages.
&lt;a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/16cb30b4b92fd4989b8619a61752a2387c6dd474.pdf" rel="nofollow"&gt;Quoted from Google Research&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this section I'm featuring one of the canonical examples for MapReduce: counting word frequencies in a large text.&lt;/p&gt;
&lt;p&gt;Let's start with a function &lt;code&gt;stringToWordCountMap&lt;/code&gt; that takes a string as input and creates the respective word frequency map:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a key value map, mapping a word to a frequency&lt;/span&gt;
&lt;span class="pl-k"&gt;newtype&lt;/span&gt; &lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (&lt;span class="pl-en"&gt;Map&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;) &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; creating a word frequency map from a String.&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt;   To ease readability I'm using the (&amp;gt;&amp;gt;&amp;gt;) operator, which is just an inverted (.): f &amp;gt;&amp;gt;&amp;gt; g == g . f&lt;/span&gt;
&lt;span class="pl-en"&gt;stringToWordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt;
stringToWordCountMap &lt;span class="pl-k"&gt;=&lt;/span&gt;
  &lt;span class="pl-c1"&gt;map&lt;/span&gt; toLower &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;words&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; convert to lowercase and split into a list of words&lt;/span&gt;
  sort &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; group &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;         &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; sort the words alphabetically and group all equal words to sub-lists&lt;/span&gt;
  &lt;span class="pl-c1"&gt;map&lt;/span&gt; (&lt;span class="pl-c1"&gt;head&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;amp;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="pl-c1"&gt;length&lt;/span&gt;) &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;  &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; for each of those list of grouped words: form a pair (word, frequency)&lt;/span&gt;
  &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;fromList &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;           &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; create a Map from the list of (word, frequency) pairs&lt;/span&gt;
  &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt;               &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; wrap as WordCountMap&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; stringToWordCountMap &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world World&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;)])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In a MapReduce scenario we would have a huge text as input that would take ages to process on a single core.
So the idea is to split up the huge text into smaller chunks that can than be processed in parallel on multiple cores or even large machine clusters.&lt;/p&gt;
&lt;p&gt;Let's assume we have split a text into two chunks. We could then use &lt;code&gt;map&lt;/code&gt; to create a &lt;code&gt;WordCountMap&lt;/code&gt; for both chunks:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt; stringToWordCountMap [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world World&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out of this world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
[&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;)])
,&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;of&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;this&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;)])]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This was the &lt;em&gt;Map&lt;/em&gt; part. Now to &lt;em&gt;Reduce&lt;/em&gt;.
In Order to get a comprehensive word frequency map we have to merge those individual &lt;code&gt;WordCountMap&lt;/code&gt;s into one.
The merging must form a union of all entries from all individual maps. This union must also ensure that the frequencies from the indivual maps are added up properly in the resulting map. We will use the &lt;code&gt;Map.unionWith&lt;/code&gt; function to achieve this:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; merges a list of individual WordCountMap into single one.&lt;/span&gt;
&lt;span class="pl-en"&gt;reduceWordCountMaps&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; [&lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt;
reduceWordCountMaps &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; (&lt;span class="pl-c1"&gt;Map.&lt;/span&gt;unionWith &lt;span class="pl-en"&gt;(+)&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; coerce) empty

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; reduceWordCountMaps it
&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;of&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;this&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;)])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have just performed a manual map reduce operation! We can now take these ingredients to write a generic MapReduce function:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;simpleMapReduce&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt;
     (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;)   &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; map function&lt;/span&gt;
  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; ([&lt;span class="pl-smi"&gt;b&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; reduce function&lt;/span&gt;
  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; list to map over&lt;/span&gt;
  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;          &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; result&lt;/span&gt;
simpleMapReduce mapFunc reduceFunc &lt;span class="pl-k"&gt;=&lt;/span&gt; reduceFunc &lt;span class="pl-k"&gt;.&lt;/span&gt; &lt;span class="pl-c1"&gt;map&lt;/span&gt; mapFunc

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; simpleMapReduce stringToWordCountMap reduceWordCountMaps [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world World&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out of this world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;of&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;this&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;)])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What I have shown so far just demonstrates the general mechanism of chaining &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; functions without implying any parallel execution.
Essentially we are chaining a &lt;code&gt;map&lt;/code&gt; with a &lt;code&gt;fold&lt;/code&gt; (i.e. reduction) function. In the Haskell base library there is a higher order function &lt;code&gt;foldMap&lt;/code&gt; that covers exactly this pattern of chaining. Please note that &lt;code&gt;foldMap&lt;/code&gt;does only a single traversal of the foldable data structure. It fuses the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; phase into a single one by function composition of &lt;code&gt;mappend&lt;/code&gt; and the mapping function &lt;code&gt;f&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Map each element of the structure to a monoid,&lt;/span&gt;
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and combine the results.&lt;/span&gt;
&lt;span class="pl-en"&gt;foldMap&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Foldable&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;t&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;m&lt;/span&gt;
&lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; f &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;foldr&lt;/span&gt; (&lt;span class="pl-c1"&gt;mappend&lt;/span&gt; &lt;span class="pl-k"&gt;.&lt;/span&gt; f) &lt;span class="pl-c1"&gt;mempty&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This signature requires that our type &lt;code&gt;WordCountMap&lt;/code&gt; must be a &lt;code&gt;Monoid&lt;/code&gt; in order to allow merging of multiple &lt;code&gt;WordCountMaps&lt;/code&gt; by using &lt;code&gt;mappend&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Semigroup&lt;/span&gt; &lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; a &lt;span class="pl-k"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; b &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;unionWith &lt;span class="pl-en"&gt;(+)&lt;/span&gt; a b
&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Monoid&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    &lt;span class="pl-c1"&gt;mempty&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; &lt;span class="pl-c1"&gt;Map.&lt;/span&gt;empty&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That's all we need to use &lt;code&gt;foldMap&lt;/code&gt; to achieve a MapReduce:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;foldMap&lt;/span&gt; stringToWordCountMap [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world World&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out of this world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;of&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;this&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;)])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From what I have shown so far it's easy to see that the &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; phases of the word frequency computation are candidates for heavily parallelized processing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The generation of word frequency maps for the text chunks can be done in parallel. There are no shared data or other dependencies between those executions.&lt;/li&gt;
&lt;li&gt;The reduction of the maps can start in parallel (that is we don't have to wait to start reduction until all individual maps are computed) and the reduction itself can also be parallelized.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The calculation of word frequencies is a candidate for a parallel MapReduce because the addition operation used to accumulate the word frequencies is &lt;em&gt;associatve&lt;/em&gt; and &lt;em&gt;commutative&lt;/em&gt;:
&lt;em&gt;The order of execution doesn't affect the final result&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;So actually our data type &lt;code&gt;WordCountMap&lt;/code&gt; is not only a &lt;code&gt;Monoid&lt;/code&gt; (which requires an &lt;em&gt;associative&lt;/em&gt; binary operation) but even a &lt;a href="https://en.wikipedia.org/wiki/Monoid#Commutative_monoid" rel="nofollow"&gt;&lt;em&gt;commutative Monoid&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So our conclusion: if the intermediary key/value map for the data analytics task at hand forms a &lt;em&gt;commutative monoid&lt;/em&gt; then it is a candidate for parallel MapReduce. See also &lt;a href="https://pdfs.semanticscholar.org/0498/3a1c0d6343e21129aaffca2a1b3eec419523.pdf" rel="nofollow"&gt;An Algebra for Distributed Big Data Analytics&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Haskell provides a package &lt;code&gt;parallel&lt;/code&gt; for defining parallel executions in a rather declarative way.
Here is what a parallelized MapReduce looks like when using this package:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a MapReduce using the Control.Parallel package to denote parallel execution&lt;/span&gt;
&lt;span class="pl-en"&gt;parMapReduce&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; ([&lt;span class="pl-smi"&gt;b&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;c&lt;/span&gt;
parMapReduce mapFunc reduceFunc input &lt;span class="pl-k"&gt;=&lt;/span&gt;
    mapResult &lt;span class="pl-k"&gt;`pseq`&lt;/span&gt; reduceResult
    &lt;span class="pl-k"&gt;where&lt;/span&gt; mapResult    &lt;span class="pl-k"&gt;=&lt;/span&gt; parMap rseq mapFunc input
          reduceResult &lt;span class="pl-k"&gt;=&lt;/span&gt; reduceFunc mapResult &lt;span class="pl-k"&gt;`using`&lt;/span&gt; rseq

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; parMapReduce stringToWordCountMap reduceWordCountMaps [&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello world World&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out of this world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;]
&lt;span class="pl-ent"&gt;WordCountMap&lt;/span&gt; (fromList [(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hello&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;of&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;out&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;this&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;1&lt;/span&gt;),(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;world&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;)])&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For more details see &lt;a href="http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html" rel="nofollow"&gt;Real World Haskell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/MapReduce.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-lazy-evaluation" class="anchor" aria-hidden="true" href="#lazy-evaluation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lazy Evaluation&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In programming language theory, lazy evaluation, or call-by-need is an evaluation strategy which delays the evaluation of an expression until its value is needed (non-strict evaluation) and which also avoids repeated evaluations (sharing). The sharing can reduce the running time of certain functions by an exponential factor over other non-strict evaluation strategies, such as call-by-name.&lt;/p&gt;
&lt;p&gt;The benefits of lazy evaluation include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The ability to define control flow (structures) as abstractions instead of primitives.&lt;/li&gt;
&lt;li&gt;The ability to define potentially infinite data structures. This allows for more straightforward implementation of some algorithms.&lt;/li&gt;
&lt;li&gt;Performance increases by avoiding needless calculations, and avoiding error conditions when evaluating compound expressions.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let's start with a short snippet from a Java program:&lt;/p&gt;
&lt;div class="highlight highlight-source-java"&gt;&lt;pre&gt;    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; a non-terminating computation aka _|_ or bottom&lt;/span&gt;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-smi"&gt;Void&lt;/span&gt; bottom() {
        &lt;span class="pl-k"&gt;return&lt;/span&gt; bottom();
    }

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; the K combinator, K x y returns x&lt;/span&gt;
    &lt;span class="pl-k"&gt;private&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;&lt;span class="pl-smi"&gt;A&lt;/span&gt;, &lt;span class="pl-smi"&gt;B&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;A&lt;/span&gt; k(&lt;span class="pl-smi"&gt;A&lt;/span&gt; x, &lt;span class="pl-smi"&gt;B&lt;/span&gt; y) {
        &lt;span class="pl-k"&gt;return&lt;/span&gt; x;
    }

    &lt;span class="pl-k"&gt;public&lt;/span&gt; &lt;span class="pl-k"&gt;static&lt;/span&gt; &lt;span class="pl-k"&gt;void&lt;/span&gt; main(&lt;span class="pl-k"&gt;String&lt;/span&gt;[] args) {
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; part 1&lt;/span&gt;
        &lt;span class="pl-k"&gt;if&lt;/span&gt; (&lt;span class="pl-c1"&gt;true&lt;/span&gt;) {
            &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(&lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;21 is only half the truth&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;);
        } &lt;span class="pl-k"&gt;else&lt;/span&gt; {
            bottom();
        }

        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;//&lt;/span&gt; part 2&lt;/span&gt;
        &lt;span class="pl-smi"&gt;System&lt;/span&gt;&lt;span class="pl-k"&gt;.&lt;/span&gt;out&lt;span class="pl-k"&gt;.&lt;/span&gt;println(k (&lt;span class="pl-c1"&gt;42&lt;/span&gt;, bottom()));
    }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What is the expected output of running &lt;code&gt;main&lt;/code&gt;?
In part 1 we expect to see the text "21 is only half the truth" on the console. The else part of the &lt;code&gt;if&lt;/code&gt; statement will never be executed (thus avoiding the endless loop of calling &lt;code&gt;bottom()&lt;/code&gt;) as &lt;code&gt;true&lt;/code&gt; is always true.&lt;/p&gt;
&lt;p&gt;But what will happen in part 2?
If the Java compiler would be clever it could determine that &lt;code&gt;k (x, y)&lt;/code&gt; will never need to evaluate &lt;code&gt;y&lt;/code&gt; as is always returns just &lt;code&gt;x&lt;/code&gt;. In this case we should see a 42 printed to the console.&lt;/p&gt;
&lt;p&gt;But Java Method calls have eager evaluation semantics.
So will just see a &lt;code&gt;StackOverflowError&lt;/code&gt;...&lt;/p&gt;
&lt;p&gt;In a non-strict (or lazy) language like Haskell this will work out much smoother:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; bottom, a computation which never completes successfully, aka as _|_&lt;/span&gt;
&lt;span class="pl-en"&gt;bottom&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
bottom &lt;span class="pl-k"&gt;=&lt;/span&gt; bottom

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; the K combinator which drop its second argument (k x y = x)&lt;/span&gt;
&lt;span class="pl-en"&gt;k&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;b&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
k x _ &lt;span class="pl-k"&gt;=&lt;/span&gt; x

&lt;span class="pl-en"&gt;infinityDemo&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
infinityDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
  &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; k &lt;span class="pl-c1"&gt;21&lt;/span&gt; &lt;span class="pl-c1"&gt;undefined&lt;/span&gt; &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; evaluating undefined would result in a runtime error&lt;/span&gt;
  &lt;span class="pl-c1"&gt;print&lt;/span&gt; &lt;span class="pl-k"&gt;$&lt;/span&gt; k &lt;span class="pl-c1"&gt;42&lt;/span&gt; bottom    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; evaluating botoom would result in an endless loop&lt;/span&gt;
  &lt;span class="pl-c1"&gt;putStrLn&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Haskell being a non-strict language the arguments of &lt;code&gt;k&lt;/code&gt; are not evaluated when calling the function.
thus in &lt;code&gt;k 21 undefined&lt;/code&gt; and &lt;code&gt;k 42 bottom&lt;/code&gt; the second arguments &lt;code&gt;undefined&lt;/code&gt; and &lt;code&gt;bottom&lt;/code&gt; are simply dropped and never evaluated.&lt;/p&gt;
&lt;p&gt;The Haskell laziness can sometimes be tricky to deal with but it has also some huge benefits when dealing with infinite data structures.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; a list of *all* natural numbers&lt;/span&gt;
&lt;span class="pl-en"&gt;ints&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Num&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
ints &lt;span class="pl-k"&gt;=&lt;/span&gt; from &lt;span class="pl-c1"&gt;1&lt;/span&gt;
  &lt;span class="pl-k"&gt;where&lt;/span&gt;
    from n &lt;span class="pl-k"&gt;=&lt;/span&gt; n &lt;span class="pl-k"&gt;:&lt;/span&gt; from (n &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is a recursive definition of a list holding all natural numbers.
As this recursion has no termination criteria it will never terminate!&lt;/p&gt;
&lt;p&gt;What will happen when we start to use &lt;code&gt;ints&lt;/code&gt; in our code?&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; ints
[&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case we have not been greedy and just asked for a finite subset of ints. The Haskell runtime thus does not fully evaluate &lt;code&gt;ints&lt;/code&gt; but only as many elements as we aked for.&lt;/p&gt;
&lt;p&gt;These kind of generator functions (also known as &lt;a href="https://wiki.haskell.org/Constant_applicative_form" rel="nofollow"&gt;CAFs&lt;/a&gt; for Constant Applicative Forms) can be very useful to define lazy streams of infinite data.&lt;/p&gt;
&lt;p&gt;Haskell even provides some more syntactic sugar to ease the definitions of such CAFs. So for instance our &lt;code&gt;ints&lt;/code&gt; function could be written as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; ints &lt;span class="pl-k"&gt;=&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;]
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; ints
[&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This feature is called &lt;em&gt;arithmetic sequences&lt;/em&gt; and allows also to define regions and a step witdth:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; [&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;&lt;span class="pl-c1"&gt;20&lt;/span&gt;]
[&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;,&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;14&lt;/span&gt;,&lt;span class="pl-c1"&gt;16&lt;/span&gt;,&lt;span class="pl-c1"&gt;18&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another useful feature in this area are &lt;em&gt;list comprehensions&lt;/em&gt;. With list comprehensions it's quite convenient to define infinite sets with specific properties:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; infinite list of all odd numbers&lt;/span&gt;
&lt;span class="pl-en"&gt;odds&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;]
odds &lt;span class="pl-k"&gt;=&lt;/span&gt; [n &lt;span class="pl-k"&gt;|&lt;/span&gt; n &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;..&lt;/span&gt;], n &lt;span class="pl-k"&gt;`mod`&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;/=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;] &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; read as set builder notation: {n | n ∈ ℕ, n%2 ≠ 0}&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; infinite list of all integer pythagorean triples with a² + b² = c²&lt;/span&gt;
&lt;span class="pl-en"&gt;pythagoreanTriples&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; [(&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Int&lt;/span&gt;&lt;/span&gt;)]
pythagoreanTriples &lt;span class="pl-k"&gt;=&lt;/span&gt;  [ (a, b, c)
  &lt;span class="pl-k"&gt;|&lt;/span&gt; c &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;..&lt;/span&gt;]
  , b &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;..&lt;/span&gt; c &lt;span class="pl-k"&gt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;]
  , a &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; [&lt;span class="pl-c1"&gt;1&lt;/span&gt; &lt;span class="pl-k"&gt;..&lt;/span&gt; b &lt;span class="pl-k"&gt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;]
  , a &lt;span class="pl-k"&gt;^&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;+&lt;/span&gt; b &lt;span class="pl-k"&gt;^&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;==&lt;/span&gt; c &lt;span class="pl-k"&gt;^&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt;
  ]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; infinite list of all prime numbers&lt;/span&gt;
&lt;span class="pl-en"&gt;primes&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; [&lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;Integer&lt;/span&gt;&lt;/span&gt;]
primes &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;:&lt;/span&gt; [i &lt;span class="pl-k"&gt;|&lt;/span&gt; i &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; [&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;&lt;span class="pl-k"&gt;..&lt;/span&gt;],  
              &lt;span class="pl-c1"&gt;and&lt;/span&gt; [&lt;span class="pl-c1"&gt;rem&lt;/span&gt; i p &lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt; &lt;span class="pl-k"&gt;|&lt;/span&gt; p &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;takeWhile&lt;/span&gt; (&lt;span class="pl-k"&gt;\&lt;/span&gt;p &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; p&lt;span class="pl-k"&gt;^&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;lt;=&lt;/span&gt; i) primes]]

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and the in GHCi:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; odds
[&lt;span class="pl-c1"&gt;1&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;11&lt;/span&gt;,&lt;span class="pl-c1"&gt;13&lt;/span&gt;,&lt;span class="pl-c1"&gt;15&lt;/span&gt;,&lt;span class="pl-c1"&gt;17&lt;/span&gt;,&lt;span class="pl-c1"&gt;19&lt;/span&gt;]
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; pythagoreanTriples
[(&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;4&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;),(&lt;span class="pl-c1"&gt;6&lt;/span&gt;,&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;10&lt;/span&gt;),(&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;13&lt;/span&gt;),(&lt;span class="pl-c1"&gt;9&lt;/span&gt;,&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;15&lt;/span&gt;),(&lt;span class="pl-c1"&gt;8&lt;/span&gt;,&lt;span class="pl-c1"&gt;15&lt;/span&gt;,&lt;span class="pl-c1"&gt;17&lt;/span&gt;),(&lt;span class="pl-c1"&gt;12&lt;/span&gt;,&lt;span class="pl-c1"&gt;16&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;),(&lt;span class="pl-c1"&gt;15&lt;/span&gt;,&lt;span class="pl-c1"&gt;20&lt;/span&gt;,&lt;span class="pl-c1"&gt;25&lt;/span&gt;),(&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;24&lt;/span&gt;,&lt;span class="pl-c1"&gt;25&lt;/span&gt;),(&lt;span class="pl-c1"&gt;10&lt;/span&gt;,&lt;span class="pl-c1"&gt;24&lt;/span&gt;,&lt;span class="pl-c1"&gt;26&lt;/span&gt;),(&lt;span class="pl-c1"&gt;20&lt;/span&gt;,&lt;span class="pl-c1"&gt;21&lt;/span&gt;,&lt;span class="pl-c1"&gt;29&lt;/span&gt;)]
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;20&lt;/span&gt; primes
[&lt;span class="pl-c1"&gt;2&lt;/span&gt;,&lt;span class="pl-c1"&gt;3&lt;/span&gt;,&lt;span class="pl-c1"&gt;5&lt;/span&gt;,&lt;span class="pl-c1"&gt;7&lt;/span&gt;,&lt;span class="pl-c1"&gt;11&lt;/span&gt;,&lt;span class="pl-c1"&gt;13&lt;/span&gt;,&lt;span class="pl-c1"&gt;17&lt;/span&gt;,&lt;span class="pl-c1"&gt;19&lt;/span&gt;,&lt;span class="pl-c1"&gt;23&lt;/span&gt;,&lt;span class="pl-c1"&gt;29&lt;/span&gt;,&lt;span class="pl-c1"&gt;31&lt;/span&gt;,&lt;span class="pl-c1"&gt;37&lt;/span&gt;,&lt;span class="pl-c1"&gt;41&lt;/span&gt;,&lt;span class="pl-c1"&gt;43&lt;/span&gt;,&lt;span class="pl-c1"&gt;47&lt;/span&gt;,&lt;span class="pl-c1"&gt;53&lt;/span&gt;,&lt;span class="pl-c1"&gt;59&lt;/span&gt;,&lt;span class="pl-c1"&gt;61&lt;/span&gt;,&lt;span class="pl-c1"&gt;67&lt;/span&gt;,&lt;span class="pl-c1"&gt;71&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another classic example in this area is the Newton-Raphson algorithm that approximates the square roots of a number &lt;em&gt;n&lt;/em&gt; by starting from an initial value &lt;em&gt;a&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt; and computing the approximation &lt;em&gt;a&lt;sub&gt;i+1&lt;/sub&gt;&lt;/em&gt; as:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;a&lt;sub&gt;i+1&lt;/sub&gt; = (a&lt;sub&gt;i&lt;/sub&gt; + n/a&lt;sub&gt;i&lt;/sub&gt;)/2&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;For &lt;em&gt;n &amp;gt;= 0&lt;/em&gt; and &lt;em&gt;a&lt;sub&gt;0&lt;/sub&gt; &amp;gt; 0&lt;/em&gt; this series converges quickly towards the square root of &lt;em&gt;n&lt;/em&gt;
(See &lt;a href="https://en.wikipedia.org/wiki/Newton%27s_method" rel="nofollow"&gt;Newton's method on Wikipedia&lt;/a&gt; for details).&lt;/p&gt;
&lt;p&gt;The Haskell implementations makes full usage of lazy evaluation. The first step is to define a function &lt;code&gt;next&lt;/code&gt; that computes &lt;em&gt;a&lt;sub&gt;i+1&lt;/sub&gt;&lt;/em&gt; based on &lt;em&gt;n&lt;/em&gt; and &lt;em&gt;a&lt;sub&gt;i&lt;/sub&gt;&lt;/em&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;next&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Fractional&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
next n a_i &lt;span class="pl-k"&gt;=&lt;/span&gt; (a_i &lt;span class="pl-k"&gt;+&lt;/span&gt; n&lt;span class="pl-k"&gt;/&lt;/span&gt;a_i)&lt;span class="pl-k"&gt;/&lt;/span&gt;&lt;span class="pl-c1"&gt;2&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we use &lt;code&gt;next&lt;/code&gt; to define an infinite set of approximizations:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; root_of_16 &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-c1"&gt;iterate&lt;/span&gt; (next &lt;span class="pl-c1"&gt;16&lt;/span&gt;) &lt;span class="pl-c1"&gt;1&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;take&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; root_of_16
[&lt;span class="pl-c1"&gt;1.0&lt;/span&gt;,&lt;span class="pl-c1"&gt;8.5&lt;/span&gt;,&lt;span class="pl-c1"&gt;5.1911764705882355&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.136664722546242&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.002257524798522&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.000000636692939&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.000000000000051&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.0&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.0&lt;/span&gt;,&lt;span class="pl-c1"&gt;4.0&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The function &lt;code&gt;iterate&lt;/code&gt; is a standard library function in Haskell. &lt;code&gt;iterate f x&lt;/code&gt; returns an infinite list of repeated applications of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;iterate&lt;/span&gt; f x &lt;span class="pl-k"&gt;==&lt;/span&gt; [x, f x, f (f x), &lt;span class="pl-k"&gt;...&lt;/span&gt;]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It is defined as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;iterate&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;]
&lt;span class="pl-c1"&gt;iterate&lt;/span&gt; f x &lt;span class="pl-k"&gt;=&lt;/span&gt;  x &lt;span class="pl-k"&gt;:&lt;/span&gt; &lt;span class="pl-c1"&gt;iterate&lt;/span&gt; f (f x)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As lazy evaluation is the default in Haskell it's totally safe to define infinite structures like &lt;code&gt;root_of_16&lt;/code&gt; as long as we make sure that not all elements of the list are required by subsequent computations.&lt;/p&gt;
&lt;p&gt;As &lt;code&gt;root_of_16&lt;/code&gt; represents a converging series of approximisations we'll have to search this list for the first element that matches our desired precision, specified by a maximum tolerance &lt;code&gt;eps&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We define a function &lt;code&gt;within&lt;/code&gt; which takes the tolerance &lt;code&gt;eps&lt;/code&gt; and a list of approximations and looks down the list for two successive approximations &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that differ by no more than the given tolerance &lt;code&gt;eps&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;within&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Fractional&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; [&lt;span class="pl-smi"&gt;a&lt;/span&gt;] &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
within eps (a&lt;span class="pl-k"&gt;:&lt;/span&gt;b&lt;span class="pl-k"&gt;:&lt;/span&gt;rest) &lt;span class="pl-k"&gt;=&lt;/span&gt;
  &lt;span class="pl-k"&gt;if&lt;/span&gt; &lt;span class="pl-c1"&gt;abs&lt;/span&gt;(a&lt;span class="pl-k"&gt;/&lt;/span&gt;b &lt;span class="pl-k"&gt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;) &lt;span class="pl-k"&gt;&amp;lt;=&lt;/span&gt; eps
    &lt;span class="pl-k"&gt;then&lt;/span&gt; b
    &lt;span class="pl-k"&gt;else&lt;/span&gt; within eps (b&lt;span class="pl-k"&gt;:&lt;/span&gt;rest)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The actual function &lt;code&gt;root n eps&lt;/code&gt; can then be defined as:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;root&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Ord&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Fractional&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
root n eps &lt;span class="pl-k"&gt;=&lt;/span&gt; within eps (&lt;span class="pl-c1"&gt;iterate&lt;/span&gt; (next n) &lt;span class="pl-c1"&gt;1&lt;/span&gt;)```

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; and then in GHCI:&lt;/span&gt;
ghci&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; root &lt;span class="pl-c1"&gt;2&lt;/span&gt; &lt;span class="pl-c1"&gt;0.000001&lt;/span&gt;
&lt;span class="pl-c1"&gt;1.414213562373095&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This example has been taken from The classic paper &lt;a href="https://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf" rel="nofollow"&gt;Why Functional Programming Matters&lt;/a&gt;. In this paper John Hughes highlights higher order functions and lazy evaluation as two outstanding contributions of functional programming. The paper features several very instructive examples for both concepts.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Infinity.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;&lt;a id="user-content-reflection" class="anchor" aria-hidden="true" href="#reflection"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reflection&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;In computer science, reflection is the ability of a computer program to examine, introspect, and modify its own structure and behavior at runtime.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Reflection_(computer_programming)" rel="nofollow"&gt;Quoted from Wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Reflection is one of those programming language features that were introduced first in Lisp based environments but became popular in many mainstream programming languages as it proved to be very useful in writing generic frameworks for persistence, serialization etc.&lt;/p&gt;
&lt;p&gt;I'll demonstrate this with simple persistence library. This library is kept as simple as possible. We just define a new type class &lt;code&gt;Entity a&lt;/code&gt; with two actions &lt;code&gt;persist&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; with both have a generic default implementation used for writing an entity to a file or reading it back from a file.
The type class also features a function &lt;code&gt;getId&lt;/code&gt; which returns a unique identifier for a given entity, which must be implemented by all concrete types deriving &lt;code&gt;Entity&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;module&lt;/span&gt; &lt;span class="pl-c1"&gt;SimplePersistence&lt;/span&gt;
    ( &lt;span class="pl-en"&gt;Id&lt;/span&gt;
    , &lt;span class="pl-en"&gt;Entity&lt;/span&gt;
    , &lt;span class="pl-en"&gt;getId&lt;/span&gt;
    , &lt;span class="pl-en"&gt;persist&lt;/span&gt;
    , &lt;span class="pl-en"&gt;retrieve&lt;/span&gt;
    ) &lt;span class="pl-k"&gt;where&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; Identifier for an Entity&lt;/span&gt;
&lt;span class="pl-k"&gt;type&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; The Entity type class provides generic persistence to text files&lt;/span&gt;
&lt;span class="pl-k"&gt;class&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Read&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Entity&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; return the unique Id of the entity. This function must be implemented by type class instances.&lt;/span&gt;
    &lt;span class="pl-en"&gt;getId&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; persist an entity of type a and identified by an Id to a text file&lt;/span&gt;
    &lt;span class="pl-en"&gt;persist&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
    persist entity &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute file path based on entity id&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; fileName &lt;span class="pl-k"&gt;=&lt;/span&gt; getPath (getId entity)
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; serialize entity as JSON and write to file&lt;/span&gt;
        &lt;span class="pl-c1"&gt;writeFile&lt;/span&gt; fileName (&lt;span class="pl-c1"&gt;show&lt;/span&gt; entity)

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; load persistent entity of type a and identified by an Id&lt;/span&gt;
    &lt;span class="pl-en"&gt;retrieve&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    retrieve &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute file path based on entity id&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; fileName &lt;span class="pl-k"&gt;=&lt;/span&gt; getPath &lt;span class="pl-c1"&gt;id&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; read file content into string&lt;/span&gt;
        contentString &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;readFile&lt;/span&gt; fileName
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; parse entity from string&lt;/span&gt;
        &lt;span class="pl-c1"&gt;return&lt;/span&gt; (&lt;span class="pl-c1"&gt;read&lt;/span&gt; contentString)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; compute path of data file&lt;/span&gt;
&lt;span class="pl-en"&gt;getPath&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;FilePath&lt;/span&gt;&lt;/span&gt;
getPath &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.stack-work/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.txt&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A typical usage of this library would look like follows:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-k"&gt;import&lt;/span&gt; &lt;span class="pl-c1"&gt;SimplePersistence&lt;/span&gt; (&lt;span class="pl-en"&gt;Id&lt;/span&gt;, &lt;span class="pl-en"&gt;Entity&lt;/span&gt;, &lt;span class="pl-en"&gt;getId&lt;/span&gt;, &lt;span class="pl-en"&gt;persist&lt;/span&gt;, &lt;span class="pl-en"&gt;retrieve&lt;/span&gt;)

&lt;span class="pl-k"&gt;data&lt;/span&gt; &lt;span class="pl-en"&gt;User&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;User&lt;/span&gt; &lt;span class="pl-k"&gt;{&lt;/span&gt;
      &lt;span class="pl-e"&gt;userId&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt;
    , &lt;span class="pl-e"&gt;name&lt;/span&gt;   &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
    , &lt;span class="pl-e"&gt;email&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span class="pl-k"&gt;}&lt;/span&gt; &lt;span class="pl-k"&gt;deriving&lt;/span&gt; (&lt;span class="pl-e"&gt;Show&lt;/span&gt;, &lt;span class="pl-e"&gt;Read&lt;/span&gt;)

&lt;span class="pl-k"&gt;instance&lt;/span&gt; &lt;span class="pl-en"&gt;Entity&lt;/span&gt; &lt;span class="pl-en"&gt;User&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;
    getId &lt;span class="pl-k"&gt;=&lt;/span&gt; userId

reflectionDemo &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
    &lt;span class="pl-k"&gt;let&lt;/span&gt; user &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-ent"&gt;User&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;Heinz Meier&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;hm@meier.com&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;
    persist user
    user' &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; retrieve &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;1&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-en"&gt;User&lt;/span&gt;
    &lt;span class="pl-c1"&gt;print&lt;/span&gt; user'&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So all a user has to do in order to use our library is:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;let the data type derive the &lt;code&gt;Show&lt;/code&gt; and &lt;code&gt;Read&lt;/code&gt; type classes, which provides a poor mans serialization.&lt;/li&gt;
&lt;li&gt;let the data type derive from &lt;code&gt;Entity&lt;/code&gt; by providing an implementation for &lt;code&gt;getId&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;use &lt;code&gt;persist&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; to write and read entities to/from file.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As we can see from the function signatures for &lt;code&gt;persist&lt;/code&gt; and &lt;code&gt;retrieve&lt;/code&gt; both functions have no information about the concrete type they are being used on:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;&lt;span class="pl-en"&gt;persist&lt;/span&gt;  &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Entity&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;  &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
&lt;span class="pl-en"&gt;retrieve&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Entity&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a consequence the generic implementation of both function in the Entity type class also have no direct access to the concrete type of the processed entities. (They simply delegate to other generic functions like &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;show&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;So how can we access the concrete type of a processed entity? Imagine we'd like to store our entities into files that bear the type name as part of the file name, e.g. &lt;code&gt;User.7411.txt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The answer is of course: reflection. Here is what we have to add to our library to extend &lt;code&gt;persist&lt;/code&gt; according to our new requirements:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;{-# &lt;span class="pl-k"&gt;LANGUAGE&lt;/span&gt; ScopedTypeVariables   #-}
&lt;span class="pl-k"&gt;import&lt;/span&gt;           &lt;span class="pl-c1"&gt;Data.Typeable&lt;/span&gt;

&lt;span class="pl-k"&gt;class&lt;/span&gt; (&lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Show&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;&lt;span class="pl-e"&gt;Read&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;, &lt;span class="pl-en"&gt;Typeable&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;) &lt;span class="pl-k"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;Entity&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;where&lt;/span&gt;

    &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; persist an entity of type a and identified by an Id to a file&lt;/span&gt;
    &lt;span class="pl-en"&gt;persist&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;()&lt;/span&gt;
    persist entity &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute file path based on entity type and id&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; fileName &lt;span class="pl-k"&gt;=&lt;/span&gt; getPath (typeOf entity) (getId entity)
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; serialize entity as JSON and write to file&lt;/span&gt;
        &lt;span class="pl-c1"&gt;writeFile&lt;/span&gt; fileName (&lt;span class="pl-c1"&gt;show&lt;/span&gt; entity)

&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; &lt;span class="pl-c"&gt;|&lt;/span&gt; compute path of data file, this time with the type name as part of the file name&lt;/span&gt;
&lt;span class="pl-en"&gt;getPath&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;TypeRep&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;String&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;FilePath&lt;/span&gt;&lt;/span&gt;
getPath tr &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.stack-work/&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;show&lt;/span&gt; tr &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;++&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;"&lt;/span&gt;.txt&lt;span class="pl-pds"&gt;"&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We have to add a new constrained &lt;code&gt;Typeable a&lt;/code&gt; to our definition of &lt;code&gt;Entity&lt;/code&gt;. This allows to use reflective code on our entity types. In our case we simply compute a type representation &lt;code&gt;TypeRep&lt;/code&gt; by calling &lt;code&gt;typeOf entity&lt;/code&gt; which we then use in &lt;code&gt;getPath&lt;/code&gt; to add the type name to the file path.&lt;/p&gt;
&lt;p&gt;The definition of &lt;code&gt;retrieve&lt;/code&gt; is a bit more tricky as we don't yet have an entity available yet when computing the file path. So we have to apply a small trick to compute the correct type representation:&lt;/p&gt;
&lt;div class="highlight highlight-source-haskell"&gt;&lt;pre&gt;    &lt;span class="pl-en"&gt;retrieve&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-en"&gt;Id&lt;/span&gt; &lt;span class="pl-k"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="pl-en"&gt;&lt;span class="pl-c1"&gt;IO&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;
    retrieve &lt;span class="pl-c1"&gt;id&lt;/span&gt; &lt;span class="pl-k"&gt;=&lt;/span&gt; &lt;span class="pl-k"&gt;do&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; compute file path based on entity type and id&lt;/span&gt;
        &lt;span class="pl-k"&gt;let&lt;/span&gt; fileName &lt;span class="pl-k"&gt;=&lt;/span&gt; getPath (typeOf (&lt;span class="pl-c1"&gt;undefined&lt;/span&gt; &lt;span class="pl-k"&gt;::&lt;/span&gt; &lt;span class="pl-smi"&gt;a&lt;/span&gt;)) &lt;span class="pl-c1"&gt;id&lt;/span&gt;
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; read file content into string&lt;/span&gt;
        contentString &lt;span class="pl-k"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="pl-c1"&gt;readFile&lt;/span&gt; fileName
        &lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;--&lt;/span&gt; parse entity from string&lt;/span&gt;
        &lt;span class="pl-c1"&gt;return&lt;/span&gt; (&lt;span class="pl-c1"&gt;read&lt;/span&gt; contentString)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The compiler will be able to deduce the correct type of &lt;code&gt;a&lt;/code&gt; in the expression &lt;code&gt;(undefined :: a)&lt;/code&gt; as the concrete return type of &lt;code&gt;retrieve&lt;/code&gt; must be specified at the call site, as in example &lt;code&gt;user' &amp;lt;- retrieve "1" :: IO User&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Of course this was only a teaser of what is possible with generic reflective programming. The fearless reader is invited to study the &lt;a href="https://github.com/bos/aeson"&gt;source code of the aeson library&lt;/a&gt; for a deep dive.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/thma/LtuPatternFactory/blob/master/src/Reflection.hs"&gt;Sourcecode for this section&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-conclusions" class="anchor" aria-hidden="true" href="#conclusions"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Conclusions&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-design-patterns-are-not-limited-to-object-oriented-programming" class="anchor" aria-hidden="true" href="#design-patterns-are-not-limited-to-object-oriented-programming"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Design Patterns are not limited to object oriented programming&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Christopher Alexander says, "Each pattern describes a problem which occurs over and
over again in our environment, and then describes the core of the solution to that
problem, in such a way that you can use this solution a million times over, without ever
doing it the same way twice" [AIS+77, page x]. Even though Alexander was talking
about patterns in buildings and towns, what he says is true about object-oriented design
patterns. Our solutions are expressed in terms of objects and interfaces instead of walls
and doors, but at the core of both kinds of patterns is a solution to a problem in a
context.
&lt;a href="https://en.wikipedia.org/wiki/Design_Patterns" rel="nofollow"&gt;Quoted from "Design Patterns Elements of Reusable Object-Oriented Software"&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The GoF &lt;em&gt;Design Patterns Elements of Reusable Object-Oriented Software&lt;/em&gt; was written to help software developers to think about software design problems in a different way:
From just writing a minimum adhoc solution for the problem at hand to stepping back and to think about how to solve the problem in a way that improves longterm qualities like extensibilty, flexibility, maintenability, testability and comprehensibility of a software design.&lt;/p&gt;
&lt;p&gt;The GoF and other researches in the pattern area did "pattern mining": they examined code of experienced software developers and looked for recurring structures and solutions. The patterns they distilled by this process are thus &lt;em&gt;reusable abstractions&lt;/em&gt; for structuring object-oriented software to achieve the above mentioned goals.&lt;/p&gt;
&lt;p&gt;So while the original design patterns are formulated with object oriented languages in mind, they still adress universal problems in software engineering: decoupling of layers, configuration, dependency management, data composition, data traversal, handling state, variation of behaviour, etc.&lt;/p&gt;
&lt;p&gt;So it comes with little surprise that we can map many of those patterns to commonly used structures in functional programming: The domain problems remain the same, yet the concrete solutions differ:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some patterns are absorbed by language features:
&lt;ul&gt;
&lt;li&gt;Template method and strategy pattern are no brainers in any functional language with functions as first class citizens and higher order functions.&lt;/li&gt;
&lt;li&gt;Dependency Injection and Configuration is solved by partial application of curried functions.&lt;/li&gt;
&lt;li&gt;Adapter layers are replaced by function composition&lt;/li&gt;
&lt;li&gt;Visitor pattern and Interpreters are self-evident with algebraic data types.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Other patterns are covered by libraries like the Haskell type classes:
&lt;ul&gt;
&lt;li&gt;Composite is reduced to a Monoid&lt;/li&gt;
&lt;li&gt;Singleton, Pipeline, NullObject can be rooted in Functor, Applicative Functor and Monad&lt;/li&gt;
&lt;li&gt;Visitor and Iterator are covered by Foldable and Traversable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Yet another category of patterns is covered by specific language features like Lazy Evaluation, Parallelism. These features may be specific to certain languages.
&lt;ul&gt;
&lt;li&gt;Laziness allows to work with non-terminating compuations and data structures of infinite size.&lt;/li&gt;
&lt;li&gt;Parallelism allows to scale the execution of a program transparently across CPU cores.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-design-patterns-reflect-mathematical-structures" class="anchor" aria-hidden="true" href="#design-patterns-reflect-mathematical-structures"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Design patterns reflect mathematical structures&lt;/h3&gt;
&lt;p&gt;What really struck me in the course of writing this study was that so many of the Typeclassopedia type classes could be related to Design Patterns.&lt;/p&gt;
&lt;p&gt;Most of these type classes stem from abstract algebra and category theory in particular.
Take for instance the &lt;code&gt;Monoid&lt;/code&gt; type class which is a 1:1 representation of the &lt;a href="https://en.wikipedia.org/wiki/Monoid" rel="nofollow"&gt;monoid&lt;/a&gt; of abstract algebra.
Identifying the &lt;a href="#composite--semigroup--monoid"&gt;composite pattern&lt;/a&gt; as an application of a monoidal data structure was an eye opener for me:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Design patterns reflect abstract algebraic structures.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As another example take the &lt;a href="#map-reduce"&gt;Map-Reduce&lt;/a&gt; pattern: we demonstrated that the question whether a problem can be solved by a map-reduce approach boils down to the algebraic question whether the data structure used to hold the intermediary results of the &lt;code&gt;map&lt;/code&gt; operation forms a &lt;em&gt;commutative monoid&lt;/em&gt; under the &lt;code&gt;reduce&lt;/code&gt; operation.&lt;/p&gt;
&lt;p&gt;Rooting design patterns in abstract algebra brings a higher level of confidence to software design as we can move from 'hand waving' – painting UML diagrams, writing prose, building prototypes, etc. – to mathematical reasoning.&lt;/p&gt;
&lt;p&gt;Mark Seemann has written an instructive series of articles on the coincidence of design patterns with abstract algebra: &lt;a href="http://blog.ploeh.dk/2017/10/04/from-design-patterns-to-category-theory/" rel="nofollow"&gt;From Design Patterns to Category Theory&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Jeremy Gibbons has also written several excellent papers on this subject:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Design patterns are reusable abstractions in object-oriented software.
However, using current mainstream programming languages, these elements can only be expressed extra-linguistically: as prose,pictures, and prototypes.
We believe that this is not inherent in the patterns themselves, but evidence of a lack of expressivity in the languages of today.
We expect that, in the languages of the future, the code parts of design patterns will be expressible as reusable library components.
Indeed, we claim that the languages of tomorrow will suffice; the future is not far away. All that is needed, in addition to commonly-available features,
are higher-order and datatype-generic constructs;
these features are already or nearly available now.&lt;br&gt;
Quoted from &lt;a href="http://www.cs.ox.ac.uk/jeremy.gibbons/publications/hodgp.pdf" rel="nofollow"&gt;Design Patterns as Higher-Order Datatype-Generic Programs&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;He also maintains a blog dedicated to &lt;a href="https://patternsinfp.wordpress.com/welcome/" rel="nofollow"&gt;patterns in functional programming&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I'd like to conclude this section with a quote from Martin Menestrets FP blog:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] there is this curious thing called &lt;a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="nofollow"&gt;Curry–Howard correspondence&lt;/a&gt; which is a direct analogy between mathematical concepts and computational calculus [...].&lt;/p&gt;
&lt;p&gt;This correspondence means that a lot of useful stuff discovered and proven for decades in Math can then be transposed to programming, opening a way for a lot of extremely robust constructs for free.&lt;/p&gt;
&lt;p&gt;In OOP, Design patterns are used a lot and could be defined as idiomatic ways to solve a given problems, in specific contexts but their existences won’t save you from having to apply and write them again and again each time you encounter the problems they solve.&lt;/p&gt;
&lt;p&gt;Functional programming constructs, some directly coming from category theory (mathematics), solve directly what you would have tried to solve with design patterns.&lt;/p&gt;
&lt;p&gt;Quoted from &lt;a href="http://geekocephale.com/blog/2018/10/08/fp" rel="nofollow"&gt;Geekocephale&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id="user-content-some-interesting-links" class="anchor" aria-hidden="true" href="#some-interesting-links"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;some interesting links&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.ibm.com/developerworks/library/j-ft10/index.html" rel="nofollow"&gt;IBM Developerworks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.ezyang.com/2010/05/design-patterns-in-haskel/" rel="nofollow"&gt;Design patterns in Haskell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://staticallytyped.wordpress.com/2013/03/09/gang-of-four-patterns-with-type-classes-and-implicits-in-scala/" rel="nofollow"&gt;GOF patterns in Scala&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://norvig.com/design-patterns/design-patterns.pdf" rel="nofollow"&gt;Patterns in dynamic functional languages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/tel/scala-typeclassopedia"&gt;Scala Typeclassopedia&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/mmenestret/fp-resources/blob/master/README.md"&gt;FP resources&lt;/a&gt;&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>thma</author><guid isPermaLink="false">https://github.com/thma/LtuPatternFactory</guid><pubDate>Tue, 07 Jan 2020 00:06:00 GMT</pubDate></item><item><title>idris-lang/Idris-dev #7 in Haskell, This week</title><link>https://github.com/idris-lang/Idris-dev</link><description>&lt;p&gt;&lt;i&gt;A Dependently Typed Functional Programming Language&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-idris" class="anchor" aria-hidden="true" href="#idris"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Idris&lt;/h1&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/idris-lang/Idris-dev" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/cd343118e69b413195fb1e0b5f1021d601498942/68747470733a2f2f7472617669732d63692e6f72672f69647269732d6c616e672f49647269732d6465762e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/idris-lang/Idris-dev.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://ci.appveyor.com/project/idrislang/idris-dev" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/b982bf88ef78a9c9e286a6e6b2d5c11deb367e4b/68747470733a2f2f63692e6170707665796f722e636f6d2f6170692f70726f6a656374732f7374617475732f786938797538316f793131333467376f2f6272616e63682f6d61737465723f7376673d74727565" alt="Appveyor build" data-canonical-src="https://ci.appveyor.com/api/projects/status/xi8yu81oy1134g7o/branch/master?svg=true" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://readthedocs.org/projects/idris/?badge=latest" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/864a08dfca8c9a1849bd393b65af8d267bb0b89a/68747470733a2f2f72656164746865646f63732e6f72672f70726f6a656374732f69647269732f62616467652f3f76657273696f6e3d6c6174657374" alt="Documentation Status" data-canonical-src="https://readthedocs.org/projects/idris/badge/?version=latest" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://hackage.haskell.org/package/idris" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/d7eccafe3d5829c82a4d58a90fd169ff427287a6/68747470733a2f2f696d672e736869656c64732e696f2f6861636b6167652f762f69647269732e737667" alt="Hackage" data-canonical-src="https://img.shields.io/hackage/v/idris.svg" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://stackage.org/lts/package/idris" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/2cd84fd43e84d9dd4bbbf82b83eeb978cdae15a7/68747470733a2f2f737461636b6167652e6f72672f7061636b6167652f69647269732f62616467652f6c7473" alt="Stackage LTS" data-canonical-src="https://stackage.org/package/idris/badge/lts" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://stackage.org/nightly/package/idris" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/d8731729a1701110e153935f87391ca6c4e8b703/68747470733a2f2f737461636b6167652e6f72672f7061636b6167652f69647269732f62616467652f6e696768746c79" alt="Stackage Nightly" data-canonical-src="https://stackage.org/package/idris/badge/nightly" style="max-width:100%;"&gt;&lt;/a&gt;
&lt;a href="https://www.irccloud.com/invite?channel=%23idris&amp;amp;hostname=irc.freenode.net&amp;amp;port=6697&amp;amp;ssl=1" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/066b9c3b856a9da49aeac5f58e571e0bf1b827b5/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f4952432d25323369647269732d3165373266662e7376673f7374796c653d666c6174" alt="IRC" data-canonical-src="https://img.shields.io/badge/IRC-%23idris-1e72ff.svg?style=flat" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Idris (&lt;a href="https://idris-lang.org/" rel="nofollow"&gt;https://idris-lang.org/&lt;/a&gt;) is a general-purpose functional programming
language with dependent types.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-installation-guides" class="anchor" aria-hidden="true" href="#installation-guides"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation Guides.&lt;/h2&gt;
&lt;p&gt;This repository represents the latest development version of the
language, and may contain bugs that are being actively worked on.  For
those who wish to use a more stable version of Idris please consider
installing the latest version that has been released on Hackage.
Installation instructions for various platforms can be
&lt;a href="https://github.com/idris-lang/Idris-dev/wiki/Installation-Instructions"&gt;found on the Idris Wiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;More information about building Idris from source has been detailed in the &lt;a href="INSTALL.md"&gt;Installation Guide&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-code-generation" class="anchor" aria-hidden="true" href="#code-generation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Code Generation&lt;/h2&gt;
&lt;p&gt;Idris has support for external code generators. Supplied with the distribution
is a C code generator to compile executables, and a JavaScript code generator
with support for node.js and browser JavaScript.&lt;/p&gt;
&lt;p&gt;More information about &lt;a href="https://idris.readthedocs.io/en/latest/reference/codegen.html" rel="nofollow"&gt;code generators can be found on the wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-more-information" class="anchor" aria-hidden="true" href="#more-information"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;More Information&lt;/h2&gt;
&lt;p&gt;If you would like to find out more information, or ask questions, we
currently have a &lt;a href="https://github.com/idris-lang/Idris-dev/wiki"&gt;Wiki&lt;/a&gt;;
a &lt;a href="https://groups.google.com/forum/#!forum/idris-lang" rel="nofollow"&gt;mailing list&lt;/a&gt;,
and an &lt;code&gt;IRC&lt;/code&gt; channel &lt;code&gt;#idris&lt;/code&gt; on freenode. To join the IRC channel,
point your irc client to &lt;code&gt;chat.freenode.net&lt;/code&gt; then &lt;code&gt;/join #idris&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For those further interested in using Idris for projects, the
&lt;a href="https://github.com/idris-hackers"&gt;Idris Hackers&lt;/a&gt; GitHub organisation is
where some interesting projects are being hosted.&lt;/p&gt;
&lt;p&gt;For those interested in contributing to Idris directly we kindly ask that
prospective developers please consult the &lt;a href="CONTRIBUTING.md"&gt;Contributing Guide&lt;/a&gt; first.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>idris-lang</author><guid isPermaLink="false">https://github.com/idris-lang/Idris-dev</guid><pubDate>Tue, 07 Jan 2020 00:07:00 GMT</pubDate></item></channel></rss>