<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>GitHub Trending: Coq, Today</title><link>https://github.com/trending/coq?since=daily</link><description>The top repositories on GitHub for coq, measured daily</description><pubDate>Mon, 13 Jan 2020 01:04:18 GMT</pubDate><lastBuildDate>Mon, 13 Jan 2020 01:04:18 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><ttl>720</ttl><item><title>mit-plv/fiat-crypto #1 in Coq, Today</title><link>https://github.com/mit-plv/fiat-crypto</link><description>&lt;p&gt;&lt;i&gt;Cryptographic Primitive Code Generation by Fiat&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-fiat-crypto-synthesizing-correct-by-construction-code-for-cryptographic-primitives" class="anchor" aria-hidden="true" href="#fiat-crypto-synthesizing-correct-by-construction-code-for-cryptographic-primitives"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Fiat-Crypto: Synthesizing Correct-by-Construction Code for Cryptographic Primitives&lt;/h1&gt;
&lt;h2&gt;&lt;a id="user-content-building" class="anchor" aria-hidden="true" href="#building"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Building&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://travis-ci.org/mit-plv/fiat-crypto" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/378f9bf3f70bacc56908888afbc9b106d49ad5b9/68747470733a2f2f6170692e7472617669732d63692e6f72672f6d69742d706c762f666961742d63727970746f2e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://api.travis-ci.org/mit-plv/fiat-crypto.png?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This repository requires coq 8.9 or later. 8.7 may work, but we don't use it ourselves.&lt;/p&gt;
&lt;p&gt;Git submodules are used for some dependencies. If you did not clone with &lt;code&gt;--recursive&lt;/code&gt;, run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build (if your COQPATH variable is empty):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   make
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To build:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   export COQPATH="$(pwd)/coqprime/src:$(pwd)/bedrock2/bedrock2/src:$(pwd)/bedrock2/deps/coqutil/src${COQPATH:+:}$COQPATH"
   make
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a id="user-content-usage" class="anchor" aria-hidden="true" href="#usage"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Usage&lt;/h2&gt;
&lt;p&gt;The Coq development builds binary compilers that generate code using some implementation strategy.
The parameters (modulus, hardware multiplication input bitwidth, etc.) are are specified on the command line of the compiler.
The generated C code is written to standard output.&lt;/p&gt;
&lt;p&gt;A collection of C files for popular curves can be made with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make c-files
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The C files will appear in the top-level directory.&lt;/p&gt;
&lt;p&gt;Just the compilers generating these C files can be made with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;make standalone
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or &lt;code&gt;make standalone-haskell&lt;/code&gt; or &lt;code&gt;make standalone-ocaml&lt;/code&gt; for binaries generated with just one compiler.
The binaries are located in &lt;code&gt;src/ExtractionOcaml/&lt;/code&gt; and &lt;code&gt;src/ExtractionHaskell&lt;/code&gt; respectively.&lt;/p&gt;
&lt;p&gt;There is a separate compiler binary for each implementation strategy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;saturated_solinas&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unsaturated_solinas&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;word_by_word_montgomery&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Passing no arguments, or passing &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; (or any other invalid arguments) will result in a usage message being printed.  These binaries output C code on stdout.&lt;/p&gt;
&lt;p&gt;Here are some examples of ways to invoke the binaries (from the directories that they live in):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Generate code for 2^255-19
./unsaturated_solinas '25519' '5' '2^255 - 19' '64' carry_mul carry_square carry_scmul121666 carry add sub opp selectznz to_bytes from_bytes &amp;gt; curve25519_64.c
./unsaturated_solinas '25519' '10' '2^255 - 19' '32' carry_mul carry_square carry_scmul121666 carry add sub opp selectznz to_bytes from_bytes &amp;gt; curve25519_32.c

# Generate code for NIST-P256 (2^256 - 2^224 + 2^192 + 2^96 - 1)
./word_by_word_montgomery 'p256' '2^256 - 2^224 + 2^192 + 2^96 - 1' '32' &amp;gt; p256_32.c
./word_by_word_montgomery 'p256' '2^256 - 2^224 + 2^192 + 2^96 - 1' '64' &amp;gt; p256_64.c
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find more examples in the &lt;code&gt;Makefile&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-reading-about-the-code" class="anchor" aria-hidden="true" href="#reading-about-the-code"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reading About The Code&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://adam.chlipala.net/papers/FiatCryptoSP19/FiatCryptoSP19.pdf" rel="nofollow"&gt;Andres Erbsen, Jade Philipoom, Jason Gross, Robert Sloan, Adam Chlipala. Simple High-Level Code For Cryptographic Arithmetic -- With Proofs, Without Compromises. To Appear in Proceedings of the IEEE Symposium on Security &amp;amp; Privacy 2019 (S&amp;amp;P'19). May 2019.&lt;/a&gt;. This paper describes multiple field arithmetic implementations, and an older version of the compilation pipeline (preserved &lt;a href="https://github.com/mit-plv/fiat-crypto/tree/sp2019latest"&gt;here&lt;/a&gt;). It is somewhat space-constrained, so some details are best read about in theses below.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://adam.chlipala.net/theses/jadep_meng.pdf" rel="nofollow"&gt;Jade Philipoom. Correct-by-Construction Finite Field Arithmetic in Coq. MIT Master's Thesis. February 2018.&lt;/a&gt; Chapters 3 and 4 contain a detailed walkthrough of the field arithmetic implementations (again, targeting the previous compilation pipeline).&lt;/li&gt;
&lt;li&gt;&lt;a href="http://adam.chlipala.net/theses/andreser_meng.pdf" rel="nofollow"&gt;Andres Erbsen. Crafting Certified Elliptic CurveCryptography Implementations in Coq. MIT Master's Thesis. June 2017.&lt;/a&gt; Section 3 contains a whirlwind introduction to synthesizing field arithmetic code using coq, without assuming Coq skills, but covering a tiny fraction of the overall library. Sections 5 and 6 contain the only write-up on the ellitpic-curve library in this repository.&lt;/li&gt;
&lt;li&gt;The newest compilation pipeline does not have a separate document yet, but this README does go over it in some detail.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-reading-the-code" class="anchor" aria-hidden="true" href="#reading-the-code"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reading The Code&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-demo-of-synthesis" class="anchor" aria-hidden="true" href="#demo-of-synthesis"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Demo of Synthesis&lt;/h3&gt;
&lt;p&gt;The idea of the synthesis process is demoed in &lt;a href="./src/Demo.v"&gt;&lt;code&gt;src/Demo.v&lt;/code&gt;&lt;/a&gt;.
We strongly recommend reading this before studying the full-scale system.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-proofs-about-elliptic-curves" class="anchor" aria-hidden="true" href="#proofs-about-elliptic-curves"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Proofs About Elliptic Curves&lt;/h3&gt;
&lt;p&gt;We have some about elliptic curves, for example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="./src/Curves/Edwards/AffineProofs.v"&gt;&lt;code&gt;src/Curves/Edwards/AffineProofs.v&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="./src/Curves/Edwards/XYZT/Basic.v"&gt;&lt;code&gt;src/Curves/Edwards/XYZT/Basic.v&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="./src/Curves/Montgomery/AffineProofs.v"&gt;&lt;code&gt;src/Curves/Montgomery/AffineProofs.v&lt;/code&gt;&lt;/a&gt;,&lt;/li&gt;
&lt;li&gt;&lt;a href="src/Curves/Montgomery/XZProofs.v"&gt;&lt;code&gt;src/Curves/Montgomery/XZProofs.v&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;&lt;a id="user-content-actual-synthesis-pipeline" class="anchor" aria-hidden="true" href="#actual-synthesis-pipeline"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Actual Synthesis Pipeline&lt;/h3&gt;
&lt;p&gt;The entry point for clients of the PHOAS expressions we use is
&lt;code&gt;Language/API.v&lt;/code&gt;.  Refer to comments in that file for an explanation
of the interface; the following text describes how the expressions are
generated, not how to interact with them.&lt;/p&gt;
&lt;p&gt;The ordering of files (eliding &lt;code&gt;*Proofs.v&lt;/code&gt; files) is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Language/*.v
    ↑
    ├────────────────────────────────┬───────────────────────┬───────────────────────┐
AbstractInterpretation/*.v     MiscCompilerPasses.v    Rewriter/*.v     PushButtonSynthesis/ReificationCache.v      Arithmetic.v
    ↑                                ↑                       ↑                       ↑                                   ↑
Stringification/*.v                  │                       │                       │                        COperationSpecifications.v
    ↑                                │                       │                       │                                   ↑
    └────────────┬───────────────────┴───────────────────────┴────────┬──────────────┘                                   │
           BoundsPipeline.v                                  CompilersTestCases.v                                        │
                 ↑                                                                                                       │
                 └────────────┬──────────────────────────────────────────────────────────────────────────────────────────┘
                     PushButtonSynthesis/*.v
                              ↑
                   ┌──────────┴────────────────┐
                  CLI.v                SlowPrimeSynthesisExamples.v
                   ↑
        ┌──────────┴────────────────┐
StandaloneHaskellMain.v   StandaloneOCamlMain.v
        ↑                           ↑
ExtractionHaskell.v          ExtractionOCaml.v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Within each directory, the dependency graphs (again eliding &lt;code&gt;*Proofs.v&lt;/code&gt; and related files) are:&lt;/p&gt;
&lt;p&gt;Within &lt;code&gt;Language/&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Pre.v ←──────────────────────────────────────────────────────────────────────── IdentifierParameters.v
    ↑                                                                                        ↑
Language.v ←── IdentifiersBasicLibrary.v ←──── IdentifiersBasicGenerate.v ←── IdentifiersBasicGENERATED.v ←───────────────────────────── API.v
    ↑                        ↑                                                               ↑
    ├────────────────┐       └────────────────────────────┐                                  │
UnderLets.v    IdentifiersLibrary.v ←──────────── IdentifiersGenerate.v ←─────── IdentifiersGENERATED.v
                     ↑                                       ↑                               ↑
              IdentifiersLibraryProofs.v ←─── IdentifiersGenerateProofs.v ←─ IdentifersGENERATEDProofs.v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Within &lt;code&gt;Stringification/&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Language.v
    ↑
   IR.v
    ↑
 ┌──┴───────┐
C.v       Rust.v
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will come back to the &lt;code&gt;Rewriter/*&lt;/code&gt; files shortly.&lt;/p&gt;
&lt;p&gt;The files contain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Arithmetic.v&lt;/code&gt;: All of the high-level field arithmetic stuff&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;COperationSpecifications.v&lt;/code&gt;: The specifications for the various
operations to be synthesized.
TODO: This file should probably be renamed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractInterpretation/*.v&lt;/code&gt;: type-code-based ZRange definitions, abstract
interpretation of identifiers (which does let-lifting, for historical reasons,
and the dependency on UnderLets should probably be removed), defines the
passes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PartialEvaluateWithBounds&lt;/li&gt;
&lt;li&gt;PartialEvaluateWithListInfoFromBounds&lt;/li&gt;
&lt;li&gt;CheckPartialEvaluateWithBounds&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MiscCompilerPasses.v&lt;/code&gt;: Defines the passes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EliminateDead (dead code elimination)&lt;/li&gt;
&lt;li&gt;Subst01 (substitute let-binders used 0 or 1 times)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rewriter/*.v&lt;/code&gt;: rewrite rules, rewriting.  See below for actual stucture
of files.  Defines the passes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RewriteNBE&lt;/li&gt;
&lt;li&gt;RewriteArith&lt;/li&gt;
&lt;li&gt;RewriteArithWithCasts&lt;/li&gt;
&lt;li&gt;RewriteStripLiteralCasts&lt;/li&gt;
&lt;li&gt;RewriteToFancy&lt;/li&gt;
&lt;li&gt;RewriteToFancyWithCasts&lt;/li&gt;
&lt;li&gt;PartialEvaluate (which is just a synonym for RewriteNBE)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inside &lt;code&gt;Language/&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Pre.v&lt;/code&gt;: A few definitions which are used in writing out rewrite
rules and the interpretations of PHOAS identifiers, e.g.,
&lt;code&gt;ident.cast&lt;/code&gt;, &lt;code&gt;ident.eagerly&lt;/code&gt;, &lt;code&gt;Thunked.list_rect&lt;/code&gt;, etc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Language.v&lt;/code&gt;: Defines parts of the PHOAS basic infrastructure
parameterized over base types and identifiers including:
. PHOAS
. reification
. denotation/intepretation
. utilities for inverting PHOAS exprs
. default/dummy values of PHOAS exprs
. default instantiation of generic PHOAS types
. gallina reification of ground terms
. Flat/indexed syntax trees, and conversions to and from PHOAS&lt;/p&gt;
&lt;p&gt;Defines the passes:
. ToFlat
. FromFlat
. GeneralizeVar&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;API.v&lt;/code&gt;: Specializes the type of PHOAS expressions to the
particular identifiers we're using, and defines convenience
notations, tactics, and definitions for some of the specialized
versions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifierParameters.v&lt;/code&gt;: Defines a couple of definitions
determining the identifiers and types used by the language.  These
are used as input for the generation of identifier definitions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersBasicLibrary.v&lt;/code&gt;: Defines the package type holding basic
identifier definitions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersBasicGenerate.v&lt;/code&gt;: Defines the tactics that generate
all of the identifier-list-specific definitions used by the PHOAS
machinery, in addition to defining the tactics that do reification
based on the generated package.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersBasicGENERATED.v&lt;/code&gt;: Basically autogenerated file that
defines the inductives of base type codes and identifier codes
(the first hand-written because it's short; the latter copy-pasted
from a tactic that prints out the inductive), and calls the
package-generation-tactic from &lt;code&gt;IdentifiersBasicGenerate.v&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UnderLets.v&lt;/code&gt;: the UnderLets monad, a pass that does substitution
of var-like things, a pass that inserts let-binders in the
next-to-last line of code, substituting away var-like things (this
is used to ensure that when we output C code, aliasing the input
and the output arrays doesn't cause issues).
Defines the passes:
. SubstVar
. SubstVarLike
. SubstVarOrIdent&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The following files in &lt;code&gt;Language/&lt;/code&gt; are used only by the rewriter:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersLibrary.v&lt;/code&gt;: Some definitions about identifiers and
pattern identifiers and raw identifiers.  Some of these
definitions take generated definitions as arguments. Also defines
a package record to hold all of the generated definitions.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersGenerate.v&lt;/code&gt;: Tactics to generate definitions about
untyped and pattern versions of identifiers for the rewriter.
Culminates in a tactic which inhabits the package type defined in
&lt;code&gt;IdentifiersLibrary.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersLibraryProofs.v&lt;/code&gt;: proofs about definitions in
IdentifiersLibrary.  Also defines a package to hold generated
proofs that require destructing inductives not yet defined in this
file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersGenerateProofs.v&lt;/code&gt;: tactics to prove lemmas to inhabit
the package defined in &lt;code&gt;IdentifiersLibraryProofs.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersGENERATE.v&lt;/code&gt;: identifiers / inductives and definitions
generated by IdentifiersGenerate.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IdentifiersGENERATEProofs.v&lt;/code&gt;: proofs generated by
IdentifiersGenerateProofs, about definitions in
IdentifiersGENERATE&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Inside &lt;code&gt;Stringification/&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Language.v&lt;/code&gt;: defines a printer (Show instance) for the PHOAS
language, defines some common language-independent utilities for
conversion to output code, and defines the spec/API of conversion
from PHOAS to code in a language as strings.  (Depends on
&lt;code&gt;AbstractInterpretation.v&lt;/code&gt; for ZRange utilities.)  Defines the
passes:
. ToString.LinesToString
. ToString.ToFunctionLines&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;IR.v&lt;/code&gt;: Defines a common IR for C and Rust (and maybe eventually
other languages), and builds most of the infrastructure necessary
for instantiating the LanguageSpecification API for a language
with pointers and function calls&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;C.v&lt;/code&gt;: conversion to C code as strings.  Instantiates the API
defined in &lt;code&gt;Stringification.Language&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rust.v&lt;/code&gt;: conversion to Rust code as strings.  Instantiates the
API defined in &lt;code&gt;Stringification.Language&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CompilersTestCases.v&lt;/code&gt;: Various test cases to ensure everything is working&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;BoundsPipeline.v&lt;/code&gt;: Assemble the various compiler passes together into
a composed pipeline.  It is the final interface for the compiler.
Also contains some tactics for applying the BoundsPipeline
correctness lemma.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PushButtonSynthesis/ReificationCache.v&lt;/code&gt;: Defines the cache that
holds reified versions of operations, as well as the tactics that
reify and apply things from the cache.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;PushButtonSynthesis/*&lt;/code&gt;: Reifies the various operations from
&lt;code&gt;Arithmetic.v&lt;/code&gt;, definies the compositions of the BoundsPipeline with
these operations, proves that their interpretations satisfies the
specs from &lt;code&gt;COperationSpecifications.v&lt;/code&gt;, assembles the reified
post-bounds operations into synthesis targets.  These are the files
that &lt;code&gt;CLI.v&lt;/code&gt; depends on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ReificationCache.v&lt;/code&gt;:
Defines the cache of pre-reified terms.  Splitting up
reification from uses of the pipeline allows us to not have to
re-reify big terms every time we change the pipeline or
intermediate stages thereof.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;InvertHighLow.v&lt;/code&gt;:
Defines some common definitions, around plitting apart high and
low bits of things, for Barrett and FancyMontgomeryReduction.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Primitives.v&lt;/code&gt;:
Specializes the pipeline to basic "primitive" operations such as
cmovznz, addcarryx, subborrowx, etc.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SmallExamples.v&lt;/code&gt;:
Some small examples of using the pipeline.  Nothing depends on
this file; it is for demonstration purposes only.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*ReificationCache.v&lt;/code&gt;:
Holds the reified versions of the definitions used in the
corresponding file.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarrettReduction.v&lt;/code&gt;, &lt;code&gt;FancyMontgomeryReduction.v&lt;/code&gt;,
&lt;code&gt;SaturatedSolinas.v&lt;/code&gt;, &lt;code&gt;UnsaturatedSolinas.v&lt;/code&gt;, &lt;code&gt;WordByWordMontgomery.v&lt;/code&gt;:
Holds the instantiation of the pipeline to the corresponding
implementation choice, as well as any relevant correctness
proofs (such as that things assemble into a ring).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;SlowPrimeSynthesisExamples.v&lt;/code&gt;: Additional uses of the pipeline for
primes that are kind-of slow, which I don't want extraction blocking
on.  Also contains some debugging examples.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CLI.v&lt;/code&gt;: Setting up all of the language-independent parts of extraction; relies
on having a list of strings-or-error-messages for each pipeline, and on the
arguments to that pipeline, and builds a parser for command line arguments for
that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;StandaloneHaskellMain.v&lt;/code&gt;, &lt;code&gt;StandaloneOCamlMain.v&lt;/code&gt;, &lt;code&gt;ExtractionHaskell.v&lt;/code&gt;,
&lt;code&gt;ExtractionOCaml.v&lt;/code&gt;: Extraction of pipeline to various languages&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The files defined in &lt;code&gt;Rewriter/&lt;/code&gt; are split up into the following
dependency graph (including some files from &lt;code&gt;Language/&lt;/code&gt; at the top):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IdentifiersLibrary.v ←───────────────────────── IdentifiersGenerate.v ←──────────────────── IdentifiersGENERATED.v
    ↑ ↑                                                   ↑                                        ↑
    │ └──────────────── IdentifiersLibraryProofs.v ←──────┴─ IdentifiersGenerateProofs.v ←─ IdentifersGENERATEDProofs.v
    │                                     ↑                                                        ↑
    │                                     │                                                        │
    │                                     │                                                        │
    │                                     │                                                        │
    │                                     │                                                        │
Rewriter.v ←────────────────────── ProofsCommon.v ←──────────────────── ProofsCommonTactics.v      │
    ↑                                 ↗        ↖                                ↑                  │
Reify.v ←──────────────┐           Wf.v   InterpProofs.v                        │                  │
                       │              ↖        ↗                                │                  │
Rules.v                └──────────── AllTactics.v ──────────────────────────────┘                  │
    ↑                                      ↑       ┌───────────────────────────────────────────────┘
RulesProofs.v                         AllTacticsExtra.v
    ↑                                      ↑
    ├────────┬─────────────┬───────────────┴────────┬─────────────────────────────┐
    │   Passes/NBE.v    Passes/Arith.v    Passes/ArithWithCasts.v    Passes/StripLiteralCasts.v
    │        ↑             ↑                        ↑                             ↑
    │        └─────────────┴────────────────────────┴─────────────────────────────┴─────────────┐
    │                                                                                           │
    └────────┬──────────────────────────┐                                                       │
      Passes/ToFancy.v      Passes/ToFancyWithCasts.v                                           │
             ↑                          ↑                                                       │
             └───────┬──────────────────┴───────────────────────────────────────────────────────┘
                     │
                   All.v
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rules.v&lt;/code&gt;: Defines the list of types of the rewrite rules that
will be reified.  Largely independent of the expression language.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RulesProofs.v&lt;/code&gt;: Proves all of the Gallina versions of the
rewrite rules correct.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Rewriter.v&lt;/code&gt;: Defines the rewriter machinery.  In particular, all of
the rewriter definitions that have non-rewrite-rule-specific proofs
about them are found in this file.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RewrierReify.v&lt;/code&gt;: Defines reification of rewrite rules, continuing on
from &lt;code&gt;Rewriter.v&lt;/code&gt;, and culminates in the tactic
&lt;code&gt;RewriteRules.Tactic.Build_RewriterT&lt;/code&gt; and the tactic notation
&lt;code&gt;make_Rewriter&lt;/code&gt; which define a package of type
&lt;code&gt;RewriteRules.GoalType.RewriterT&lt;/code&gt;.  The &lt;code&gt;Build_*&lt;/code&gt; tactic returns a
&lt;code&gt;constr&lt;/code&gt;, while the &lt;code&gt;make_*&lt;/code&gt; tactic notation refines that &lt;code&gt;constr&lt;/code&gt;
in the goal.  Both tactics take two arguments: first a boolean
&lt;code&gt;include_interp&lt;/code&gt; which specifies whether (&lt;code&gt;true&lt;/code&gt;) or not (&lt;code&gt;false&lt;/code&gt;)
to prefix the list of rewrite rules with the reduction-to-literal
rewrite rules; and second a list of &lt;code&gt;bool * Prop&lt;/code&gt; which is the list
of rewrite rule types to reify, each paired with a boolean saying
whether or not to try rewriting again in the output of the
replacement for that rule.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProofsCommon.v&lt;/code&gt;: Defines the notion of interp-goodness and wf-goodness
for rewrite rules, defines tactics to prove these notions, and
contains a semi-arbitrary collection of proofs and definitions that
are mostly shared between the wf proofs and the interp proofs.
Importantly, this file defines everything needed to state and prove
that specific rewrite rules are correct.  Additionally defines a
package &lt;code&gt;RewriteRules.GoalType.VerifiedRewriter&lt;/code&gt; which describes the
type of the overall specialized rewriter together with its &lt;code&gt;Wf&lt;/code&gt; and
&lt;code&gt;Interp&lt;/code&gt; proofs. (This package should perhaps move to another file?)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ProofsCommonTactics.v&lt;/code&gt;: Defines the actual tactics used to prove that
specific rewrite rules are correct, and to inhabit the packages
defined in &lt;code&gt;ProofsCommon.v&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Wf.v&lt;/code&gt;: Proves wf-preservation of the generic rewriter,
taking in wf-goodness of rewrite rules as a hypothesis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;InterpProofs.v&lt;/code&gt;: Proves interp-correctness of the generic
rewriter, taking in interp-goodness of rewrite rules as a
hypothesis.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AllTactics.v&lt;/code&gt;: Defines the tactic
&lt;code&gt;RewriteRules.Tactic.make_rewriter&lt;/code&gt; (and a similar tactic notation)
which build the entire &lt;code&gt;VerifiedRewriter&lt;/code&gt;.  They take in the
&lt;code&gt;include_interp&lt;/code&gt; as in &lt;code&gt;Rewriter.v&lt;/code&gt; tactics, as well as an hlist of
proofs of rewrite rules indexed over a &lt;code&gt;list (bool * Prop)&lt;/code&gt; of
rewrite rule types.  This is the primary interface for defining a
rewriter from a list of rewrite rules.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AllTacticsExtra.v&lt;/code&gt;: Specializes &lt;code&gt;AllTactics.v&lt;/code&gt; to
what's defined in &lt;code&gt;Identifier.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;{NBE, Arith, ArithWithCasts, StripLiteralCasts, ToFancy, ToFancyWithCasts}.v&lt;/code&gt;: Use the tactic from &lt;code&gt;AllTactics.v&lt;/code&gt;
together with the proven list of rewrite rules from
&lt;code&gt;RulesProofs.v&lt;/code&gt; to reify and reduce the corresponding pass
and generate a rewriter.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;All.v&lt;/code&gt;: &lt;code&gt;Definition&lt;/code&gt;less file that &lt;code&gt;Export&lt;/code&gt;s the rewriters
defined in &lt;code&gt;Rewriter/*.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Proofs files:
For &lt;code&gt;Language.v&lt;/code&gt;, there is a semi-arbitrary split between two files
&lt;code&gt;Language.Inversion&lt;/code&gt; and &lt;code&gt;Language.Wf&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Inversion.v&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;classifies equality of type codes and exprs&lt;/li&gt;
&lt;li&gt;type codes have decidable equality&lt;/li&gt;
&lt;li&gt;correctness of the various type-transport definitions&lt;/li&gt;
&lt;li&gt;correctness lemmas for the various &lt;code&gt;expr.invert_*&lt;/code&gt; definitions&lt;/li&gt;
&lt;li&gt;correctness lemmas for the various &lt;code&gt;reify_*&lt;/code&gt; definitions in &lt;code&gt;Language.v&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inversion_type&lt;/code&gt;, which inverts equality of type codes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type_beq_to_eq&lt;/code&gt;, which converts boolean equality of types to
Leibniz equality&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rewrite_type_transport_correct&lt;/code&gt;, which rewrites with the
correctness lemmas of the various type-transport definitions&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type.invert_one e&lt;/code&gt; which does case analysis on any inductive type
indexed over type codes, in a way that preserves information
about the type of &lt;code&gt;e&lt;/code&gt;, and generally works even when the goal is
dependently typed over &lt;code&gt;e&lt;/code&gt; and/or its type&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ident.invert&lt;/code&gt;, which does case-anaylsis on idents whose type has
structure (i.e., is not a var)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ident.invert_match&lt;/code&gt;, which does case-analysis on idents appearing as
the discriminee of a &lt;code&gt;match&lt;/code&gt; in the goal or in any hypothesis&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.invert&lt;/code&gt;, which does case-anaylsis on exprs whose type has
structure (i.e., is not a var)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.invert_match&lt;/code&gt;, which does case-analysis on exprs appearing as
the discriminee of a &lt;code&gt;match&lt;/code&gt; in the goal or in any hypothesis&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.invert_subst&lt;/code&gt;, which does case-analysis on exprs which show up
in hypotheses of the form &lt;code&gt;expr.invert_* _ = Some _&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.inversion_expr&lt;/code&gt;, which inverts equalities of exprs&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Wf.v&lt;/code&gt;: Depends on &lt;code&gt;Inversion.v&lt;/code&gt;
Defines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;expr.wf, expr.Wf, expr.wf3, expr.Wf3&lt;/li&gt;
&lt;li&gt;GeneralizeVar.Flat.wf&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.inversion_wf&lt;/code&gt; (and variants), which invert &lt;code&gt;wf&lt;/code&gt; hypotheses&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.wf_t&lt;/code&gt; (and variants wf_unsafe_t and wf_safe_t) which make
progress on &lt;code&gt;wf&lt;/code&gt; goals; &lt;code&gt;wf_safe_t&lt;/code&gt; should never turn a provable
goal into an unprovable one, while &lt;code&gt;wf_unsafe_t&lt;/code&gt; might.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr.interp_t&lt;/code&gt; (and variants), which should make progress on
equivalence-of-interp hypotheses and goals, but is not used much
(mainly because I forgot I had defined it)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prove_Wf&lt;/code&gt;, which proves wf goals on concrete syntax trees in a more
optimized way than &lt;code&gt;repeat constructor&lt;/code&gt;
Proves:&lt;/li&gt;
&lt;li&gt;funext → (type.eqv ↔ Logic.eq) (&lt;code&gt;eqv_iff_eq_of_funext&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;type.related and type.eqv are PERs&lt;/li&gt;
&lt;li&gt;Proper instances for &lt;code&gt;type.app_curried&lt;/code&gt;, &lt;code&gt;type.and_for_each_lhs_of_arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type.is_not_higher_order&lt;/code&gt; → Reflexive (type.and_for_each_lhs_of_arrow type.eqv)&lt;/li&gt;
&lt;li&gt;iff between &lt;code&gt;type.related{,_hetero}&lt;/code&gt; and related of &lt;code&gt;type.app_curried&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;various properties of &lt;code&gt;type.and{,b_bool}for_each_lhs_of_arrow&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;various properties of &lt;code&gt;type.eqv&lt;/code&gt; and &lt;code&gt;ident.{gen_,}interp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;various properties of &lt;code&gt;ident.cast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;various properties of &lt;code&gt;expr.wf&lt;/code&gt; (particularly of things defined in &lt;code&gt;Language.v&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;interp and wf proofs for the passes to/from Flat&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;UnderLetsProofs.v&lt;/code&gt;: wf and interp lemmas for the various passes defined in &lt;code&gt;UnderLets.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MiscCompilerPassesProofs.v&lt;/code&gt;: wf and interp lemmas for the various passes defined in &lt;code&gt;MiscCompilerPasses.v&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractInterpretation/ZRangeProofs.v&lt;/code&gt;: Proves correctness lemmas of the per-operation zrange-bounds-analysis functions&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractInterpretation/Wf.v&lt;/code&gt;: wf lemmas for the AbstractInterpretation pass&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;AbstractInterpretation/Proofs.v&lt;/code&gt;: interp lemmas for the
AbstractInterpretation pass, and also correctness lemmas that
combine Wf and interp&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>mit-plv</author><guid isPermaLink="false">https://github.com/mit-plv/fiat-crypto</guid><pubDate>Mon, 13 Jan 2020 00:01:00 GMT</pubDate></item><item><title>thery/coqprime #2 in Coq, Today</title><link>https://github.com/thery/coqprime</link><description>&lt;p&gt;&lt;i&gt;Prime numbers for Coq&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;p&gt;&lt;a href="https://travis-ci.org/thery/coqprime" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/6c6e69fd259119f6d4f7b40a0a257716e61b5ca9/68747470733a2f2f7472617669732d63692e6f72672f74686572792f636f717072696d652e7376673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/thery/coqprime.svg?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a id="user-content-coqprime" class="anchor" aria-hidden="true" href="#coqprime"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;coqprime&lt;/h1&gt;
&lt;p&gt;CoqPrime is a library built on top of the Coq proof system to certify primality using Pocklington certificate and Elliptic Curve Certificate. It is a nice illustration of what we can do with safe computation inside a prover. The library consists of 4 main parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A library of facts from number theory: the goal was to prove the theorems relative to Pocklington certificate. The library includes some very nice theorems like Lagrange theorem, Euler-Fermat theorem.&lt;/li&gt;
&lt;li&gt;A library for elliptic curves&lt;/li&gt;
&lt;li&gt;An efficient library to perform modular arithmetic: using the standard representation of integers in Coq was not sufficient to tackle large prime numbers so we have developped our own modular arithmetic based on tree-like structures. The library includes comparison, successor, predecessor, complement, addition, subtraction, multiplication, square, division, square root, gcd, power and modulo.&lt;/li&gt;
&lt;li&gt;A C program that generates Pocklington certificates. This program is based on ECM and some scripts that turn a certificate generated by primo into a Coq file&lt;/li&gt;
&lt;/ul&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>thery</author><guid isPermaLink="false">https://github.com/thery/coqprime</guid><pubDate>Mon, 13 Jan 2020 00:02:00 GMT</pubDate></item></channel></rss>