<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>GitHub Trending: Smalltalk, Today</title><link>https://github.com/trending/smalltalk?since=daily</link><description>The top repositories on GitHub for smalltalk, measured daily</description><pubDate>Sun, 12 Jan 2020 01:10:16 GMT</pubDate><lastBuildDate>Sun, 12 Jan 2020 01:10:16 GMT</lastBuildDate><generator>PyRSS2Gen-1.1.0</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><ttl>720</ttl><item><title>pharo-contributions/OSSubprocess #1 in Smalltalk, Today</title><link>https://github.com/pharo-contributions/OSSubprocess</link><description>&lt;p&gt;&lt;i&gt;Forking Operating System Processes from within Pharo Language&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;p&gt;&lt;a href="https://travis-ci.org/marianopeck/OSSubprocess" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/384c1b6f1dfbe3234d6ff8b0f61ade3da87f99c9/68747470733a2f2f7472617669732d63692e6f72672f706861726f2d636f6e747269627574696f6e732f4f5353756270726f636573732e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/pharo-contributions/OSSubprocess.png?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;&lt;a id="user-content-ossubprocess" class="anchor" aria-hidden="true" href="#ossubprocess"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;OSSubprocess&lt;/h1&gt;
&lt;p&gt;OSSubprocess is a software project that allows the user to spawn Operating System processes from within Pharo language. The main usage of forking external OS processes is to execute OS commands (.e.g &lt;code&gt;cat&lt;/code&gt;, &lt;code&gt;ls&lt;/code&gt;, &lt;code&gt;ps&lt;/code&gt;, &lt;code&gt;cp&lt;/code&gt;, etc) as well as arbitrary shell scripts (.e.g &lt;code&gt;/etc/myShellScript.sh&lt;/code&gt;) from Pharo.&lt;/p&gt;
&lt;p&gt;An important part of OSSubprocess is how to manage standard streams (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) and how to provide an API for reading and writing from them at the language level.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It was decided together with Pharo Consortium that as a first step, we should concentrate on making it work on OSX and Unix. If the tool proves to be good and accepted, we could, at a second step, try to add Windows support.
OSSubprocess is still in an exploring phase and so it might be unstable. Use this tool with that in mind. That being said, all tests are green in the tested platforms.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id="user-content-table-of-contents" class="anchor" aria-hidden="true" href="#table-of-contents"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Table of Contents&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ossubprocess"&gt;OSSubprocess&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#table-of-contents"&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#installation"&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#getting-started"&gt;Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#api-reference"&gt;API Reference&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#child-exit-status"&gt;Child exit status&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#ossvmprocess-and-its-child-watcher"&gt;OSSVMProcess and it's child watcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#accessing-child-status-and-interpreting-it"&gt;Accessing child status and interpreting it&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#streams-management"&gt;Streams management&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#handling-pipes-within-pharo"&gt;Handling pipes within Pharo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#regular-files-vs-pipes"&gt;Regular files vs pipes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#customizing-streams-creation"&gt;Customizing streams creation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#stdin-example"&gt;Stdin example&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#synchronism-and--how-to-read-streams"&gt;Synchronism and  how to read streams&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#synchronism-vs-asynchronous-runs"&gt;Synchronism vs asynchronous runs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#when-to-process-streams"&gt;When to process streams&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#streams-processing-at-the-end"&gt;Streams processing at the end&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#semaphore-based-sigchld-waiting"&gt;Semaphore-based SIGCHLD waiting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#delay-based-polling-waiting"&gt;Delay-based polling waiting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#which-waiting-to-use"&gt;Which waiting to use?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#processing-streams-while-running"&gt;Processing streams while running&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#asynchronous-runs"&gt;Asynchronous runs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#sending-signals-to-processes"&gt;Sending signals to processes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#system-shutdown"&gt;System shutdown&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#environment-variables"&gt;Environment variables&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#setting-environment-variables"&gt;Setting environment variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#variables-are-not-expanded"&gt;Variables are not expanded&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#accessing-environment-variables"&gt;Accessing environment variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#inherit-variables-from-parent"&gt;Inherit variables from parent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#shell-commands"&gt;Shell commands&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#setting-working-directory"&gt;Setting working directory&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#running-the-tests"&gt;Running the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contributing"&gt;Contributing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#history"&gt;History&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#future-work"&gt;Future work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#authors"&gt;Authors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#license"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#acknowledgments"&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#funding"&gt;Funding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Currently, OSSubprocess only works in Pharo &amp;gt;= 5.0 with Spur VM&lt;/strong&gt;. In any case, we recommend to always grab a latest image and VM. You can do that in via command line:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;wget -O- get.pharo.org/alpha+vm &lt;span class="pl-k"&gt;|&lt;/span&gt; bash&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, from within Pharo, execute the following to install OSSubprocess:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
 	&lt;span class="pl-c1"&gt;baseline:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;OSSubprocess&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
 	&lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;github://pharo-contributions/OSSubprocess:master/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	load.&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;Important: Do not load OSProcess project in the same image of OSSubprocess because the latter won't work.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Important2: If you are installing under Linux, then you must use a threaded heartbeat VM (not the itimer one). For Pharo 5.0 and 6.0 you can search for "cog_linux32x86_pharo.cog.spur_XXXXXXXXXXXX.tar.gz" i32 &lt;a href="http://files.pharo.org/vm/pharo-spur32/linux/" rel="nofollow"&gt;Pharo static file server&lt;/a&gt;. Since Pharo 7.0, threaded heartbeat VM has become the default installation, so you shouldn't have to explicitly download a specific VM.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Besides the above installation instructions, OSSubprocess can also be installed from the &lt;code&gt;Catalog Browser&lt;/code&gt;, already present in Pharo. Just open it, search for OSSubprocess, then right click, &lt;code&gt;Install stable version&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;OSSubprocess is quite easy to use but depending on the user needs, there are different parts of the API that could be used. We start with a basic example and later we show more complicated scenarios.&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/ls&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-la' '/Users')&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt;  |
		outString inspect
	]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Until we add support for Windows, the entry point will always be OSSUnixSubprocess, which should work in OSX, Linux and others Unix-like. You can read it's class comments for details.&lt;/p&gt;
&lt;p&gt;A subprocess consist of at least a command/binary/program to be executed (in this example &lt;code&gt;/bin/ls&lt;/code&gt;) plus some optional array of arguments.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;#command:&lt;/code&gt; could be either the program name (.e.g &lt;code&gt;ls&lt;/code&gt;) or the full path to the executable (.e.g &lt;code&gt;/bin/ls&lt;/code&gt;). If the former, then the binary will be searched using &lt;code&gt;$PATH&lt;/code&gt; variable and may not be found.&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;#arguments:&lt;/code&gt; array, each argument must be a different element. In other words, passing &lt;code&gt;#('-la /Users')&lt;/code&gt; is not correct since those are 2 arguments and hence should be 2 elements of the array. It is also incorrect to not specify &lt;code&gt;#arguments:&lt;/code&gt; and specify the command like this: &lt;code&gt;command: '/bin/ls -la /Users'&lt;/code&gt;. OSSubprocess does &lt;em&gt;not&lt;/em&gt; do any parsing of the command or arguments. If you want to execute a command with a full string like &lt;code&gt;/bin/ls -la /Users&lt;/code&gt;, you may want to take a look to &lt;code&gt;#bashCommand:&lt;/code&gt; which relies on shell to do that job.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;#redirectStdout&lt;/code&gt; we are saying that we want to create a stream and that we want to map it to &lt;code&gt;stdout&lt;/code&gt; of the child process. Since they are not specified, &lt;code&gt;stderr&lt;/code&gt; and &lt;code&gt;stdin&lt;/code&gt; will then be inherit from the parent process (Pharo VM process). If you comment out the line of &lt;code&gt;#redirectStdout&lt;/code&gt; and run the example again, you can see how the output of &lt;code&gt;/bin/ls -la /Users&lt;/code&gt; is printed in the terminal (where you launched your Pharo image).&lt;/p&gt;
&lt;p&gt;Finally, we use the &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; which is a high level API method that runs the process, waits for it until it finishes, reads and then closes the &lt;code&gt;stdout&lt;/code&gt; stream, and finally invokes the passed closure. In the closure we get as arguments the original &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; instance we created, and the contents of the read &lt;code&gt;stdout&lt;/code&gt;. If you inspect &lt;code&gt;outString&lt;/code&gt; you should see the output of &lt;code&gt;/bin/ls -la /Users&lt;/code&gt; which should be exactly the same as if run from the command line.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-api-reference" class="anchor" aria-hidden="true" href="#api-reference"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;API Reference&lt;/h2&gt;
&lt;h3&gt;&lt;a id="user-content-child-exit-status" class="anchor" aria-hidden="true" href="#child-exit-status"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Child exit status&lt;/h3&gt;
&lt;p&gt;When you spawn a process in Unix, the new process becomes a "child" of the "parent" process that launched it. In our case, the parent process is the Pharo VM process and the child process would be the one executing the command (in above example, &lt;code&gt;/bin/ls&lt;/code&gt;). It is a responsibility of the parent process to collect the exit status of the child once it finishes. If the parent does not do this, the child becomes a "zombie" process. The exit status is an integer that represents how the child finished (if successful, if error, which error, if received a signal, etc etc.). Besides avoiding zombies, the exit status is also important for the user to take actions depending on its result.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-ossvmprocess-and-its-child-watcher" class="anchor" aria-hidden="true" href="#ossvmprocess-and-its-child-watcher"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;OSSVMProcess and it's child watcher&lt;/h4&gt;
&lt;p&gt;In OSSubprocess, we have a class &lt;code&gt;OSSVMProcess&lt;/code&gt; with a singleton instance accessed via a class side method &lt;code&gt;vmProcess&lt;/code&gt; which represents the operating system process in which the Pharo VM is currently running. OSSVMProcess can answer some information about the OS process running the VM, such as running PID, children, etc etc. More can be added later.&lt;/p&gt;
&lt;p&gt;Another important task of this class is to keep track of all the launched child processes (instances of &lt;code&gt;OSSUnixSubprocess&lt;/code&gt;). Whenever a process is started it's registered in OSSVMProcess and unregister in certain scenarios (see senders of &lt;code&gt;#unregisterChildProcess:&lt;/code&gt;). We keep a  list of all our children, and occasionally prune all those that have already exited.&lt;/p&gt;
&lt;p&gt;This class takes care of running what we call the "child watcher" which is basically a way to monitor children's status and collect exit code when they finish. This also guarantees not to create zombies processes. As for the implementation details, we use a SIGCHLD handler to capture a child death. For more details, see method &lt;code&gt;#initializeChildWatcher&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is important here is that whether you wait for the process to finish or not (and no matter in which way you wait), the child exit code will be collected and stored in the &lt;code&gt;exitStatus&lt;/code&gt; instVar of the instance of &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; representing the exited process, thanks to the &lt;code&gt;OSSVMProcess&lt;/code&gt; child watcher.&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-accessing-child-status-and-interpreting-it" class="anchor" aria-hidden="true" href="#accessing-child-status-and-interpreting-it"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Accessing child status and interpreting it&lt;/h4&gt;
&lt;p&gt;No matter how you waited for the child process to finish, when it exited, the instVar &lt;code&gt;exitStatus&lt;/code&gt; should have been set. &lt;code&gt;exitStatus&lt;/code&gt; is an integer bit field answered by the &lt;code&gt;wait()&lt;/code&gt; system call that contains information about the exit status of the process. The meaning of the bit field varies according to the cause of the process exit. Besides understanding &lt;code&gt;#exitStatus&lt;/code&gt;, &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; also understands &lt;code&gt;#exitStatusInterpreter&lt;/code&gt; which answers an instance of &lt;code&gt;OSSUnixProcessExitStatus&lt;/code&gt;. The task of this class is to simply decode this integer bit field and provide meaningful information. Please read its class comment for further details.&lt;/p&gt;
&lt;p&gt;In addition to &lt;code&gt;#exitStatus&lt;/code&gt; and &lt;code&gt;#exitStatusInterpreter&lt;/code&gt;, &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; provides testing methods such us &lt;code&gt;#isSuccess&lt;/code&gt;, &lt;code&gt;#isComplete&lt;/code&gt;, &lt;code&gt;isRunning&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;Let's see a possible usage of the exit status:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/ls&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-la' '/nonexistent')&lt;/span&gt;;
	redirectStdout;
	redirectStderr;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; &lt;span class="pl-en"&gt;:errString&lt;/span&gt; |
		process isSuccess
			&lt;span class="pl-k"&gt;ifTrue:&lt;/span&gt; [ &lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Command exited correctly with output: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, outString. ]
			&lt;span class="pl-k"&gt;ifFalse:&lt;/span&gt; [
				&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;OSSUnixProcessExitStatus has a nice #printOn: &lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
				&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Command exit with error status: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, process exitStatusInterpreter printString; cr.
				&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Stderr contents: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, errString.
			]
	]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example we execute &lt;code&gt;/bin/ls&lt;/code&gt; passing a none existing directory as argument.&lt;/p&gt;
&lt;p&gt;First, note that we add also a stream for &lt;code&gt;stderr&lt;/code&gt; via &lt;code&gt;#redirectStderr&lt;/code&gt;. Second, note how now in the &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; we can also have access to &lt;code&gt;errString&lt;/code&gt;. If you run this example with a &lt;code&gt;Transcript&lt;/code&gt; opened, you should see something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Command exit with error status: normal termination with status 1
Stderr contents: ls: /nonexistent: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;normal termination with status 1&lt;/code&gt; is the information that &lt;code&gt;OSSUnixProcessExitStatus&lt;/code&gt; (accessed via &lt;code&gt;#exitStatusInterpreter&lt;/code&gt;) decoded for us. "Normal termination" means it was not signaled or terminated, but rather a normal exit. The exit status bigger than zero (in this case, 1), means error. What each error means depends on the program you run.&lt;/p&gt;
&lt;p&gt;The second line of the &lt;code&gt;Transcript&lt;/code&gt; is simply the &lt;code&gt;stderr&lt;/code&gt; contents.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-streams-management" class="anchor" aria-hidden="true" href="#streams-management"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Streams management&lt;/h3&gt;
&lt;p&gt;There are many parts of the API and features of OSSubprocess which are related to streams. In this section we will try to explain these topics.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-handling-pipes-within-pharo" class="anchor" aria-hidden="true" href="#handling-pipes-within-pharo"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Handling pipes within Pharo&lt;/h4&gt;
&lt;p&gt;Besides regular files (as the files you are used to deal with), Unix provides &lt;strong&gt;pipes&lt;/strong&gt;. Since Unix manages pipes  polymorphically to regular files, you can use both for mapping standard streams (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;). That means that both kind of files can be used to communicate a parent and a child process.&lt;/p&gt;
&lt;p&gt;For regular files, Pharo already provides &lt;code&gt;Stream&lt;/code&gt; classes to write and read from them, such as &lt;code&gt;StandardFileStream&lt;/code&gt; and subclasses. For pipes things are different because there is a write end and a read end (each having a different file descriptor at Unix level). For this purpose, we have implemented the class called &lt;code&gt;OSSPipe&lt;/code&gt; which represents a OS pipe and it is a subclass of &lt;code&gt;Stream&lt;/code&gt;. &lt;code&gt;OSSPipe&lt;/code&gt; contains both, a &lt;code&gt;reader&lt;/code&gt; and a &lt;code&gt;writer&lt;/code&gt;, and it implements the &lt;code&gt;Stream&lt;/code&gt; protocol by delegating messages to one or the other. For example &lt;code&gt;OSSPipe&amp;gt;&amp;gt;#nextPutAll:&lt;/code&gt; is delegated to the writer while &lt;code&gt;#next&lt;/code&gt; is delegated to the reader. That way, we have a Stream-like API for pipes. For more details, please read the class comment of &lt;code&gt;OSSPipe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The question is now what type of streams are the 'reader' and 'writer' instVars of a &lt;code&gt;OSSPipe&lt;/code&gt;. As I said before, the write end and read end of a pipe have different file descriptor at Unix level, hence they are seem as two different file streams. When we create a pipe via a system call, we directly get both file descriptors. That means that in Pharo, once we created a OS pipe, we already have both, the read and the write. Ideally, we could use &lt;code&gt;StandardFileStream&lt;/code&gt; for this case too. However, those file streams were &lt;em&gt;already opened&lt;/em&gt; by the system call to make the pipes. To solve this issue, we created what we call &lt;code&gt;OSSAttachableFileStream&lt;/code&gt; which is a special subclass of &lt;code&gt;StandardFileStream&lt;/code&gt; and that can be &lt;em&gt;attached&lt;/em&gt; to an already existing and opened file.&lt;/p&gt;
&lt;p&gt;To conclude, we use a system call to create an OS pipe. At Pharo level we represent that pipe as an instance of &lt;code&gt;OSSPipe&lt;/code&gt;. And a &lt;code&gt;OSSPipe&lt;/code&gt; has both, a reader and a writer which are both instances of &lt;code&gt;OSSAttachableFileStream&lt;/code&gt; and that have been attached to the reader and writer end of the pipe.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-regular-files-vs-pipes" class="anchor" aria-hidden="true" href="#regular-files-vs-pipes"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Regular files vs pipes&lt;/h4&gt;
&lt;p&gt;As we said before, both regular files or pipes can be used for mapping standard streams (&lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) and OSSubprocess supports both and manages them polymorphically thanks to &lt;code&gt;OSSPipe&lt;/code&gt; and &lt;code&gt;OSSAttachableFileStream&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important:&lt;/strong&gt; For regular files, you &lt;strong&gt;must&lt;/strong&gt; use instances of &lt;code&gt;StandardFileStream&lt;/code&gt; since we have some problems when using instances of &lt;code&gt;MultiByteFileStream&lt;/code&gt;. So... try not to use the &lt;code&gt;FileSystem&lt;/code&gt; library for creating file streams but rather &lt;code&gt;StandardFileStream&lt;/code&gt; directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The user can decide to use one or another. Pipes are normally faster since they run in memory. On the contrary, files may do I/0 operations even with caches (at least creating and deleting the file). With pipes you do not have to handle the deletion of the files as you do with regular files. You can read more about "regular files vs pipes" in the internet and come yourself to a conclusion.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt; We have found some problems when using regular files for the &lt;code&gt;stdin&lt;/code&gt;. While we do not strictly forbid that, we recommend you do so only if you know very well what you are doing. Otherwise, use blocking pipes for &lt;code&gt;stdin&lt;/code&gt; (default behavior).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt; Our recommendation as a rule of thumb is to always use pipes rather than regular files. That is, none-blocking pipes for &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; and blocking pipes for &lt;code&gt;stdin&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is only one problem with pipes that you should be aware of and it's the fact that you may get a deadlock in certain situations. See &lt;a href="#semaphore-based-sigchld-waiting"&gt;Semaphore-based SIGCHLD waiting&lt;/a&gt; for more details.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-customizing-streams-creation" class="anchor" aria-hidden="true" href="#customizing-streams-creation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Customizing streams creation&lt;/h4&gt;
&lt;p&gt;Let's consider this example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;| &lt;span class="pl-c1"&gt;process&lt;/span&gt; |
process &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
			&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/ls&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
			&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-la' '/nonexistent')&lt;/span&gt;;
			&lt;span class="pl-c1"&gt;defaultWriteStreamCreationBlock:&lt;/span&gt; [&lt;span class="pl-c1"&gt;OSSVMProcess&lt;/span&gt; vmProcess systemAccessor makeNonBlockingPipe];
			redirectStdout;
			&lt;span class="pl-c1"&gt;redirectStderrTo:&lt;/span&gt; (&lt;span class="pl-c1"&gt;StandardFileStream&lt;/span&gt; &lt;span class="pl-c1"&gt;forceNewFileNamed:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/tmp/customStderr.txt&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;);
			&lt;span class="pl-c1"&gt;defaultReadStreamCreationBlock:&lt;/span&gt; [ &lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-c1"&gt;createTempFileToBeUsedAsReadStreamOn:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/tmp&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; ];
			&lt;span class="pl-c1"&gt;createMissingStandardStreams:&lt;/span&gt; &lt;span class="pl-c1"&gt;true&lt;/span&gt;.
&lt;span class="pl-c1"&gt;Halt&lt;/span&gt; halt.			
process runAndWait.  
process isSuccess
	&lt;span class="pl-k"&gt;ifTrue:&lt;/span&gt; [ &lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Command exited correctly with output: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, process stdoutStream upToEndOfFile. ]
	&lt;span class="pl-k"&gt;ifFalse:&lt;/span&gt; [
		&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;OSSUnixProcessExitStatus has a nice #printOn: &lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
		&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Command exit with error status: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, process exitStatusInterpreter printString; cr.
		&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Stderr contents: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, process stderrStream upToEndOfFile.
	].
process closeAndCleanStreams.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There are many things to explain in this example. First of all, we are not using the API &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; and so certain things must be done manually (like retrieving the contents of the streams via &lt;code&gt;#upToEndOfFile&lt;/code&gt; and closing and cleaning streams with &lt;code&gt;#closeAndCleanStreams&lt;/code&gt;). Now you get a better idea of what &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; does automatically for you. The reason we are not using &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; and instead the low level API, is to have a &lt;code&gt;Halt halt&lt;/code&gt; while running the process so that you can confirm yourself the existence of the files used for the streams, as explained next.&lt;/p&gt;
&lt;p&gt;With the methods &lt;code&gt;#redirectStdinTo:&lt;/code&gt;, &lt;code&gt;#redirectStdoutTo:&lt;/code&gt; and &lt;code&gt;#redirectStdoutTo:&lt;/code&gt; the user is able to set a custom stream for each standard stream. The received stream could be either a &lt;code&gt;StandardFileStream&lt;/code&gt; (as is the result of &lt;code&gt;StandardFileStream forceNewFileNamed: '/tmp/customStderr.txt'&lt;/code&gt;) or a &lt;code&gt;OSSPipe&lt;/code&gt; (as is the result of &lt;code&gt;OSSVMProcess vmProcess systemAccessor makeNonBlockingPipe&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;If you do not want to create a custom stream (like above example of &lt;code&gt;#redirectStderrTo:&lt;/code&gt;) but you still want to create a default stream that would be mapped to a standard stream, then you can use the methods &lt;code&gt;#redirectStdin:&lt;/code&gt;, &lt;code&gt;#redirectStdout&lt;/code&gt; and &lt;code&gt;#redirectStderr&lt;/code&gt;. Those methods will create &lt;em&gt;default&lt;/em&gt; streams. The &lt;em&gt;default&lt;/em&gt; streams are defined by the instVars &lt;code&gt;defaultWriteStreamCreationBlock&lt;/code&gt; and &lt;code&gt;defaultReadStreamCreationBlock&lt;/code&gt;. And these can be customized too as shown in above example. In this example, all write streams (to be used for &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;) will be pipes (forget for the moment about the none blocking part). And all read streams (only used by &lt;code&gt;stdin&lt;/code&gt;) will be temp files automatically created in &lt;code&gt;/tmp&lt;/code&gt;. This feature is useful if you want to change the way streams are created without having to specially create each stream. You can see how &lt;code&gt;OSSPipeBasedUnixSubprocessTest&lt;/code&gt; and &lt;code&gt;OSSFileBasedUnixSubprocessTest&lt;/code&gt; use these in the method &lt;code&gt;#newCommand&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you see &lt;code&gt;OSSUnixSubprocess&amp;gt;&amp;gt;#initialize&lt;/code&gt; you will see that by default we create pipes for all type of streams.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Previously, we said that if the user does not specify a stream to be mapped to one of the standard streams (by any of the means explained above), the child will inherit the one of the parent process (VM Process). With the method &lt;code&gt;#createMissingStandardStreams:&lt;/code&gt; one can change that behavior, and instead, create default streams for all none already defined streams. In above example, the user defined &lt;code&gt;stdout&lt;/code&gt; via &lt;code&gt;#redirectStdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; via &lt;code&gt;#redirectStderrTo:&lt;/code&gt;. So, by doing &lt;code&gt;#createMissingStandardStreams: true&lt;/code&gt;, a default stream (pipe) will be created and mapped to the missing streams (only &lt;code&gt;stdin&lt;/code&gt; in this example). Of course, if you are happy with default streams creation, you can avoid having to declare each stream and simple enable all. But keep in mind the costs of managing streams that you may not use at all. For this reason, the default value of &lt;code&gt;createMissingStandardStreams&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Finally, note that since we are not using the API &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt; in this case, we must explicitly close streams via the message &lt;code&gt;#closeAndCleanStreams&lt;/code&gt;. This method will also take care of deleting all those streams which were regular files (not pipes).&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-stdin-example" class="anchor" aria-hidden="true" href="#stdin-example"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Stdin example&lt;/h4&gt;
&lt;p&gt;All of the examples so far showed how to redirect &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt;. Below is an example on how can we redirect &lt;code&gt;stdin&lt;/code&gt; and write to it from Pharo:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;| &lt;span class="pl-c1"&gt;process&lt;/span&gt; |
process &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
				&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/cat&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
				redirectStdin;
				redirectStdout;
				run.
process stdinStream
		&lt;span class="pl-c1"&gt;nextPutAll:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;we are testing!&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
		&lt;span class="pl-c1"&gt;nextPutAll:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;we again!&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
		close.		
process waitForExit.
process stdoutStream upToEndOfFile inspect.
process closeAndCleanStreams.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you run above example you will see how the strings are first written to the &lt;code&gt;stdin&lt;/code&gt; of the child process and then the child writes them to &lt;code&gt;stdout&lt;/code&gt; (that's what the &lt;code&gt;cat&lt;/code&gt; command does). We finally read them from &lt;code&gt;stdout&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note that the &lt;code&gt;#close&lt;/code&gt; we send to the &lt;code&gt;stdinStream&lt;/code&gt; is very important. This is because by default, we use blocking pipes for &lt;code&gt;stdin&lt;/code&gt; and that means that when the child tries to read he will be locked until data is available. Therefore, somehow, at some point, we must tell the child that we have finished writing and that is via the &lt;code&gt;#close&lt;/code&gt; message.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-synchronism-and--how-to-read-streams" class="anchor" aria-hidden="true" href="#synchronism-and--how-to-read-streams"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Synchronism and  how to read streams&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-synchronism-vs-asynchronous-runs" class="anchor" aria-hidden="true" href="#synchronism-vs-asynchronous-runs"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Synchronism vs asynchronous runs&lt;/h4&gt;
&lt;p&gt;We call synchronous runs when you create a child process and you wait for it to finish before going to the next task of your code. This is by far the most common approach since many times you need to know which was the exit status (wether it was success or not) or get some output, and depending on that, change the flow of your code.&lt;/p&gt;
&lt;p&gt;Asynchronous runs are when you run a process and you do not care it's results for the next task of your code. In other words, your code can continue its execution no matter what happened with the spawned process.&lt;/p&gt;
&lt;p&gt;Let's see this example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;| &lt;span class="pl-c1"&gt;process&lt;/span&gt; |
process &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
				&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/ls&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
				run. 	
process waitForExit.
process isSuccess
	&lt;span class="pl-k"&gt;ifTrue:&lt;/span&gt; [ &lt;span class="pl-k"&gt;self&lt;/span&gt; doSomethingWithSucess ]
	&lt;span class="pl-k"&gt;ifFalse:&lt;/span&gt; [ &lt;span class="pl-k"&gt;self&lt;/span&gt; doSomethingWithFailure ].
process closeAndCleanStreams.
&lt;span class="pl-k"&gt;self&lt;/span&gt; myNextCodeAction.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;myNextCodeAction&lt;/code&gt; represents the user code (user of this library) that will run after spawning the process. The important question here is when should the line &lt;code&gt;self myNextCodeAction&lt;/code&gt; be executed? Does &lt;code&gt;myNextCodeAction&lt;/code&gt; depend on the exit status of the forked process or it needs some of its output?&lt;/p&gt;
&lt;p&gt;If &lt;code&gt;myNextCodeAction&lt;/code&gt; should be executed after the forked process has finished, then it is synchronous. Otherwise, asynchronous.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The way the previous and next examples are written are actually synchronous. In &lt;a href="#asynchronous-runs"&gt;Asynchronous runs&lt;/a&gt; we see how can we make asynchronous calls.&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-when-to-process-streams" class="anchor" aria-hidden="true" href="#when-to-process-streams"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;When to process streams&lt;/h4&gt;
&lt;p&gt;If we have defined that we wanted to map a standard stream, it means that at some point we would like to read/write it and &lt;strong&gt;do something with it&lt;/strong&gt;.
There are basically two possibilities here. The most common approach is to simply wait until the process has finished, and once finished, depending on the exit status, &lt;strong&gt;do something&lt;/strong&gt; with the stream contents. What to do exactly, depends on the needs the user has for that process.&lt;/p&gt;
&lt;p&gt;The other possibility a user may do, is to define some code that loops while the process is still running. For every cycle of the loop, it retrieves what is available from the streams and do something with it. But in this case, &lt;strong&gt;doing something&lt;/strong&gt; is not simply accumulating the stream contents in another stream so that it is processed at the end. By doing something we really mean that the user wants to do something with that intermediate result: print it in a &lt;code&gt;Transcript&lt;/code&gt;, show a progress bar, or whatever.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-streams-processing-at-the-end" class="anchor" aria-hidden="true" href="#streams-processing-at-the-end"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Streams processing at the end&lt;/h4&gt;
&lt;p&gt;For the scenario in which streams processing should be done once a process has exited, we provide some facilities methods that should ease the usage. Processing the streams at the end also means that somehow we should wait for the process to finish. We provide two ways of doing this.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-semaphore-based-sigchld-waiting" class="anchor" aria-hidden="true" href="#semaphore-based-sigchld-waiting"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Semaphore-based SIGCHLD waiting&lt;/h5&gt;
&lt;p&gt;The first way is with the method &lt;code&gt;#waitForExit&lt;/code&gt;. This method is used by the high level API methods &lt;code&gt;#runAndWait&lt;/code&gt; and &lt;code&gt;#runAndWaitOnExitDo:&lt;/code&gt;. The wait in this scenario does &lt;strong&gt;not&lt;/strong&gt; use an image-based delay polling. Instead, it uses a semaphore. Just after the process starts, it waits on a semaphore of the instVar &lt;code&gt;mutexForSigchld&lt;/code&gt;. When the &lt;code&gt;OSSVMProcess&lt;/code&gt; child watcher receives a &lt;code&gt;SIGCHLD&lt;/code&gt; signal, it will notify the child that die with the message &lt;code&gt;#processHasExitNotification&lt;/code&gt;. That method, will do the &lt;code&gt;#signal&lt;/code&gt; in the semaphore and hence the execution of &lt;code&gt;#waitForExit&lt;/code&gt; will continue.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANT&lt;/strong&gt; In this kind of waiting there is no polling and hence we do not read from the streams periodically. Instead, we read the whole contents of each stream at the end. Basically, there is a problem in general (deadlock!) with waiting for an external process to exit before reading its output. If the external process creates a large amount of output, and if the output is a pipe, it will block on writing to the pipe until someone (our VM process) reads some data from the pipe to make room for the writing. That leads to cases where we never read the output (because the external process did not exit) and the external process never exits (because we have not read the data from the pipe to make room for the writing).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Another point to take into account is that this kind of wait also depends on the child watcher and &lt;code&gt;SIGCHLD&lt;/code&gt; capture. While we do our best to make this as reliable as possible, it might be cases where we miss some &lt;code&gt;SIGCHLD&lt;/code&gt; signals. There is a workaround for that (see method &lt;code&gt;#initializeChildWatcher&lt;/code&gt;), but there may still be issues. If such problem happens, the child process (at our language level) never exits from the &lt;code&gt;#waitForExit&lt;/code&gt; method. And at the OS level, the child would look like a zombie because the parent did not collect the exit status.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5&gt;&lt;a id="user-content-delay-based-polling-waiting" class="anchor" aria-hidden="true" href="#delay-based-polling-waiting"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Delay-based polling waiting&lt;/h5&gt;
&lt;p&gt;The other way we have for waiting a child process is by doing a delay-based in-image polling. That basically means a loop in which we wait some milliseconds, and then check the exit status of the process. For this, we provide the method &lt;code&gt;#waitForExitPollingEvery:retrievingStreams:&lt;/code&gt;, and it's high level API method &lt;code&gt;#runAndWaitPollingEvery:retrievingStreams:onExitDo:&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is important to note that as part of the loop we send &lt;code&gt;#queryExitStatus&lt;/code&gt;, which is the one that sends the &lt;code&gt;waitpid()&lt;/code&gt; in Unix. That means that we are fully independent of the child watcher and the &lt;code&gt;SIGCHLD&lt;/code&gt; and hence much more reliable than the previous approach.&lt;/p&gt;
&lt;p&gt;In addition, we provide a &lt;code&gt;retrievingStreams:&lt;/code&gt; boolean which if true, it reads from streams as part of the loop. This solves the problem mentioned before where there could be a deadlock if there is no room in the pipe for the writing.&lt;/p&gt;
&lt;p&gt;Below is an example of delay polling:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/ls&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-la' '/Users')&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitPollingEvery:&lt;/span&gt; (&lt;span class="pl-c1"&gt;Delay&lt;/span&gt; &lt;span class="pl-c1"&gt;forMilliseconds:&lt;/span&gt; &lt;span class="pl-c1"&gt;50&lt;/span&gt;) &lt;span class="pl-c1"&gt;retrievingStreams:&lt;/span&gt; &lt;span class="pl-c1"&gt;true&lt;/span&gt; &lt;span class="pl-c1"&gt;onExitDo:&lt;/span&gt; [
		:process :outString  &lt;span class="pl-k"&gt;|&lt;/span&gt;
		outString inspect
	]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, the main disadvantage of the polling is the cost of it at the language level. The waiting on a semaphore (as with the &lt;code&gt;SIGCHLD&lt;/code&gt;) has no cost.&lt;/p&gt;
&lt;h5&gt;&lt;a id="user-content-which-waiting-to-use" class="anchor" aria-hidden="true" href="#which-waiting-to-use"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Which waiting to use?&lt;/h5&gt;
&lt;p&gt;If you are using pipes (which is our recommendation) and you are not sure about how much the child process could write in the streams, then we recommend the polling approach (with &lt;code&gt;retrievingStreams:&lt;/code&gt; with &lt;code&gt;true&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;If you are using pipes and you know the process will not write much, then you can use both approaches. If you want to be sure 100% to never ever get a zombie or related problem, then we think the polling approach is a bit more reliable. If you can live with such a possibility, then maybe the &lt;code&gt;SIGCHLD&lt;/code&gt; approach could work too.&lt;/p&gt;
&lt;p&gt;If you are using files instead of pipes, then it would depend on how long does the process take. If it is normally short, then the polling approach would be fine. If it is a long process then you may want to do the &lt;code&gt;SIGCHLD&lt;/code&gt; approach to avoid the polling costs. But you can also use the polling approach and specify a larger timeout.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;As you can see, there is no silver bullet. It's up to the user to know which model would fit better for his use-case. If you are uncertain or you are not an expert, then go with the polling approach with &lt;code&gt;retrievingStreams:&lt;/code&gt; on &lt;code&gt;true&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-processing-streams-while-running" class="anchor" aria-hidden="true" href="#processing-streams-while-running"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Processing streams while running&lt;/h4&gt;
&lt;p&gt;Instead of processing the streams once the process has finished, the other alternative is to process the streams while the process runs.&lt;/p&gt;
&lt;p&gt;To demonstrate the facilities we provide for this case, we will see an example in which we invoke the command &lt;code&gt;tail -f /var/log/system.log&lt;/code&gt;. In this example we use &lt;code&gt;/var/log/system.log&lt;/code&gt; because it's a file whose contents grows frequently on OSX, but the example could apply to any file. What the example does is to poll with a delay and in every cycle of the loop, read from &lt;code&gt;stdout&lt;/code&gt; and append that into a &lt;code&gt;Pharo Playground&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;| &lt;span class="pl-c1"&gt;streamsInfo&lt;/span&gt; &lt;span class="pl-c1"&gt;totalStdout&lt;/span&gt; &lt;span class="pl-c1"&gt;page&lt;/span&gt; &lt;span class="pl-c1"&gt;playground&lt;/span&gt; |
totalStdout &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;String&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt; writeStream.
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;These first lines just open a Pharo Playground with an initial content&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
(page &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;GTPlayPage&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;)
	&lt;span class="pl-c1"&gt;saveContent:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;initial content&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;.
(playground &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;GTPlayground&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;)
	&lt;span class="pl-c1"&gt;openOn:&lt;/span&gt; page.
[
	&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;tail&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-f' '/var/log/system.log' )&lt;/span&gt;;
	redirectStdout;
	redirectStderr;
	&lt;span class="pl-c1"&gt;runAndWaitPollingEvery:&lt;/span&gt; (&lt;span class="pl-c1"&gt;Delay&lt;/span&gt; &lt;span class="pl-c1"&gt;forMilliseconds:&lt;/span&gt; &lt;span class="pl-c1"&gt;500&lt;/span&gt;)
	&lt;span class="pl-c1"&gt;doing:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outStream&lt;/span&gt; &lt;span class="pl-en"&gt;:errStream&lt;/span&gt; |  
		| &lt;span class="pl-c1"&gt;read&lt;/span&gt; |
		read &lt;span class="pl-k"&gt;:=&lt;/span&gt; outStream upToEnd.
		&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;Next 2 lines is to simply update the Playground&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
		page &lt;span class="pl-c1"&gt;saveContent:&lt;/span&gt; (page content, read).
		playground update.
		totalStdout &lt;span class="pl-c1"&gt;nextPutAll:&lt;/span&gt; read.
		errStream upToEnd.
	]
	&lt;span class="pl-c1"&gt;onExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outStream&lt;/span&gt; &lt;span class="pl-en"&gt;:errStream&lt;/span&gt;  |
		process closeAndCleanStreams.
		&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Total stdout: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, totalStdout contents.
	]
] fork.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you run above code, you will see how a Pharo Playground is opened and every half second the contents are refreshed and appended at the end. The most important method here is &lt;code&gt;runAndWaitPollingEvery:doing:onExitDo:&lt;/code&gt; which is the facility we provide for these scenarios. However, there are other points to mention:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The user must explicitly close streams. It could be inside the &lt;code&gt;onExitDo:&lt;/code&gt; or elsewhere, but must be done. We cannot automatically close streams because we don't know if the user has retrieved their contents or not (we cannot know what the user will do in the &lt;code&gt;doing:&lt;/code&gt; closure).&lt;/li&gt;
&lt;li&gt;If using pipes, the user must be sure to either retrieve steam contents as part of the &lt;code&gt;doing:&lt;/code&gt; block or else make sure the process will not be writing much on them. Otherwise, you may hit the deadlock mentioned in &lt;a href="#semaphore-based-sigchld-waiting"&gt;Semaphore-based SIGCHLD waiting&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Contrary to regular files, the read of a pipe &lt;strong&gt;consumes&lt;/strong&gt; the read. That is, you cannot read more than once a particular content. So for example, say you read from &lt;code&gt;stdout&lt;/code&gt; in the &lt;code&gt;doing:&lt;/code&gt; closure and then in &lt;code&gt;onExitDo:&lt;/code&gt; you would like to do something with the total of the &lt;code&gt;stdout&lt;/code&gt; (in this example, print it in the &lt;code&gt;Transcript&lt;/code&gt;). If you read from &lt;code&gt;stdout&lt;/code&gt; in &lt;code&gt;onExitDo:&lt;/code&gt;, in this example, you will get nothing, because it was already read and consumed. To avoid loosing what you read (in case you need it later), you must store it somewhere yourself (in this example in the temp variable &lt;code&gt;totalStdout&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;So far in this guide we have always used &lt;code&gt;upToEndOfFile&lt;/code&gt; to retrieve streams contents. Sending such message is ideal once the process has exited. But if it is running and still writing into the standard streams, then the message to send is &lt;code&gt;upToEnd&lt;/code&gt; which simply reads all available data in the stream. And that does not necessary mean the end of the file or the pipe (the child process may have written even more on it).&lt;/li&gt;
&lt;li&gt;For this type of "Processing streams while running" we strongly recommend pipes over regular files.&lt;/li&gt;
&lt;li&gt;If we run above code without the &lt;code&gt;fork&lt;/code&gt; it will work but the Pharo UI will not be refreshed and it won't display the new Playground until the process has stopped. This could be considered as an example of asynchronous calls as explained in &lt;a href="#asynchronous-runs"&gt;Asynchronous runs&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;a id="user-content-asynchronous-runs" class="anchor" aria-hidden="true" href="#asynchronous-runs"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Asynchronous runs&lt;/h4&gt;
&lt;p&gt;The previous example of the &lt;code&gt;tail -f&lt;/code&gt; was an asynchronous run. Why? Because we wanted the user code to continue running (in this case the Pharo UI showing us the Playground with the &lt;code&gt;tail&lt;/code&gt; contents) regardless of what happened with the spawned process. In general, the way to launch asynchronous processes is like this:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;[
&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;whatever&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#()&lt;/span&gt;;
	...
] fork.
&lt;span class="pl-k"&gt;self&lt;/span&gt; continueWithOtherCode.&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;a id="user-content-sending-signals-to-processes" class="anchor" aria-hidden="true" href="#sending-signals-to-processes"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Sending signals to processes&lt;/h3&gt;
&lt;p&gt;OSSubprocess provides a way of sending UNIX signals (&lt;code&gt;SIGKILL&lt;/code&gt;, &lt;code&gt;SIGTERM&lt;/code&gt;, etc.) to the spawned process. There are many scenarios in which this is useful, such us terminating or killing an existing process for whatever reason you have. Some OS commands, like &lt;code&gt;tail -f&lt;/code&gt;, do not even finish unless you explicitly tell it to do so. If we consider again the &lt;code&gt;tail -f&lt;/code&gt; example you may now realize that that process will run forever.&lt;/p&gt;
&lt;p&gt;Which signals to send and when it completely up to the user. Under the protocol &lt;code&gt;OS signal sending&lt;/code&gt;, the class &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; provides one method per signal. Examples: &lt;code&gt;#sigterm&lt;/code&gt;, &lt;code&gt;#sigkill&lt;/code&gt;, &lt;code&gt;#sigint&lt;/code&gt;, &lt;code&gt;#sighup&lt;/code&gt;, etc. Each of those methods will simply send the signal in question to the external process.&lt;/p&gt;
&lt;p&gt;See this example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;| &lt;span class="pl-c1"&gt;counter&lt;/span&gt; |
counter &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;0&lt;/span&gt;.
[  
	&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;tail&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-f' '/var/log/system.log' )&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitPollingEvery:&lt;/span&gt; (&lt;span class="pl-c1"&gt;Delay&lt;/span&gt; &lt;span class="pl-c1"&gt;forMilliseconds:&lt;/span&gt; &lt;span class="pl-c1"&gt;500&lt;/span&gt;)
	&lt;span class="pl-c1"&gt;doing:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outStream&lt;/span&gt;  |  
		counter &lt;span class="pl-k"&gt;:=&lt;/span&gt; counter &lt;span class="pl-k"&gt;+&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;.
		&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; outStream upToEnd; cr.
		counter &lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;10&lt;/span&gt; &lt;span class="pl-k"&gt;ifTrue:&lt;/span&gt; [ process sigterm ]
	]
	&lt;span class="pl-c1"&gt;onExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outStream&lt;/span&gt; &lt;span class="pl-en"&gt;:errStream&lt;/span&gt;  |
		process closeAndCleanStreams.
		&lt;span class="pl-c1"&gt;Transcript&lt;/span&gt; &lt;span class="pl-c1"&gt;show:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Process has exited with status: &lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;, process exitStatusInterpreter printString; cr.
	]
] fork.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you open a &lt;code&gt;Transcript&lt;/code&gt; and execute above example, you will see how the changes to &lt;code&gt;/var/log/system.log&lt;/code&gt; are displayed there for approx. 5 seconds and then it stops. It should have also printed &lt;code&gt;Process has exited with status: exit due to signal 15&lt;/code&gt;, demonstrating that the exit is managed correctly. In addition, it shows up how the &lt;code&gt;exitStatusInterpreter&lt;/code&gt; correctly interprets that the exit of the process was due to signal 15, which is &lt;code&gt;SIGTERM&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Again, when and which signals to send depends on the user.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-system-shutdown" class="anchor" aria-hidden="true" href="#system-shutdown"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;System shutdown&lt;/h3&gt;
&lt;p&gt;What would happen if you are running an asynchronous process (with &lt;code&gt;#fork&lt;/code&gt;) and Pharo quits? Pharo can quit because of a crash, because the user accidentally quits it, or any other reason.&lt;/p&gt;
&lt;p&gt;By default, when Pharo is quitting, the &lt;code&gt;OSSVMProcess vmProcess&lt;/code&gt; tells all active children to &lt;code&gt;#stopWaiting&lt;/code&gt;. The &lt;code&gt;#stopWaiting&lt;/code&gt; basically makes children to stop waiting for the external process and just finish. This allows the external process to finish (at the OS level), even if Pharo has quitted. In this scenario, its likely the child to become an &lt;em&gt;orphan&lt;/em&gt; process since it's parent has die (Pharo VM). Orphan processes do what is called  &lt;code&gt;re-parenting&lt;/code&gt; which basically means they become children of the &lt;code&gt;init&lt;/code&gt; process.&lt;/p&gt;
&lt;p&gt;Contrary to the default behavior, we also provide the method &lt;code&gt;OSSUnixSubprocess &amp;gt;&amp;gt; terminateOnShutdown&lt;/code&gt; which tells the system to automatically &lt;strong&gt;terminate&lt;/strong&gt; (via &lt;code&gt;sigterm&lt;/code&gt;) the external process when Pharo is quitting. We also collect the exit status in this case.&lt;/p&gt;
&lt;p&gt;It depends on the user which behavior he wants.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-environment-variables" class="anchor" aria-hidden="true" href="#environment-variables"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Environment variables&lt;/h3&gt;
&lt;h4&gt;&lt;a id="user-content-setting-environment-variables" class="anchor" aria-hidden="true" href="#setting-environment-variables"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Setting environment variables&lt;/h4&gt;
&lt;p&gt;One common requirement for child processes is to define environment variables for them, that may not even exist in the parent process. Let's see an example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/usr/bin/git&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-C' '/Users/mariano/git/OSSubprocess' 'commit')&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;environmentAt:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;GIT_EDITOR&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;put:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/Users/mariano/bin/mate&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt;  |]&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example we are executing &lt;code&gt;/usr/bin/git&lt;/code&gt; and we are telling it to commit from the directory &lt;code&gt;/Users/mariano/git/OSSubprocess&lt;/code&gt;. Without any particular environment variable setting, &lt;code&gt;git&lt;/code&gt; will use the default editor. In my machine, it will use &lt;code&gt;nano&lt;/code&gt; editor. However, in above example, we are setting a environment variable called &lt;code&gt;GIT_EDITOR&lt;/code&gt; (which is &lt;em&gt;not&lt;/em&gt; set in parent process) with the value &lt;code&gt;/Users/mariano/bin/mate&lt;/code&gt; (TextMate editor for OSX). When we run this example, &lt;code&gt;git&lt;/code&gt; will then use TextMate for entering the commit message instead of &lt;code&gt;nano&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-variables-are-not-expanded" class="anchor" aria-hidden="true" href="#variables-are-not-expanded"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Variables are not expanded&lt;/h4&gt;
&lt;p&gt;You should not confuse the above example with variables expansions. Consider now this example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/echo&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('${HOME}')&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;environmentAt:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;HOME&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;put:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;hello&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:command&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; |
		outString inspect
	].&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;What do you expect to be the &lt;code&gt;outString&lt;/code&gt;? Well, the answer is the literal string &lt;code&gt;${HOME}&lt;/code&gt;. This is because OSSubprocess does &lt;em&gt;not&lt;/em&gt; expands variables. It does &lt;em&gt;set&lt;/em&gt; variables, but that's not the same as expanding them.&lt;/p&gt;
&lt;p&gt;Variable expansion is a responsibility of the shell, not of the command. Specific commands will of course consult their environment, but only for variables that they are designed to use (e.g. &lt;code&gt;git&lt;/code&gt; will use $GIT_EDITOR or fall back to $EDITOR when you have to type a commit message).&lt;/p&gt;
&lt;p&gt;To conclude this topic, see this example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/sh&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('-c' 'echo ${HOME}')&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;environmentAt:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;HOME&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;put:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;hello&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:command&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; |
		outString inspect. 	
	].&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this case, the &lt;code&gt;outString&lt;/code&gt; is indeed &lt;code&gt;hello&lt;/code&gt; and this is simply because &lt;code&gt;/bin/sh&lt;/code&gt; did the variable expansion before executing the &lt;code&gt;echo&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-accessing-environment-variables" class="anchor" aria-hidden="true" href="#accessing-environment-variables"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Accessing environment variables&lt;/h4&gt;
&lt;p&gt;It seems some people use OSProcess (or maybe even OSSubprocess) to access environment variables. &lt;strong&gt;This is not needed and it's not the best approach&lt;/strong&gt;. Pharo provides an out of the box way for accessing environment variables. For example, &lt;code&gt;Smalltalk platform environment at: 'PWD'&lt;/code&gt; answers &lt;code&gt;/Users/mariano/Pharo/imagenes&lt;/code&gt;. So, use that API for retrieving environment variables.&lt;/p&gt;
&lt;p&gt;Finally, not that you can "expand" yourself the value of a variable prior to spawning a process and hence avoid the need of the shell. example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/bin/echo&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; (&lt;span class="pl-c1"&gt;Array&lt;/span&gt; &lt;span class="pl-c1"&gt;with:&lt;/span&gt; (&lt;span class="pl-k"&gt;Smalltalk&lt;/span&gt; platform environment &lt;span class="pl-c1"&gt;at:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;HOME&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;));
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:command&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; |
		outString inspect
	].&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, &lt;code&gt;outString&lt;/code&gt; will be &lt;code&gt;/Users/mariano&lt;/code&gt;.&lt;/p&gt;
&lt;h4&gt;&lt;a id="user-content-inherit-variables-from-parent" class="anchor" aria-hidden="true" href="#inherit-variables-from-parent"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Inherit variables from parent&lt;/h4&gt;
&lt;p&gt;If you don't define any variable via &lt;code&gt;#environmentAt:put:&lt;/code&gt;, then by default, we will make the child process inherit all the variables from the parent process. If you did define at least one variable, then by default the child inherits no variable. However, you have the method &lt;code&gt;#addAllEnvVariablesFromParentWithoutOverride&lt;/code&gt; which basically adds all the variables inherit from the parent but those that you have explicitly set (if any).&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-shell-commands" class="anchor" aria-hidden="true" href="#shell-commands"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Shell commands&lt;/h3&gt;
&lt;p&gt;Sometimes, the process you want to execute is a shell. There are a couple of reasons for doing so:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Variables expansion.&lt;/li&gt;
&lt;li&gt;Pipelines.&lt;/li&gt;
&lt;li&gt;When there is already logic in &lt;code&gt;.bash_profile&lt;/code&gt;, &lt;code&gt;.profile&lt;/code&gt; or such kind of file.&lt;/li&gt;
&lt;li&gt;Command path resolution.&lt;/li&gt;
&lt;li&gt;Streams redirection.&lt;/li&gt;
&lt;li&gt;Available shell scripts that you want to execute.&lt;/li&gt;
&lt;li&gt;Convenience when you don't need to have full control.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Quite some of that list can easily be done without the need of a shell, as already explained. But some of them, still need the shell. To avoid having to invoke a shell as seen in &lt;a href="#variables-are-not-expanded"&gt;Variables are not expanded&lt;/a&gt;, we provide the methods &lt;code&gt;#shellCommand:&lt;/code&gt; and &lt;code&gt;#shell:command:&lt;/code&gt;. Example:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;shellCommand:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;ps -fea | grep Pharo &amp;gt; /tmp/testShellCommandWithStreamRedirects.deleteme&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	redirectStdout;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:command&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; |
		outString inspect. 					
	].&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Of course, &lt;code&gt;outString&lt;/code&gt; is empty now because the shell has redirected it to a particular file.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shellCommand:&lt;/code&gt; will first try to use the shell defined in the OS by getting the env variable &lt;code&gt;$SHELL&lt;/code&gt;. If not defined, then it will fallback to &lt;code&gt;/bin/sh&lt;/code&gt;. &lt;code&gt;#shell:command:&lt;/code&gt; is similar to &lt;code&gt;#shellCommand:&lt;/code&gt; but allows the user to specify the full path of the shell to use (for example &lt;code&gt;/bin/zsh&lt;/code&gt;).&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that when using the shell you must type the command exactly as the shell expects it, that is, with all the escaping and everything needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id="user-content-setting-working-directory" class="anchor" aria-hidden="true" href="#setting-working-directory"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Setting working directory&lt;/h3&gt;
&lt;p&gt;Another common need when spawning processes is to set a working directory (&lt;code&gt;PWD&lt;/code&gt;) for them. If none is set, by default, they inherit the working directory of the parent. Imagine the Pharo image was launched from a terminal while &lt;code&gt;PWD&lt;/code&gt; was &lt;code&gt;/Users/mariano&lt;/code&gt;. Now imagine I want to spawn a process for a git commit for the directory &lt;code&gt;/Users/mariano/git/OSSubprocess&lt;/code&gt;. For this to work, I must specify the working directory for the child. Otherwise, the &lt;code&gt;commit&lt;/code&gt; will be triggered in &lt;code&gt;/Users/mariano&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To support this, we provide the method &lt;code&gt;#workingDirectory:&lt;/code&gt; as this example shows:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;OSSUnixSubprocess&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;command:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/usr/bin/git&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;arguments:&lt;/span&gt; &lt;span class="pl-c1"&gt;#('commit' '-m' 'testing')&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;workingDirectory:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;/Users/mariano/git/OSSubprocess&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	redirectStdout;
	redirectStderr;
	&lt;span class="pl-c1"&gt;runAndWaitOnExitDo:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:process&lt;/span&gt; &lt;span class="pl-en"&gt;:outString&lt;/span&gt; &lt;span class="pl-en"&gt;:errString&lt;/span&gt; |
		errString inspect.
		outString inspect.
		]&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;The implementation of &lt;code&gt;#workingDirectory::&lt;/code&gt; is quite rudimentary and bad from performance point of view (read the method comment for details). If the program you are executing allows you to specify the path, then we recommend you to do so. For example, in this case, &lt;code&gt;git&lt;/code&gt; allow us to specify the path with the argument &lt;code&gt;-C&lt;/code&gt;. That approach would be better, as shown in &lt;a href="#setting-environment-variables"&gt;Setting environment variables&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;##Running the tests
You need to run the tests of the package &lt;code&gt;OSSubprocess-Tests&lt;/code&gt;. The current test coverage is about 65%. You may want to take a look to our &lt;a href="https://travis-ci.org/marianopeck/OSSubprocess/" rel="nofollow"&gt;Travis CI integration&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Contributing&lt;/h2&gt;
&lt;p&gt;This project is developed with &lt;a href="https://github.com/dalehenrich/filetree"&gt;GitFileTree&lt;/a&gt;, which, starting in Pharo 5.0, provides what is called &lt;code&gt;Metadata-less&lt;/code&gt; FileTree. That basically means that there are certain FileTree files (&lt;code&gt;version&lt;/code&gt; and &lt;code&gt;methodProperties&lt;/code&gt;) which are not created. &lt;strong&gt;Therefore, you cannot use regular FileTree to contribute to this project. You must use &lt;code&gt;GitFileTree&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The following are the steps to contribute to this project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fork it using Github web interface!&lt;/li&gt;
&lt;li&gt;Clone it to your local machine: &lt;code&gt;git clone git@github.com:YOUR_NAME/OSSubprocess.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create your feature branch: &lt;code&gt;git checkout -b MY_NEW_FEATURE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Download latest Pharo 5.0 and load GitFileTree and this project:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
 	&lt;span class="pl-c1"&gt;baseline:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;FileTree&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
   	&lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;github://dalehenrich/filetree:issue_171/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
   	&lt;span class="pl-c1"&gt;load:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Git&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;.
&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;baseline:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;OSSubprocess&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
 	&lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;gitfiletree:///path/to/your/local/clone/OSSubprocess/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;onConflict:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:ex&lt;/span&gt; | ex allow ];
	load.&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;You can now perform the changes you want at Pharo level and commit using the regular Monticello Browser.&lt;/li&gt;
&lt;li&gt;Run all OSSubprocess tests to make sure you did not break anything.&lt;/li&gt;
&lt;li&gt;Push to the branch. Either from MC browser of with &lt;code&gt;git push origin MY_NEW_FEATURE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Submit a pull request from github web interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-history" class="anchor" aria-hidden="true" href="#history"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;History&lt;/h2&gt;
&lt;p&gt;You can see the whole changelog of the project &lt;a href="CHANGELOG.md"&gt;Changelog&lt;/a&gt; for details about the release history.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-future-work" class="anchor" aria-hidden="true" href="#future-work"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Future work&lt;/h2&gt;
&lt;p&gt;Besides the &lt;a href="https://github.com/marianopeck/OSSubprocess/issues"&gt;issues&lt;/a&gt;, the following are also desired features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of using asynchronous I/O operations with FFI blocking callouts, sse synchronous I/O operations but with threaded FFI callouts. This will only be possible once Pharo VM and FFI supports threaded callouts.&lt;/li&gt;
&lt;li&gt;Experiment with a VM plugin with a single &lt;code&gt;forkAndExec&lt;/code&gt; kind of primitive (based on OSProcess one) and avoid using &lt;code&gt;posix_spawn()&lt;/code&gt; family of functions.&lt;/li&gt;
&lt;li&gt;Experiment with a Windows support by calling via FFI to &lt;code&gt;CreateProcess()&lt;/code&gt;. Note there is a VM plugin called &lt;a href="http://leves.web.elte.hu/ProcessWrapper/" rel="nofollow"&gt;ProcessorWrapper&lt;/a&gt; that wraps such a function. So we can base our work from it.&lt;/li&gt;
&lt;li&gt;Implement a pipeline at Pharo level. That is, to be able to create multiple instances of &lt;code&gt;OSSUnixSubprocess&lt;/code&gt; which we will be piped each other. We can base our work in OSProcess &lt;code&gt;ProxyPipeline&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-authors" class="anchor" aria-hidden="true" href="#authors"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Authors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mariano Martinez Peck&lt;/strong&gt; - &lt;em&gt;Initial work&lt;/em&gt; - &lt;a href="https://github.com/marianopeck"&gt;Mariano Martinez Peck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also the list of &lt;a href="https://github.com/marianopeck/OSSubprocess/contributors"&gt;contributors&lt;/a&gt; who participated in this project.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-license" class="anchor" aria-hidden="true" href="#license"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;License&lt;/h2&gt;
&lt;p&gt;This project is licensed under the MIT License - see the &lt;a href="LICENSE"&gt;LICENSE&lt;/a&gt; file for details&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-acknowledgments" class="anchor" aria-hidden="true" href="#acknowledgments"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;OSSubprocess is highly influenced by a subset of the &lt;a href="http://wiki.squeak.org/squeak/708" rel="nofollow"&gt;OSProcess&lt;/a&gt; project. There are parts which we even copied and adapted them (OSSPipe, OSSAttachableStream, OSSUnixProcessExitStatus). Other parts, we took them as inspiration (the idea of ThisOSProcess representing the VM process, the child watcher, and many others). In addition, OSSubprocess currently uses some of the OSProcess &lt;strong&gt;plugin&lt;/strong&gt; (not OSProcess image side), such as the SIGCHLD handler or the creation of pipes.&lt;/li&gt;
&lt;li&gt;Took some ideas from &lt;a href="https://github.com/theseion/liblimbo"&gt;Limbo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-funding" class="anchor" aria-hidden="true" href="#funding"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Funding&lt;/h2&gt;
&lt;p&gt;This project is sponsored by the &lt;a href="http://consortium.pharo.org/" rel="nofollow"&gt;Pharo Consortium&lt;/a&gt;.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>pharo-contributions</author><guid isPermaLink="false">https://github.com/pharo-contributions/OSSubprocess</guid><pubDate>Sun, 12 Jan 2020 00:01:00 GMT</pubDate></item><item><title>marianopeck/FFICHeaderExtractor #2 in Smalltalk, Today</title><link>https://github.com/marianopeck/FFICHeaderExtractor</link><description>&lt;p&gt;&lt;i&gt;Program to extract constants from C headers and integrate that as FFI SharedPools&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="" class="anchor" aria-hidden="true" href="#"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href="https://travis-ci.org/marianopeck/FFICHeaderExtractor" rel="nofollow"&gt;&lt;img src="https://camo.githubusercontent.com/311875d93f84ce26d67bd1f3b7ef6fc2cabbf440/68747470733a2f2f7472617669732d63692e6f72672f6d617269616e6f7065636b2f46464943486561646572457874726163746f722e706e673f6272616e63683d6d6173746572" alt="Build Status" data-canonical-src="https://travis-ci.org/marianopeck/FFICHeaderExtractor.png?branch=master" style="max-width:100%;"&gt;&lt;/a&gt;&lt;/h1&gt;
&lt;h1&gt;&lt;a id="user-content-fficheaderextractor" class="anchor" aria-hidden="true" href="#fficheaderextractor"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;FFICHeaderExtractor&lt;/h1&gt;
&lt;p&gt;In short, FFICHeaderExtractor is a program to extract information (e.g. constants) from &lt;code&gt;C&lt;/code&gt; headers and integrate that into Smalltalk &lt;code&gt;SharedPools&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we use FFI to call a certain library, it's quite common that we need to pass specific constants (for example, &lt;code&gt;SIGKILL&lt;/code&gt; to &lt;code&gt;kill()&lt;/code&gt;). These constants are defined in &lt;code&gt;C&lt;/code&gt; header files and can even change their values in different paltforms. Sometimes, these constants also are defined by the &lt;code&gt;C&lt;/code&gt; preprocessor and so there is not way to get those values from FFI. If you don't have the value of those constants, you cannot make the FFI call. In other words, if I cannot know that the value of &lt;code&gt;SIGKILL&lt;/code&gt; is &lt;code&gt;9&lt;/code&gt;, how do I call &lt;code&gt;kill()&lt;/code&gt; from FFI?&lt;/p&gt;
&lt;p&gt;This tool allows the developers of a FFI tool (any project which uses FFI to call a certain library), to automatically create a &lt;code&gt;C&lt;/code&gt; program that writes all the user-defined constants values, compile it, run it, and create a Smalltalk init method which initializes the shared pool constants based on &lt;code&gt;C&lt;/code&gt; program output. This autogenerated init method can then be distributed with the rest of the FFI tool. FFICHeaderExtractor will also automatically initialize (searching and executing the previously autogenerated init method for the current platform) a &lt;code&gt;SharedPool&lt;/code&gt; upon system startup.&lt;/p&gt;
&lt;p&gt;##Table of Contents&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#fficheaderextractor"&gt;FFICHeaderExtractor&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#table-of-contents"&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#installation"&gt;Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#getting-started"&gt;Getting Started&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#defining-and-using-a-ffisharedpool-with-ffi"&gt;Defining and using a FFISharedPool with FFI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#extracting-and-storing-constants-information"&gt;Extracting and storing constants information&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#initializing-variables-from-autogenerated-method"&gt;Initializing variables from autogenerated method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#deploying-the-ffi-tool-with-autogenerated-methods"&gt;Deploying the FFI tool with autogenerated methods&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#running-the-tests"&gt;Running the tests&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#contributing"&gt;Contributing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#history"&gt;History&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#future-work"&gt;Future work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#authors"&gt;Authors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#license"&gt;License&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#acknowledgments"&gt;Acknowledgments&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#funding"&gt;Funding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-installation" class="anchor" aria-hidden="true" href="#installation"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Installation&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;FFICHeaderExtractor currently only works in Pharo 5.0 with Spur VM&lt;/strong&gt;. Until Pharo 5.0 is released, we recommend to always grab a latest image and VM. You can do that in via command line:&lt;/p&gt;
&lt;div class="highlight highlight-source-shell"&gt;&lt;pre&gt;wget -O- get.pharo.org/alpha+vm &lt;span class="pl-k"&gt;|&lt;/span&gt; bash&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, from within Pharo, execute the following to install FFICHeaderExtractor:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
    &lt;span class="pl-c1"&gt;configuration:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;FFICHeaderExtractor&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
    &lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;github://marianopeck/FFICHeaderExtractor:master/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;version:&lt;/span&gt; &lt;span class="pl-c1"&gt;#stable&lt;/span&gt;;
    load.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Besides the above installation instructions, FFICHeaderExtractor can also be installed from the &lt;code&gt;Catalog Browser&lt;/code&gt;, already present in Pharo. Just open it, search for FFICHeaderExtractor, then right click, &lt;code&gt;Install stable version&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Important: so far FFICHeaderExtractor works only in OSX and Unix.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;a id="user-content-getting-started" class="anchor" aria-hidden="true" href="#getting-started"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Getting Started&lt;/h2&gt;
&lt;p&gt;The user of this tool will be a developer of a FFI-based project. As an example, let's say we want to call some functions from the &lt;code&gt;libc&lt;/code&gt; (the standard C library) via FFI. &lt;code&gt;libc&lt;/code&gt; is huge and it has lots of functions and constants. For our example we will take only a small portion of it.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-defining-and-using-a-ffisharedpool-with-ffi" class="anchor" aria-hidden="true" href="#defining-and-using-a-ffisharedpool-with-ffi"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Defining and using a FFISharedPool with FFI&lt;/h3&gt;
&lt;p&gt;The first step is to define your own subclass of &lt;code&gt;FFISharedPool&lt;/code&gt; and define all the constants you want to retrieve their values, as class variables:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-e"&gt;FFISharedPool&lt;/span&gt; &lt;span class="pl-k"&gt;subclass:&lt;/span&gt; &lt;span class="pl-c1"&gt;#LibCSharedPool&lt;/span&gt;
	&lt;span class="pl-c1"&gt;instanceVariableNames:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;classVariableNames:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;EINVAL EPERM SIGCHLD SIGCONT SIGINFO SIGKILL SIGPOLL SIGSTOP SIGTERM&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;package:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;LibC&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In this example, we pick up only some signals and some errors. Let's now see the user of this &lt;code&gt;SharedPool&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-e"&gt;Object&lt;/span&gt; &lt;span class="pl-k"&gt;subclass:&lt;/span&gt; &lt;span class="pl-c1"&gt;#LibCWrapper&lt;/span&gt;
	&lt;span class="pl-c1"&gt;instanceVariableNames:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;classVariableNames:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;poolDictionaries:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;LibCSharedPool&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;package:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;LibC&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The imporant line there is &lt;code&gt;poolDictionaries: 'LibCSharedPool'&lt;/code&gt; were we declare that we want to use &lt;code&gt;LibCSharedPool&lt;/code&gt;. The &lt;code&gt;LibCWrapper&lt;/code&gt; is then able to do this:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCWrapper&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;stopProcess:&lt;/span&gt; aPidNumber
	&lt;span class="pl-k"&gt;self&lt;/span&gt; &lt;span class="pl-c1"&gt;primitiveKill:&lt;/span&gt; aPidNumber &lt;span class="pl-k"&gt;signal&lt;/span&gt;: &lt;span class="pl-c1"&gt;SIGSTOP&lt;/span&gt;.&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCWrapper&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;continueProcess:&lt;/span&gt; aPidNumber
	&lt;span class="pl-k"&gt;self&lt;/span&gt; &lt;span class="pl-c1"&gt;primitiveKill:&lt;/span&gt; aPidNumber &lt;span class="pl-k"&gt;signal&lt;/span&gt;: &lt;span class="pl-c1"&gt;SIGCONT&lt;/span&gt;.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;SIGSTOP&lt;/code&gt; and &lt;code&gt;SIGCONT&lt;/code&gt; are signals which, via &lt;code&gt;kill()&lt;/code&gt;, can pause a process with it's current state and  then resume it's execution later. The details of &lt;code&gt;primitiveKill:signal:&lt;/code&gt; is not important for this example as it is the simple FFI call to &lt;code&gt;int kill(pid_t pid, int sig)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The important part here is that thanks to &lt;code&gt;SharedPools&lt;/code&gt;, the &lt;code&gt;LibCSharedPool&lt;/code&gt; code can access directly to &lt;code&gt;SIGSTOP&lt;/code&gt; and &lt;code&gt;SIGCONT&lt;/code&gt; as if they were class variables. However, these are the class variables defined in &lt;code&gt;LibCWrapper&lt;/code&gt;. For above code to really work, the class variables of &lt;code&gt;LibCSharedPool&lt;/code&gt; must be initialized with the correct values. If we were using &lt;code&gt;SIGKILL&lt;/code&gt; or &lt;code&gt;SIGTERM&lt;/code&gt; for example, it's very likely that the values of them are &lt;code&gt;9&lt;/code&gt; and &lt;code&gt;15&lt;/code&gt; in almost every possible platform. But that's not the case of &lt;code&gt;SIGSTOP&lt;/code&gt; and &lt;code&gt;SIGCONT&lt;/code&gt;. Do you know their values? Are you sure they do not change among platforms? As we will read later, these constants &lt;strong&gt;do change&lt;/strong&gt; between platforms.&lt;/p&gt;
&lt;p&gt;This problematic is part of what FFICHeaderExtractor solves. Let's see how.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-extracting-and-storing-constants-information" class="anchor" aria-hidden="true" href="#extracting-and-storing-constants-information"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Extracting and storing constants information&lt;/h3&gt;
&lt;p&gt;Once you have defined your own &lt;code&gt;FFISharedPool&lt;/code&gt; subclass and the constants for which you would like to get the values, the next step is to give more information to FFICHeaderExtractor so that it can extract the definitions from &lt;code&gt;C&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The created &lt;code&gt;FFISharedPool&lt;/code&gt; subclass, must implement the class side method &lt;code&gt;#headersContainingVariables&lt;/code&gt; which answers an array with the &lt;code&gt;C&lt;/code&gt; header names that define all the defined constants. In the example of &lt;code&gt;LibCSharedPool&lt;/code&gt; we have singal constants (defined in &lt;code&gt;signal.h&lt;/code&gt;) and error constants (defined in &lt;code&gt;errno.h&lt;/code&gt;). Therefore:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCSharedPool&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; headersContainingVariables
	&lt;span class="pl-k"&gt;^&lt;/span&gt; &lt;span class="pl-c1"&gt;#( 'errno.h' 'signal.h' )&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;blockquote&gt;
&lt;p&gt;For many cases, this is all the needed information. We will later see cases where more definitions are needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The last step for the developer of the FFI tool (&lt;code&gt;LibCWrapper&lt;/code&gt; in our example) is to trigger the extraction itself. The way of doing this is:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCSharedPool&lt;/span&gt; extractAndStoreHeadersInformation&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;As explained later, to be able to run &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt; the user must have installed and reached by &lt;code&gt;$PATH&lt;/code&gt;, &lt;code&gt;cc&lt;/code&gt; (LLVM Clang) in OSX and &lt;code&gt;gcc&lt;/code&gt; in Unix.&lt;/p&gt;
&lt;p&gt;The method &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt; first extracts all the constants values (defined in C header files) &lt;strong&gt;from the current running platform&lt;/strong&gt; and then creates a Smalltalk init method which is then compiled into the SharedPool. So, for example, if I execute such a method in OSX with a Pharo 32 bits VM, then the resulting autogenerated method is this:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCSharedPool&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; initVariablesMacOS32
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;&lt;span class="pl-c1"&gt;platformName:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Mac OS&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;wordSize:&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;EINVAL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;22&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;EPERM&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGCHLD&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;20&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGCONT&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;19&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGINFO&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;29&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGKILL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;9&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGPOLL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;nil&lt;/span&gt;.&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;SIGPOLL is UNDEFINED for this platform&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;SIGSTOP&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;17&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGTERM&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;15&lt;/span&gt;.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that the selector of the autogenerated method is &lt;code&gt;#initVariablesMacOS32&lt;/code&gt; which matches the platform used to run &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt;. If later we have Pharo 64 bits VM, then we should also run &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt; with such a VM. Here is the example when running in Linux 32 bits:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;initVariablesunix32
&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;Method automatically generated by FFICHeaderExtractor. Read more at https://github.com/marianopeck/FFICHeaderExtractor&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-k"&gt;&amp;lt;&lt;/span&gt;&lt;span class="pl-c1"&gt;platformName:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;unix&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class="pl-c1"&gt;wordSize:&lt;/span&gt; &lt;span class="pl-c1"&gt;4&lt;/span&gt;&lt;span class="pl-k"&gt;&amp;gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;EINVAL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;22&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;EPERM&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;1&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGCHLD&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;17&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGCONT&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;18&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGINFO&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;nil&lt;/span&gt;.&lt;span class="pl-c"&gt;&lt;span class="pl-c"&gt;"&lt;/span&gt;SIGINFO is UNDEFINED for this platform&lt;span class="pl-c"&gt;"&lt;/span&gt;&lt;/span&gt;
	&lt;span class="pl-c1"&gt;SIGKILL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;9&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGPOLL&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;29&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGSTOP&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;19&lt;/span&gt;.
	&lt;span class="pl-c1"&gt;SIGTERM&lt;/span&gt; &lt;span class="pl-k"&gt;:=&lt;/span&gt; &lt;span class="pl-c1"&gt;15&lt;/span&gt;.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you compare &lt;code&gt;#initVariablesunix32&lt;/code&gt; and &lt;code&gt;initVariablesMacOS32&lt;/code&gt; you can get some interesting conclusions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some constants do not have the same value in OSX and in Linux. In fact, the ones we use in this example (&lt;code&gt;SIGSTOP&lt;/code&gt; and &lt;code&gt;SIGCONT&lt;/code&gt;) are different. So, without FFICHeaderExtractor this example would have been difficult to implement.&lt;/li&gt;
&lt;li&gt;Not all constants are defined in all OS. For example, &lt;code&gt;SIGINFO&lt;/code&gt; is defined in OSX but not in Linux, and &lt;code&gt;SIGPOLL&lt;/code&gt; the other way around.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The information embebed as part of the selectors of the methods is just for organization. When FFICHeaderExtractor needs to search the correct method for the current platform, it uses the &lt;code&gt;platformName&lt;/code&gt; and &lt;code&gt;wordSize&lt;/code&gt; of the pragma of the autogenerated method, not the selector itself.&lt;/p&gt;
&lt;p&gt;The developer of the FFI tool is responsible of running &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt; for every platform he needs. Ideally, the developer could have a CI (continuous integration) server that automatically runs this for every platform.&lt;/p&gt;
&lt;h3&gt;&lt;a id="user-content-initializing-variables-from-autogenerated-method" class="anchor" aria-hidden="true" href="#initializing-variables-from-autogenerated-method"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Initializing variables from autogenerated method&lt;/h3&gt;
&lt;p&gt;Upon Pharo startup, &lt;code&gt;FFISharedPool&lt;/code&gt; analyses each subclass to see which ones require the initialization of the class variables. When the initialization of class variables does happen, then the used &lt;code&gt;platformName&lt;/code&gt; and &lt;code&gt;wordSize&lt;/code&gt; are stored in the SharedPool. This way, next system startup we can check if the platform has changed compared to what we have stored (like running the image in another OS). If the platform has changed or if the class variables were never initialized before, then &lt;code&gt;FFISharedPool&lt;/code&gt; will try to do the initialization by sending the message &lt;code&gt;#initializeVariables&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#initializeVariables&lt;/code&gt; simply searches an autogenerated method whose &lt;code&gt;platformName&lt;/code&gt; and &lt;code&gt;wordSize&lt;/code&gt; matches the running platform. If the method is found, then it is executed and platform information is stored. If not found, then it simply prints an error into the &lt;code&gt;Transcript&lt;/code&gt; saying an init methd could not be found for the desired paltform.&lt;/p&gt;
&lt;p&gt;For when we are &lt;em&gt;developing&lt;/em&gt; the FFI tool, we don't want to quit Pharo and start again every time want to initialize variables again. For this cases, you can simply force the autogeneration and initialization this way:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCSharedPool&lt;/span&gt;
	extractAndStoreHeadersInformation;
	initializeVariables.&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You can now check the values of the class variables to confirm they were correctly initialized.&lt;/p&gt;
&lt;p&gt;Sometimes you want the end user of the FFI tool to be able to use it just after loading it, without any Pharo quit and start, and without having to manually execute the initialization. For this, our recommended approach is to simply create this method for each &lt;code&gt;FFISharedPool&lt;/code&gt; subclass:&lt;/p&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;LibCSharedPool&lt;/span&gt; &lt;span class="pl-k"&gt;class&lt;/span&gt; &lt;span class="pl-k"&gt;&amp;gt;&amp;gt;&lt;/span&gt; initialize
	&lt;span class="pl-k"&gt;self&lt;/span&gt; initializeVariables&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That way, when the package is being loaded, Pharo will automatically send the class side &lt;code&gt;#initialize&lt;/code&gt; to &lt;code&gt;LibCSharedPool&lt;/code&gt; and such a method will initialize the class variables with the autogenerated methods.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;To conclude: end users of the FFI tool have nothing to do as starting Pharo will automatically initialize the class variables of the shared pools.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;a id="user-content-deploying-the-ffi-tool-with-autogenerated-methods" class="anchor" aria-hidden="true" href="#deploying-the-ffi-tool-with-autogenerated-methods"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Deploying the FFI tool with autogenerated methods&lt;/h3&gt;
&lt;p&gt;The developers of the FFI tool should extract constants and autogenerate the init method (send &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt;) for every platform they wish to support. The result will be the autogenerated methods like &lt;code&gt;#initVariablesMacOS32&lt;/code&gt;, &lt;code&gt;#initVariablesMacOS64&lt;/code&gt;, &lt;code&gt;#initVariablesunix32&lt;/code&gt;, &lt;code&gt;#initVariablesunix64&lt;/code&gt;, etc. All these methods are organized in a protocol called &lt;code&gt;autogenerated by FFICHeaderExtractor&lt;/code&gt; of the particular SharedPool (&lt;code&gt;LibCSharedPool&lt;/code&gt; in our example).&lt;/p&gt;
&lt;p&gt;As we also said, to be able to run &lt;code&gt;#extractAndStoreHeadersInformation&lt;/code&gt;, the developer needs C compiler installed.&lt;/p&gt;
&lt;p&gt;Once the autogenerated init methods are created, they should be versioned, distributed and deployed as any other method of the SharedPool class.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The end users of the FFI tool (not the developers) do not need a C compiler at all, nor to extract any constant. The end users do not even need to manually initialize the class variables of the SharedPool as that also happens automatically.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;##Running the tests
You need to run the tests of the package &lt;code&gt;FFICHeaderExtractor-Tests&lt;/code&gt;. For running those, you need &lt;code&gt;cc&lt;/code&gt; (LLVM Clang) in OSX or &lt;code&gt;gcc&lt;/code&gt; in Unix, installed in your machine. The current test coverage is about 84%.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-contributing" class="anchor" aria-hidden="true" href="#contributing"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Contributing&lt;/h2&gt;
&lt;p&gt;This project is developed with &lt;a href="https://github.com/dalehenrich/filetree"&gt;GitFileTree&lt;/a&gt;, which, starting in Pharo 5.0, provides what is called &lt;code&gt;Metadata-less&lt;/code&gt; FileTree. That basically means that there are certain FileTree files (&lt;code&gt;version&lt;/code&gt; and &lt;code&gt;methodProperties&lt;/code&gt;) which are not created. &lt;strong&gt;Therefore, you cannot use regular FileTree to contribute to this project. You must use &lt;code&gt;GitFileTree&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The following are the steps to contribute to this project:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fork it using Github web interface!&lt;/li&gt;
&lt;li&gt;Clone it to your local machine: &lt;code&gt;git clone git@github.com:YOUR_NAME/FFICHeaderExtractor.git&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Create your feature branch: &lt;code&gt;git checkout -b MY_NEW_FEATURE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Download latest Pharo 5.0 and load GitFileTree and this project:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight highlight-source-smalltalk"&gt;&lt;pre&gt;&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
 	&lt;span class="pl-c1"&gt;baseline:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;FileTree&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
   	&lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;github://dalehenrich/filetree:issue_171/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
   	&lt;span class="pl-c1"&gt;load:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;Git&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;.
&lt;span class="pl-c1"&gt;Metacello&lt;/span&gt; &lt;span class="pl-k"&gt;new&lt;/span&gt;
	&lt;span class="pl-c1"&gt;baseline:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;FFICHeaderExtractor&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
 	&lt;span class="pl-c1"&gt;repository:&lt;/span&gt; &lt;span class="pl-s"&gt;&lt;span class="pl-pds"&gt;'&lt;/span&gt;gitfiletree:///path/to/your/local/clone/FFICHeaderExtractor/repository&lt;span class="pl-pds"&gt;'&lt;/span&gt;&lt;/span&gt;;
	&lt;span class="pl-c1"&gt;onConflict:&lt;/span&gt; [ &lt;span class="pl-en"&gt;:ex&lt;/span&gt; | ex allow ];
	load.&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;You can now perform the changes you want at Pharo level and commit using the regular Monticello Browser.&lt;/li&gt;
&lt;li&gt;Run all FFICHeaderExtractor tests to make sure you did not break anything.&lt;/li&gt;
&lt;li&gt;Push to the branch. Either from MC browser of with &lt;code&gt;git push origin MY_NEW_FEATURE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Submit a pull request from github web interface.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-history" class="anchor" aria-hidden="true" href="#history"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;History&lt;/h2&gt;
&lt;p&gt;You can see the whole changelog of the project &lt;a href="CHANGELOG.md"&gt;Changelog&lt;/a&gt; for details about the release history.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-future-work" class="anchor" aria-hidden="true" href="#future-work"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Future work&lt;/h2&gt;
&lt;p&gt;Besides the &lt;a href="https://github.com/marianopeck/FFICHeaderExtractor/issues"&gt;issues&lt;/a&gt;, the following are also desired features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Be able to extract structs information (internal organization and size). For this, as well as for other possible useful information, we could try to update the &lt;a href="http://smalltalkhub.com/#!/~CipT/LibClang" rel="nofollow"&gt;libclang wrapper&lt;/a&gt; to Pharo 5.0 and new FFI. And then use &lt;a href="http://smalltalkhub.com/#!/~CipT/TalkFFI" rel="nofollow"&gt;TalkFFI&lt;/a&gt; to get a Smalltalk-based visitor / AST on the C parsed code.&lt;/li&gt;
&lt;li&gt;Add support for compiling in Windows (&lt;code&gt;mingw&lt;/code&gt;?).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-authors" class="anchor" aria-hidden="true" href="#authors"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Authors&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mariano Martinez Peck&lt;/strong&gt; - &lt;em&gt;Initial work&lt;/em&gt; - &lt;a href="https://github.com/marianopeck"&gt;Mariano Martinez Peck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See also the list of &lt;a href="https://github.com/marianopeck/FFICHeaderExtractor/contributors"&gt;contributors&lt;/a&gt; who participated in this project.&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-license" class="anchor" aria-hidden="true" href="#license"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;License&lt;/h2&gt;
&lt;p&gt;This project is licensed under the MIT License - see the &lt;a href="LICENSE"&gt;LICENSE&lt;/a&gt; file for details&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-acknowledgments" class="anchor" aria-hidden="true" href="#acknowledgments"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Acknowledgments&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;FFICHeaderExtractor was an idea of Eliot Miranda which helped in many different ways to this project.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;&lt;a id="user-content-funding" class="anchor" aria-hidden="true" href="#funding"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Funding&lt;/h2&gt;
&lt;p&gt;This project is sponsored by the &lt;a href="http://consortium.pharo.org/" rel="nofollow"&gt;Pharo Consortium&lt;/a&gt;.&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>marianopeck</author><guid isPermaLink="false">https://github.com/marianopeck/FFICHeaderExtractor</guid><pubDate>Sun, 12 Jan 2020 00:02:00 GMT</pubDate></item><item><title>svenvc/zodiac #3 in Smalltalk, Today</title><link>https://github.com/svenvc/zodiac</link><description>&lt;p&gt;&lt;i&gt;Zodiac is an open-source Smalltalk framework implementing TLS/SSL secure as well as regular socket streams.&lt;/i&gt;&lt;/p&gt;&lt;div id="readme" class="md" data-path="README.md"&gt;&lt;article class="markdown-body entry-content p-5" itemprop="text"&gt;&lt;h1&gt;&lt;a id="user-content-zodiac-tlsssl" class="anchor" aria-hidden="true" href="#zodiac-tlsssl"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Zodiac TLS/SSL&lt;/h1&gt;
&lt;p&gt;Zodiac is an open-source, cross-smalltalk implementation of regular and secure socket streams.
The primary goal of the project is to offer TLS/SSL streams that can then be used to implement
for example HTTPS when combined with a suitable client such as Zinc HTTP Components.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://zdc.stfx.eu" rel="nofollow"&gt;http://zdc.stfx.eu&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a id="user-content-please-read-the-tlsssl-paper" class="anchor" aria-hidden="true" href="#please-read-the-tlsssl-paper"&gt;&lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Please read the &lt;a href="https://github.com/svenvc/zodiac/blob/master/zodiac-paper.md"&gt;TLS/SSL&lt;/a&gt; paper&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Sven Van Caekenberghe&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/svenvc/zodiac/blob/master/license.txt"&gt;MIT Licensed&lt;/a&gt;&lt;/p&gt;
&lt;/article&gt;&lt;/div&gt;</description><author>svenvc</author><guid isPermaLink="false">https://github.com/svenvc/zodiac</guid><pubDate>Sun, 12 Jan 2020 00:03:00 GMT</pubDate></item></channel></rss>